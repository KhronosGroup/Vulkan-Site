<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Variables and Types :: Vulkan Documentation Project</title>
    <meta name="generator" content="Antora 3.1.10">
    <script>
      !function (theme) {
        if (theme === 'dark') document.documentElement.classList.add('dark')
        else document.documentElement.classList.add('light')
      }(localStorage && localStorage.getItem('theme') || (matchMedia('(prefers-color-scheme: dark)')?.matches && 'dark'))
    </script>
    <link rel="stylesheet" href="../../../_/css/site.css">
    <link rel="apple-touch-icon" sizes="180x180" href="../../../_/img/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="../../../_/img/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="../../../_/img/favicon-16x16.png">
    <link rel="manifest" href="../../../_/static/site.webmanifest">
    <link rel="mask-icon" href="../../../_/img/safari-pinned-tab.svg" color="#a41e22">
    <meta name="msapplication-TileColor" content="#ffc40d">
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="../../.."><img class="navbar-item" alt="Vulkan White Label" src="../../../_/Vulkan_Docs.svg" /></a>
      <div class="navbar-item search hide-for-print">
        <div id="search-field" class="field has-filter">
          <label for="search-input"></label>
          <input id="search-input" type="text" placeholder="Search the docs">
          <label class="filter checkbox">
            <input type="checkbox" data-facet-filter="component:glsl" checked> In this component
          </label>
        </div>
      </div>
      <button class="navbar-burger" aria-controls="topbar-nav" aria-expanded="false" aria-label="Toggle main menu">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <!-- <a class="navbar-item" href="#">Home</a> -->
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Specs</a>
          <div class="navbar-dropdown is-right">
            <a class="navbar-item" href="../../../spec/latest/chapters/introduction.html">Vulkan API</a>
            <a class="navbar-item" href="../../../glsl/latest/index.html">GLSL</a>
            <a class="navbar-item" href="../../../guide/latest/hlsl.html">HLSL</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Education</a>
          <div class="navbar-dropdown is-right">
            <a class="navbar-item" href="../../../features/latest/features/index.html">Vulkan Feature Descriptions</a>
            <a class="navbar-item" href="../../../guide/latest/index.html">Vulkan Guide</a>
            <a class="navbar-item" href="../../../samples/latest/README.html">Vulkan Samples</a>
            <a class="navbar-item" href="../../../tutorial/latest/index.html">Vulkan Tutorial</a>
            <a class="navbar-item" href="https://www.youtube.com/c/vulkan">YouTube</a>
            <a class="navbar-item" href="https://vulkan.org">More Info at Vulkan.org</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Feedback</a>
          <div class="navbar-dropdown is-right">
            <a class="navbar-item" href="https://github.com/KhronosGroup/Vulkan-Site/issues/new/choose" target="_blank">Report a Problem</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Community</a>
          <div class="navbar-dropdown is-right">
            <a class="navbar-item" href="https://discord.gg/vulkan">Vulkan Discord</a>
            <a class="navbar-item" href="https://reddit.com/r/vulkan">Reddit</a>
            <a class="navbar-item" href="https://stackoverflow.com/questions/tagged/vulkan">Stack Overflow</a>
            <a class="navbar-item" href="https://fosstodon.org/@vulkan">Mastodon</a>
          </div>
        </div>
      </div>
    </div>
    <label class="theme-toggler">
      <input type="checkbox" id="switch-theme-checkbox" name="switch-theme-checkbox"/>
      <span class="icon"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="moon" class="svg-inline--fa fa-moon moon" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><path fill="currentColor" d="M223.5 32C100 32 0 132.3 0 256S100 480 223.5 480c60.6 0 115.5-24.2 155.8-63.4c5-4.9 6.3-12.5 3.1-18.7s-10.1-9.7-17-8.5c-9.8 1.7-19.8 2.6-30.1 2.6c-96.9 0-175.5-78.8-175.5-176c0-65.8 36-123.1 89.3-153.3c6.1-3.5 9.2-10.5 7.7-17.3s-7.3-11.9-14.3-12.5c-6.3-.5-12.6-.8-19-.8z"></path>
        </svg>
        <svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="sun" class="svg-inline--fa fa-sun sun" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M361.5 1.2c5 2.1 8.6 6.6 9.6 11.9L391 121l107.9 19.8c5.3 1 9.8 4.6 11.9 9.6s1.5 10.7-1.6 15.2L446.9 256l62.3 90.3c3.1 4.5 3.7 10.2 1.6 15.2s-6.6 8.6-11.9 9.6L391 391 371.1 498.9c-1 5.3-4.6 9.8-9.6 11.9s-10.7 1.5-15.2-1.6L256 446.9l-90.3 62.3c-4.5 3.1-10.2 3.7-15.2 1.6s-8.6-6.6-9.6-11.9L121 391 13.1 371.1c-5.3-1-9.8-4.6-11.9-9.6s-1.5-10.7 1.6-15.2L65.1 256 2.8 165.7c-3.1-4.5-3.7-10.2-1.6-15.2s6.6-8.6 11.9-9.6L121 121 140.9 13.1c1-5.3 4.6-9.8 9.6-11.9s10.7-1.5 15.2 1.6L256 65.1 346.3 2.8c4.5-3.1 10.2-3.7 15.2-1.6zM160 256a96 96 0 1 1 192 0 96 96 0 1 1 -192 0zm224 0a128 128 0 1 0 -256 0 128 128 0 1 0 256 0z"></path>
        </svg></span>
    </label>
  </nav>
</header>
<script>
  window.onload = function() {
    let e = document.getElementById("switch-theme-checkbox")
    e.checked = document.documentElement.classList.contains("dark");
    e.checked ? e.parentElement.classList.add("active") : e.parentElement.classList.remove("active")
  }
  !function() {
    let e = document.getElementById("switch-theme-checkbox")
    e.checked = document.documentElement.classList.contains("dark")
    e.addEventListener("change", function() {
      if (document.documentElement.classList.contains("light")) {
        document.documentElement.classList.remove("light")
        document.documentElement.classList.add("dark")
      } else if (document.documentElement.classList.contains("dark")) {
        document.documentElement.classList.remove("dark")
        document.documentElement.classList.add("light")
      } else {
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
          document.documentElement.classList.add("dark")
        } else {
          document.documentElement.classList.add("light")
        }
      }
      document.documentElement.setAttribute("data-theme", this.checked ? "dark" : "light"),
        function(e) {
          window.localStorage && window.localStorage.setItem("theme", e)
        }(this.checked ? "dark" : "light"), this.checked ? this.parentElement.classList.add("active") : this.parentElement.classList.remove("active")
    }.bind(e))
  }();
</script>
<div class="body">
<div class="nav-container" data-component="glsl" data-version="latest">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <button class="nav-menu-toggle" aria-label="Toggle expand/collapse all" style="display: none"></button>
    <h3 class="title"><a href="../index.html">OpenGL Shading Language Specification</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="preamble.html">Preamble</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="introduction.html">Introduction</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="overview.html">Overview of Shading</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="basics.html">Basics</a>
  </li>
  <li class="nav-item is-current-page" data-depth="1">
    <a class="nav-link" href="variables.html">Variables and Types</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="operators.html">Operators and Expressions</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="statements.html">Statements and Structure</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="builtins.html">Built-In Variables</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="builtinfunctions.html">Built-In Functions</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="grammar.html">Shading Language Grammar</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="acknowledgements.html">Acknowledgments</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="references.html">Normative References</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="spirvmappings.html">Non-Normative SPIR-V Mappings</a>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">OpenGL Shading Language Specification</span>
    <span class="version">latest</span>
  </div>
  <ul class="components">
    <li class="component">
      <div class="title"><a href="../../../tutorial/latest/00_Introduction.html">Khronos Vulkan Tutorial</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../tutorial/latest/00_Introduction.html">latest</a>
        </li>
      </ul>
    </li>
    <li class="component is-current">
      <div class="title"><a href="../index.html">OpenGL Shading Language Specification</a></div>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="../index.html">latest</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../../features/latest/features/index.html">Vulkan Feature Descriptions</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../features/latest/features/index.html">latest</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../../guide/latest/index.html">Vulkan Guide</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../guide/latest/index.html">latest</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../../samples/latest/README.html">Vulkan Samples</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../samples/latest/README.html">latest</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../../spec/latest/index.html">Vulkan Specification</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../spec/latest/index.html">latest</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../../../spec/latest/index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../index.html">OpenGL Shading Language Specification</a></li>
    <li><a href="variables.html">Variables and Types</a></li>
  </ul>
</nav>
</div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">Variables and Types</h1>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>All variables and functions must be declared before being used.
Variable and function names are identifiers.</p>
</div>
<div class="paragraph">
<p>There are no default types.
All variable and function declarations must have a declared type, and
optionally qualifiers.
A variable is declared by specifying its type followed by one or more names
separated by commas.
In many cases, a variable can be initialized as part of its declaration by
using the assignment operator (<strong>=</strong>).</p>
</div>
<div class="paragraph">
<p>User-defined types may be defined using <strong>struct</strong> to aggregate a list of
existing types into a single name.</p>
</div>
<div class="paragraph">
<p>The OpenGL Shading Language is type safe.
There are some implicit conversions between types.
Exactly how and when this can occur is described in section
&#8220;<a href="#implicit-conversions">Implicit Conversions</a>&#8221; and as referenced by other
sections in this specification.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="basic-types"><a class="anchor" href="#basic-types"></a>Basic Types</h2>
<div class="sectionbody">
<div class="dlist">
<dl>
<dt class="hdlist1">Definition</dt>
<dd>
<p>A <em>basic type</em> is a type defined by a keyword in the language.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>The OpenGL Shading Language supports the following basic data types, grouped as follows.</p>
</div>
<div class="paragraph">
<p><strong>Transparent Types</strong></p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Type</th>
<th class="tableblock halign-left valign-top">Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>void</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">for functions that do not return a value</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>bool</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a conditional type, taking on values of true or false</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>int</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a signed integer</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>uint</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">an unsigned integer</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>float</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a single-precision floating-point scalar</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>double</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a double-precision floating-point scalar</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>vec2</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a two-component single-precision floating-point vector</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>vec3</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a three-component single-precision floating-point vector</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>vec4</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a four-component single-precision floating-point vector</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>dvec2</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a two-component double-precision floating-point vector</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>dvec3</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a three-component double-precision floating-point vector</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>dvec4</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a four-component double-precision floating-point vector</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>bvec2</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a two-component Boolean vector</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>bvec3</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a three-component Boolean vector</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>bvec4</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a four-component Boolean vector</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>ivec2</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a two-component signed integer vector</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>ivec3</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a three-component signed integer vector</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>ivec4</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a four-component signed integer vector</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>uvec2</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a two-component unsigned integer vector</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>uvec3</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a three-component unsigned integer vector</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>uvec4</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a four-component unsigned integer vector</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>mat2</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a 2 × 2 single-precision floating-point matrix</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>mat3</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a 3 × 3 single-precision floating-point matrix</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>mat4</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a 4 × 4 single-precision floating-point matrix</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>mat2x2</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">same as a <strong>mat2</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>mat2x3</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a single-precision floating-point matrix with 2 columns and 3 rows</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>mat2x4</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a single-precision floating-point matrix with 2 columns and 4 rows</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>mat3x2</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a single-precision floating-point matrix with 3 columns and 2 rows</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>mat3x3</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">same as a <strong>mat3</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>mat3x4</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a single-precision floating-point matrix with 3 columns and 4 rows</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>mat4x2</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a single-precision floating-point matrix with 4 columns and 2 rows</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>mat4x3</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a single-precision floating-point matrix with 4 columns and 3 rows</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>mat4x4</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">same as a <strong>mat4</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>dmat2</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a 2 × 2 double-precision floating-point matrix</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>dmat3</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a 3 × 3 double-precision floating-point matrix</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>dmat4</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a 4 × 4 double-precision floating-point matrix</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>dmat2x2</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">same as a <strong>dmat2</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>dmat2x3</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a double-precision floating-point matrix with 2 columns and 3 rows</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>dmat2x4</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a double-precision floating-point matrix with 2 columns and 4 rows</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>dmat3x2</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a double-precision floating-point matrix with 3 columns and 2 rows</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>dmat3x3</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">same as a <strong>dmat3</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>dmat3x4</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a double-precision floating-point matrix with 3 columns and 4 rows</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>dmat4x2</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a double-precision floating-point matrix with 4 columns and 2 rows</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>dmat4x3</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a double-precision floating-point matrix with 4 columns and 3 rows</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>dmat4x4</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">same as a <strong>dmat4</strong></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Note that where the following tables say &#8220;accessing a texture&#8221;, the
<strong>sampler*</strong> opaque types access textures, and the <strong>image*</strong> opaque types
access images, of a specified type.</p>
</div>
<div class="paragraph">
<p><strong>Floating-Point Opaque Types</strong></p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Type</th>
<th class="tableblock halign-left valign-top">Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>sampler1D</strong><br>
  <strong>texture1D</strong><br>
  <strong>image1D</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a handle for accessing a 1D texture</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>sampler1DShadow</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a handle for accessing a 1D depth texture with comparison</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>sampler1DArray</strong><br>
  <strong>texture1DArray</strong><br>
  <strong>image1DArray</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a handle for accessing a 1D array texture</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>sampler1DArrayShadow</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a handle for accessing a 1D array depth texture with comparison</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>sampler2D</strong><br>
  <strong>texture2D</strong><br>
  <strong>image2D</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a handle for accessing a 2D texture</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>sampler2DShadow</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a handle for accessing a 2D depth texture with comparison</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>sampler2DArray</strong><br>
  <strong>texture2DArray</strong><br>
  <strong>image2DArray</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a handle for accessing a 2D array texture</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>sampler2DArrayShadow</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a handle for accessing a 2D array depth texture with comparison</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>sampler2DMS</strong><br>
  <strong>texture2DMS</strong><br>
  <strong>image2DMS</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a handle for accessing a 2D multisample texture</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>sampler2DMSArray</strong><br>
  <strong>texture2DMSArray</strong><br>
  <strong>image2DMSArray</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a handle for accessing a 2D multisample array texture</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>sampler2DRect</strong><br>
  <strong>texture2DRect</strong><br>
  <strong>image2DRect</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a handle for accessing a rectangle texture</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>sampler2DRectShadow</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a handle for accessing a rectangle texture with comparison</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>sampler3D</strong><br>
  <strong>texture3D</strong><br>
  <strong>image3D</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a handle for accessing a 3D texture</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>samplerCube</strong><br>
  <strong>textureCube</strong><br>
  <strong>imageCube</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a handle for accessing a cube mapped texture</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>samplerCubeShadow</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a handle for accessing a cube map depth texture with comparison</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>samplerCubeArray</strong><br>
  <strong>textureCubeArray</strong><br>
  <strong>imageCubeArray</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a handle for accessing a cube map array texture</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>samplerCubeArrayShadow</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a handle for accessing a cube map array depth texture with comparison</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>samplerBuffer</strong><br>
  <strong>textureBuffer</strong><br>
  <strong>imageBuffer</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a handle for accessing a buffer texture</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>subpassInput</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a handle for accessing a floating-point subpass input</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>subpassInputMS</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a handle for accessing a multi-sampled floating-point subpass input</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><strong>Signed Integer Opaque Types</strong></p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Type</th>
<th class="tableblock halign-left valign-top">Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>isampler1D</strong><br>
  <strong>itexture1D</strong><br>
  <strong>iimage1D</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a handle for accessing an integer 1D texture</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>isampler1DArray</strong><br>
  <strong>itexture1DArray</strong><br>
  <strong>iimage1DArray</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a handle for accessing an integer 1D array texture</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>isampler2D</strong><br>
  <strong>itexture2D</strong><br>
  <strong>iimage2D</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a handle for accessing an integer 2D texture</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>isampler2DArray</strong><br>
  <strong>itexture2DArray</strong><br>
  <strong>iimage2DArray</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a handle for accessing an integer 2D array texture</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>isampler2DMS</strong><br>
  <strong>itexture2DMS</strong><br>
  <strong>iimage2DMS</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a handle for accessing an integer 2D multisample texture</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>isampler2DMSArray</strong><br>
  <strong>itexture2DMSArray</strong><br>
  <strong>iimage2DMSArray</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a handle for accessing an integer 2D multisample array texture</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>isampler2DRect</strong><br>
  <strong>itexture2DRect</strong><br>
  <strong>iimage2DRect</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a handle for accessing an integer 2D rectangle texture</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>isampler3D</strong><br>
  <strong>itexture3D</strong><br>
  <strong>iimage3D</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a handle for accessing an integer 3D texture</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>isamplerCube</strong><br>
  <strong>itextureCube</strong><br>
  <strong>iimageCube</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a handle for accessing an integer cube mapped texture</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>isamplerCubeArray</strong><br>
  <strong>itextureCubeArray</strong><br>
  <strong>iimageCubeArray</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a handle for accessing an integer cube map array texture</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>isamplerBuffer</strong><br>
  <strong>itextureBuffer</strong><br>
  <strong>iimageBuffer</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a handle for accessing an integer buffer texture</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>isubpassInput</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a handle for accessing an integer subpass input</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>isubpassInputMS</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a handle for accessing a multi-sampled integer subpass input</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><strong>Unsigned Integer Opaque Types</strong></p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Type</th>
<th class="tableblock halign-left valign-top">Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>usampler1D</strong><br>
  <strong>utexture1D</strong><br>
  <strong>uimage1D</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a handle for accessing an unsigned integer 1D texture</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>usampler1DArray</strong><br>
  <strong>utexture1DArray</strong><br>
  <strong>uimage1DArray</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a handle for accessing an unsigned integer 1D array texture</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>usampler2D</strong><br>
  <strong>utexture2D</strong><br>
  <strong>uimage2D</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a handle for accessing an unsigned integer 2D texture</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>usampler2DArray</strong><br>
  <strong>utexture2DArray</strong><br>
  <strong>uimage2DArray</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a handle for accessing an unsigned integer 2D array texture</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>usampler2DMS</strong><br>
  <strong>utexture2DMS</strong><br>
  <strong>uimage2DMS</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a handle for accessing an unsigned integer 2D multisample texture</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>usampler2DMSArray</strong><br>
  <strong>utexture2DMSArray</strong><br>
  <strong>uimage2DMSArray</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a handle for accessing an unsigned integer 2D multisample array texture</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>usampler2DRect</strong><br>
  <strong>utexture2DRect</strong><br>
  <strong>uimage2DRect</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a handle for accessing an unsigned integer rectangle texture</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>usampler3D</strong><br>
  <strong>utexture3D</strong><br>
  <strong>uimage3D</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a handle for accessing an unsigned integer 3D texture</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>usamplerCube</strong><br>
  <strong>utextureCube</strong><br>
  <strong>uimageCube</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a handle for accessing an unsigned integer cube mapped texture</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>usamplerCubeArray</strong><br>
  <strong>utextureCubeArray</strong><br>
  <strong>uimageCubeArray</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a handle for accessing an unsigned integer cube map array texture</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>usamplerBuffer</strong><br>
  <strong>utextureBuffer</strong><br>
  <strong>uimageBuffer</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a handle for accessing an unsigned integer buffer texture</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>atomic_uint</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a handle for accessing an unsigned integer atomic counter</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>usubpassInput</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a handle for accessing an unsigned-integer subpass input</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>usubpassInputMS</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a handle for accessing a multi-sampled unsigned-integer subpass input</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><strong>Sampler Opaque Types</strong></p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Type</th>
<th class="tableblock halign-left valign-top">Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>sampler</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a handle for accessing state describing how to sample a texture</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>samplerShadow</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a handle for accessing state describing how to sample a depth
                            texture with comparison</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>In addition, a shader can aggregate these basic types using arrays and
structures to build more complex types.</p>
</div>
<div class="paragraph">
<p>There are no pointer types.</p>
</div>
<div class="paragraph">
<p>In this specification, an <em>aggregate</em> will mean a structure or array.
(Matrices and vectors are not by themselves aggregates.) Aggregates,
matrices, and vectors will collectively be referred to as <em>composites</em>.</p>
</div>
<div class="sect2">
<h3 id="void"><a class="anchor" href="#void"></a>Void</h3>
<div class="paragraph">
<p>Functions that do not return a value must be declared as <strong>void</strong>.
There is no default function return type.
The keyword <strong>void</strong> cannot be used in any other declarations (except for
empty formal or actual parameter lists), or a compile-time error results.</p>
</div>
</div>
<div class="sect2">
<h3 id="booleans"><a class="anchor" href="#booleans"></a>Booleans</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">Definition</dt>
<dd>
<p>A <em>boolean type</em> is any boolean scalar or vector type (<strong>bool</strong>, <strong>bvec2</strong>,
<strong>bvec3</strong>, <strong>bvec4</strong>)</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>To make conditional execution of code easier to express, the type <strong>bool</strong> is
supported.
There is no expectation that hardware directly supports variables of this
type.
It is a genuine Boolean type, holding only one of two values meaning either
true or false.
Two keywords <strong>true</strong> and <strong>false</strong> can be used as literal Boolean constants.
Booleans are declared and optionally initialized as in the follow example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">bool success;      // declare "success" to be a Boolean
bool done = false; // declare and initialize "done"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Expressions used for conditional jumps (<strong>if</strong>, <strong>for</strong>, <strong>?:</strong>, <strong>while</strong>,
<strong>do</strong>-<strong>while</strong>) must evaluate to the type <strong>bool</strong>.</p>
</div>
</div>
<div class="sect2">
<h3 id="integers"><a class="anchor" href="#integers"></a>Integers</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">Definitions</dt>
<dd>
<p>An <em>integral type</em> is any signed or unsigned, scalar or vector integer type.
It excludes arrays and structures.</p>
</dd>
<dt class="hdlist1"></dt>
<dd>
<p>A <em>scalar integral type</em> is a scalar signed or unsigned integer type:</p>
</dd>
<dt class="hdlist1"></dt>
<dd>
<p>A <em>vector integral type</em> is a vector of signed or unsigned integers:</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Signed and unsigned integer variables are fully supported.
In this document, the term <em>integer</em> is meant to generally include both
signed and unsigned integers.</p>
</div>
<div class="paragraph">
<p>For OpenGL, unsigned integers have exactly 32 bits of precision.
When targeting Vulkan, <strong>highp</strong>
unsigned integers have exactly 32 bits of precision.</p>
</div>
<div class="paragraph">
<p>For OpenGL, signed integers use 32 bits, including a sign bit, in two&#8217;s complement form.
When targeting Vulkan, <strong>highp</strong>
signed integers use 32 bits, including a sign bit, in two&#8217;s complement form.</p>
</div>
<div class="paragraph">
<p>When targeting Vulkan, <strong>mediump</strong> and <strong>lowp</strong> integers are as defined by the
SPIR-V <strong>RelaxedPrecision</strong> decoration.</p>
</div>
<div class="paragraph">
<p>Addition,
subtraction and multiplication resulting in overflow or
underflow will result in the low-order
32
bits of the correct result R, where
R is computed with enough precision to avoid overflow or underflow.
Division resulting in overflow will result in an undefined value.</p>
</div>
<div class="paragraph">
<p>Integers are declared and optionally initialized with integer expressions,
as in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">int i, j = 42; // default integer literal type is int
uint k = 3u;   // "u" establishes the type as uint</code></pre>
</div>
</div>
<div class="paragraph">
<p>Literal integer constants can be expressed in decimal (base 10), octal (base
8), or hexadecimal (base 16) as follows.</p>
</div>
<div class="openblock bnf">
<div class="content">
<div class="dlist">
<dl>
<dt class="hdlist1"><em>integer-constant</em> : </dt>
<dd>
<p><em>decimal-constant</em> <em>integer-suffix<sub>opt</sub></em><br>
<em>octal-constant</em> <em>integer-suffix<sub>opt</sub></em><br>
<em>hexadecimal-constant</em> <em>integer-suffix<sub>opt</sub></em></p>
</dd>
<dt class="hdlist1"><em>integer-suffix</em> : one of </dt>
<dd>
<p><strong>u</strong> <strong>U</strong></p>
</dd>
<dt class="hdlist1"><em>decimal-constant</em> : </dt>
<dd>
<p><em>nonzero-digit</em><br>
<em>decimal-constant</em> <em>digit</em></p>
</dd>
<dt class="hdlist1"><em>octal-constant</em> : </dt>
<dd>
<p><strong>0</strong><br>
<em>octal-constant</em> <em>octal-digit</em></p>
</dd>
<dt class="hdlist1"><em>hexadecimal-constant</em> : </dt>
<dd>
<p><strong>0x</strong> <em>hexadecimal-digit</em><br>
<strong>0X</strong> <em>hexadecimal-digit</em><br>
<em>hexadecimal-constant</em> <em>hexadecimal-digit</em></p>
</dd>
<dt class="hdlist1"><em>digit</em> : </dt>
<dd>
<p><strong>0</strong><br>
<em>nonzero-digit</em></p>
</dd>
<dt class="hdlist1"><em>nonzero-digit</em> : one of </dt>
<dd>
<p><strong>1 2 3 4 5 6 7 8 9</strong></p>
</dd>
<dt class="hdlist1"><em>octal-digit</em> : one of </dt>
<dd>
<p><strong>0 1 2 3 4 5 6 7</strong></p>
</dd>
<dt class="hdlist1"><em>hexadecimal-digit</em> : one of </dt>
<dd>
<p><strong>0 1 2 3 4 5 6 7 8 9<br>
a b c d e f<br>
A B C D E F</strong></p>
</dd>
</dl>
</div>
</div>
</div>
<div class="paragraph">
<p>No white space is allowed between the digits of an integer constant,
including after the leading <strong>0</strong> or after the leading <strong>0x</strong> or <strong>0X</strong> of a
constant, or before the suffix <strong>u</strong> or <strong>U</strong>.
When tokenizing, the maximal token matching the above will be recognized
before a new token is started.
When the suffix <strong>u</strong> or <strong>U</strong> is present, the literal has type <strong>uint</strong>,
otherwise the type is <strong>int</strong>.
A leading unary minus sign (-) is interpreted as an arithmetic unary
negation, not as part of the constant.
Hence, literals themselves are always expressed with non-negative syntax,
though they could result in a negative value.</p>
</div>
<div class="paragraph">
<p>It is a compile-time error to provide a literal integer whose bit pattern
cannot fit in 32 bits.
The bit pattern of the literal is always used unmodified.
So a signed literal whose bit pattern includes a set sign bit creates a
negative value.</p>
</div>
<div class="paragraph">
<p>For example,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">1             // OK. Signed integer, value 1
1u            // OK. Unsigned integer, value 1
-1            // OK. Unary minus applied to signed integer.
              // result is a signed integer, value -1
-1u           // OK. Unary minus applies to unsigned integer.
              // Result is an unsigned integer, value 0xffffffff
0xA0000000    // OK. 32-bit signed hexadecimal
0xABcdEF00u   // OK. 32-bit unsigned hexadecimal
0xffffffff    // OK. Signed integer, value -1
0x80000000    // OK. Evaluates to -2147483648
0xffffffffu   // OK. Unsigned integer, value 0xffffffff
0xfffffffff   // Error: needs more than 32 bits
3000000000    // OK. A signed decimal literal taking 32 bits.
              // It evaluates to -1294967296
2147483648    // OK. Evaluates to -2147483648 (the literal set the sign bit)
5000000000    // Error: needs more than 32 bits</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="floats"><a class="anchor" href="#floats"></a>Floats</h3>
<div class="paragraph">
<p>Single-precision and double-precision floating-point variables are available
for use in a variety of scalar calculations.
Generally, the term <em>floating-point</em> will refer to both single- and
double-precision floating-point.
Floating-point variables are defined as in the following examples:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">float a, b = 1.5;    // single-precision floating-point
double c, d = 2.0LF; // double-precision floating-point</code></pre>
</div>
</div>
<div class="paragraph">
<p>As an input value to one of the processing units, a single-precision or
double-precision floating-point variable is expected to match the
corresponding IEEE 754 floating-point definition for precision and dynamic
range.
Floating-point variables within a shader are also encoded according to the
IEEE 754 specification for single-precision floating-point values
(logically, not necessarily physically).
While encodings are logically IEEE 754, operations (addition,
multiplication, etc.) are not necessarily performed as required by IEEE 754.
See &#8220;<a href="#range-and-precision">Range and Precision</a>&#8221; for more details on
precision and usage of NaNs (Not a Number) and Infs (positive or negative
infinities).</p>
</div>
<div class="paragraph">
<p>Floating-point constants are defined as follows.</p>
</div>
<div class="openblock bnf">
<div class="content">
<div class="dlist">
<dl>
<dt class="hdlist1"><em>floating-constant</em> : </dt>
<dd>
<p><em>fractional-constant</em> <em>exponent-part<sub>opt</sub></em> <em>floating-suffix<sub>opt</sub></em><br>
<em>digit-sequence</em> <em>exponent-part</em> <em>floating-suffix<sub>opt</sub></em></p>
</dd>
<dt class="hdlist1"><em>fractional-constant</em> : </dt>
<dd>
<p><em>digit-sequence</em> <strong>.</strong> <em>digit-sequence</em><br>
<em>digit-sequence</em> <strong>.</strong><br>
<strong>.</strong> <em>digit-sequence</em></p>
</dd>
<dt class="hdlist1"><em>exponent-part</em> : </dt>
<dd>
<p><strong>e</strong> <em>sign<sub>opt</sub></em> <em>digit-sequence</em><br>
<strong>E</strong> <em>sign<sub>opt</sub></em> <em>digit-sequence</em></p>
</dd>
<dt class="hdlist1"><em>sign</em> : one of </dt>
<dd>
<p><strong>+</strong> <strong>-</strong></p>
</dd>
<dt class="hdlist1"><em>digit-sequence</em> : </dt>
<dd>
<p><em>digit</em><br>
<em>digit-sequence</em> <em>digit</em></p>
</dd>
<dt class="hdlist1"><em>floating-suffix</em> : one of </dt>
<dd>
<p>    <strong>f</strong> <strong>F</strong>
<strong>lf</strong> <strong>LF</strong></p>
</dd>
</dl>
</div>
</div>
</div>
<div class="paragraph">
<p>A decimal point (<strong>.</strong>) is not needed if the exponent part is present.
No white space may appear anywhere within a floating-point constant,
including before a suffix.
When tokenizing, the maximal token matching the above will be recognized
before a new token is started.
When the suffix "lf" or "LF" is present, the literal has type <strong>double</strong>.
Otherwise, the literal has type <strong>float</strong>.
A leading unary minus sign (<strong>-</strong>) is interpreted as a unary operator and is
not part of the floating-point constant.</p>
</div>
</div>
<div class="sect2">
<h3 id="vectors"><a class="anchor" href="#vectors"></a>Vectors</h3>
<div class="paragraph">
<p>The OpenGL Shading Language includes data types for generic 2-, 3-, and 4-component vectors
of floating-point values, integers, and Booleans.
Floating-point vector variables can be used to store colors, normals,
positions, texture coordinates, texture lookup results and the like.
Boolean vectors can be used for component-wise comparisons of numeric
vectors.
Some examples of vector declarations are:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">vec2 texcoord1, texcoord2;
vec3 position;
vec4 myRGBA;
ivec2 textureLookup;
bvec3 less;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Initialization of vectors can be done with constructors.
See &#8220;<a href="operators.html#vector-and-matrix-constructors" class="xref page">Vector and Matrix Constructors</a>&#8221;.</p>
</div>
</div>
<div class="sect2">
<h3 id="matrices"><a class="anchor" href="#matrices"></a>Matrices</h3>
<div class="paragraph">
<p>The OpenGL Shading Language has built-in types for 2 × 2, 2 × 3, 2 × 4, 3
× 2, 3 × 3, 3 × 4, 4 × 2, 4 × 3, and 4 ×
4 matrices of floating-point numbers.
Matrix types beginning with "<strong>mat</strong>" have single-precision components while
matrix types beginning with "<strong>dmat</strong>" have double-precision components.
The first number in the type is the number of columns, the second is the
number of rows.
If there is only one number, the matrix is square.
Example matrix declarations:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">mat2 mat2D;
mat3 optMatrix;
mat4 view, projection;
mat4x4 view; // an alternate way of declaring a mat4
mat3x2 m;    // a matrix with 3 columns and 2 rows
dmat4 highPrecisionMVP;
dmat2x4 dm;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Initialization of matrix values is done with constructors (described in
&#8220;<a href="operators.html#vector-and-matrix-constructors" class="xref page">Vector and Matrix Constructors</a>&#8221;) in
column-major order.</p>
</div>
</div>
<div class="sect2">
<h3 id="opaque-types"><a class="anchor" href="#opaque-types"></a>Opaque Types</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">Definition</dt>
<dd>
<p>An <em>opaque type</em> is a type where the internal structure of the type is
hidden from the language.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>The opaque types, as listed in the following sections, declare variables
that are effectively opaque handles to other objects.
These objects are accessed through built-in functions, not through direct
reading or writing of the declared variable.
They can only be declared as function parameters or in <strong>uniform</strong>-qualified
variables (see &#8220;<a href="#uniform-variables">Uniform Variables</a>&#8221;).
The only opaque types that take memory qualifiers are the image types.
Except for array indexing, structure member selection, and parentheses,
opaque variables are not allowed to be operands in expressions; such use
results in a compile-time error.</p>
</div>
<div class="paragraph">
<p>When aggregated into arrays within a shader, opaque types can only be
indexed with a dynamically uniform integral expression (see &#8220;Dynamically
Uniform Expressions&#8221;) unless otherwise noted; otherwise, results are
undefined.</p>
</div>
<div class="paragraph">
<p>Opaque variables cannot be treated as l-values; hence cannot be used as
<strong>out</strong> or <strong>inout</strong> function parameters, nor can they be assigned into.
Any such use results in a compile-time error.
However, they can be passed as <strong>in</strong> parameters with matching types and
memory qualifiers.
They cannot be declared with an initializer.</p>
</div>
<div class="paragraph">
<p>Because a single opaque type declaration effectively declares two objects,
the opaque handle itself and the object it is a handle to, there is room for
both a storage qualifier and a memory qualifier.
The storage qualifier will qualify the opaque handle, while the memory
qualifier will qualify the object it is a handle to.</p>
</div>
<div class="sect3">
<h4 id="samplers"><a class="anchor" href="#samplers"></a>Texture-Combined Samplers</h4>
<div class="paragraph">
<p>Texture-combined sampler types (e.g. <strong>sampler2D</strong>) are the sampler types
described in the Basic Types tables as handles for accessing textures.
(They do not include <strong>sampler</strong> and <strong>samplerShadow</strong>.)
There are distinct texture-combined sampler types for each texture target,
and for each of float, integer, and unsigned integer data types.
Texture accesses are done through built-in texture functions (described in
&#8220;<a href="builtinfunctions.html#texture-functions" class="xref page">Texture Functions</a>&#8221;) and texture-combined samplers
are used to specify which texture to access and how it is to be filtered.</p>
</div>
<div class="paragraph">
<p>Texture-combined sampler types are opaque types,
declared and behaving as described above for opaque types.</p>
</div>
</div>
<div class="sect3">
<h4 id="images"><a class="anchor" href="#images"></a>Images</h4>
<div class="paragraph">
<p>Image types are opaque types, declared and behaving as described above for
opaque types.
They can be further qualified with memory qualifiers.</p>
</div>
<div class="paragraph">
<p>Image variables are handles to
one-,
two-, or three-dimensional images
corresponding to all or a portion of a single level of a texture image bound
to an image unit.
There are distinct image variable types for each texture target, and for
each of float, integer, and unsigned integer data types.
Image accesses should use an image type that matches the target of the
texture whose level is bound to the image unit, or for non-layered bindings
of 3D or array images should use the image type that matches the
dimensionality of the layer of the image (i.e., a layer of 3D, 2DArray,
Cube, or CubeArray should use
<strong>image2D</strong>, a layer of 1DArray should use <strong>image1D</strong>, and a layer of 2DMSArray
should use <strong>image2DMS</strong>).
If the image target type does not match the bound image in this manner, if
the data type does not match the bound image, or if the format layout
qualifier does not match the image unit format as described in section
8.25
&#8220;Texture Image Loads and Stores&#8221; of the <a href="references.html#references" class="xref page">OpenGL Specification</a>, the
results of image accesses are undefined but cannot include program
termination.</p>
</div>
<div class="paragraph">
<p>Image variables are used in the image load, store, and atomic functions
described in &#8220;<a href="builtinfunctions.html#image-functions" class="xref page">Image Functions</a>&#8221; to specify an image to
access.</p>
</div>
</div>
<div class="sect3">
<h4 id="atomic-counters"><a class="anchor" href="#atomic-counters"></a>Atomic Counters</h4>
<div class="paragraph">
<p>Atomic counter types (e.g. <strong>atomic_uint</strong>) are opaque handles to counters,
declared and behaving as described above for opaque types.
The variables they declare specify which counter to access when using the
built-in atomic counter functions as described in
&#8220;<a href="builtinfunctions.html#atomic-counter-functions" class="xref page">Atomic Counter Functions</a>&#8221;.
They are bound to buffers as described in
&#8220;<a href="#atomic-counter-layout-qualifiers">Atomic Counter Layout Qualifiers</a>&#8221;.</p>
</div>
<div class="paragraph">
<p>Members of structures cannot be declared as atomic counter types.</p>
</div>
<div class="paragraph">
<p>Atomic counter types are not available when targeting Vulkan.</p>
</div>
</div>
<div class="sect3">
<h4 id="_texture_sampler_and_samplershadow_types"><a class="anchor" href="#_texture_sampler_and_samplershadow_types"></a>Texture, <strong>sampler</strong>, and <strong>samplerShadow</strong> Types</h4>
<div class="paragraph">
<p>Texture (e.g., <strong>texture2D</strong>), <strong>sampler</strong>, and <strong>samplerShadow</strong> types are opaque
types, declared and behaving as described above for opaque types.
These types are only available when targeting Vulkan.
Texture variables are handles to one-, two-, and three-dimensional textures,
cube maps, etc., as enumerated in the basic types tables.
There are distinct texture types for each texture target, and for each of
float, integer, and unsigned integer data types.
Textures can be combined with a variable of type <strong>sampler</strong> or <strong>samplerShadow</strong>
to create a texture-combined sampler type (e.g., sampler2D, or sampler2DShadow).
This is done with a constructor, e.g., <code>sampler2D(texture2D, sampler)</code>,
<code>sampler2DShadow(texture2D, sampler)</code>, <code>sampler2DShadow(texture2D, samplerShadow)</code>,
or <code>sampler2D(texture2D, samplerShadow)</code> and is described in more detail
in section 5.4 "Constructors".</p>
</div>
</div>
<div class="sect3">
<h4 id="_subpass_inputs"><a class="anchor" href="#_subpass_inputs"></a>Subpass Inputs</h4>
<div class="paragraph">
<p>Subpass-input types are only available when targeting Vulkan.</p>
</div>
<div class="paragraph">
<p>Subpass-input types (e.g., <strong>subpassInput</strong>) are opaque types, declared
and behaving as described above for opaque types.</p>
</div>
<div class="paragraph">
<p>Subpass-input types are handles to two-dimensional single sampled or
multi-sampled images, with distinct types for each of float, integer,
and unsigned integer data types.</p>
</div>
<div class="paragraph">
<p>Subpass-input types are only available in fragment shaders.  It is
a compile-time error to use them in any other stage.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="structures"><a class="anchor" href="#structures"></a>Structures</h3>
<div class="paragraph">
<p>User-defined types can be created by aggregating other already defined types
into a structure using the <strong>struct</strong> keyword.
For example,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">struct light {
    float intensity;
    vec3 position;
} lightVar;</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this example, <em>light</em> becomes the name of the new type, and <em>lightVar</em>
becomes a variable of type <em>light</em>.
To declare variables of the new type, use its name (without the keyword
<strong>struct</strong>).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">light lightVar2;</code></pre>
</div>
</div>
<div class="paragraph">
<p>More formally, structures are declared as follows.
However, the definitive grammar is as given in
&#8220;<a href="grammar.html#shading-language-grammar" class="xref page">Shading Language Grammar</a>&#8221;.</p>
</div>
<div class="openblock bnf">
<div class="content">
<div class="dlist">
<dl>
<dt class="hdlist1"><em>struct-definition</em> : </dt>
<dd>
<p><em>qualifier<sub>opt</sub></em> <strong>struct</strong> name<sub>opt</sub>_ <strong>{</strong> <em>member-list</em> <strong>}</strong>
<em>declarators<sub>opt</sub></em> <strong>;</strong></p>
</dd>
<dt class="hdlist1"><em>member-list</em> : </dt>
<dd>
<p><em>member-declaration</em> <strong>;</strong><br>
<em>member-declaration</em> <em>member-list</em> <strong>;</strong></p>
</dd>
<dt class="hdlist1"><em>member-declaration</em> : </dt>
<dd>
<p><em>basic-type</em> <em>declarators</em> <strong>;</strong></p>
</dd>
</dl>
</div>
</div>
</div>
<div class="paragraph">
<p>where <em>name</em> becomes the user-defined type, and can be used to declare
variables to be of this new type.
The <em>name</em> shares the same name space as other variables, types, and
functions.
All previously visible variables, types, constructors, or functions with
that name are hidden.
The optional <em>qualifier</em> only applies to any <em>declarators</em>, and is not part
of the type being defined for <em>name</em>.</p>
</div>
<div class="paragraph">
<p>Structures must have at least one member declaration.
Bit fields are not supported.
Member types must be already defined (there are no forward references).</p>
</div>
<div class="paragraph">
<p>Member declarations may contain precision qualifiers, but use of any other
qualifier results in a compile-time error. Where a member declaration does not
include a precision qualifier the member&#8217;s precision is inferred as described
in <a href="#default-precision-qualifiers">Default Precision Qualifiers</a> at the point
of the struct type&#8217;s declaration.</p>
</div>
<div class="paragraph">
<p>A compile-time error results if a member declaration contains an
initializer.
Member declarators can contain arrays.
Such arrays must have a size specified, and the size must be a constant
integral expression that&#8217;s greater than zero (see
&#8220;<a href="#constant-expressions">Constant Expressions</a>&#8221;).
Each level of structure has its own name space for names given in member
declarators; such names need only be unique within that name space.</p>
</div>
<div class="paragraph">
<p>Anonymous structures are not supported.
Embedded structure definitions are not supported.
These result in compile-time errors.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">struct S { float f; }; // Allowed: S is defined as a structure.

struct T {
    S;              // Error: anonymous structures disallowed
    struct { ... }; // Error: embedded structures disallowed
    S s;            // Allowed: nested structure with a name.
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>Structures can be initialized at declaration time using constructors, as
discussed in &#8220;<a href="operators.html#structure-constructors" class="xref page">Structure Constructors</a>&#8221;.</p>
</div>
<div class="paragraph">
<p>Any restrictions on the usage of a type or qualifier also apply to any
structure that contains a member of that type or qualifier.
This also applies to structure members that are structures, recursively.</p>
</div>
</div>
<div class="sect2">
<h3 id="arrays"><a class="anchor" href="#arrays"></a>Arrays</h3>
<div class="paragraph">
<p>Variables of the same type can be aggregated into arrays by declaring a name
followed by brackets (<strong>[ ]</strong>) enclosing an optional size.
When present, the array size must be a constant integral expression (see
&#8220;<a href="#constant-expressions">Constant Expressions</a>&#8221;) greater than zero.
The type of the size parameter can be a signed or unsigned integer and the
choice of type does not affect the type of the resulting array.
Arrays only have a single dimension (a single number within &#8220;[ ]&#8221;),
however, arrays of arrays can be declared.
Any type can be formed into an array.</p>
</div>
<div class="paragraph">
<p>There are 3 types of array objects:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Explicitly Sized</dt>
<dd>
<p>The number of elements in the array is explicitly given.</p>
</dd>
<dt class="hdlist1">Runtime Sized</dt>
<dd>
<p>The number of elements is not given and the array is the
outermost dimension of the last declared member of a shader
storage block (see section &#8220;<a href="#interface-blocks">Interface                  Blocks</a>&#8221;). The array size is inferred at run-time from the
size of the data store backing the shader storage block.</p>
</dd>
<dt class="hdlist1">Unsized</dt>
<dd>
<p>The number of array elements is not given and the array
is not runtime sized.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Unsized arrays may become explicitly sized following either an explicitly-sized
initializer or a redeclaration with an explicit size (Explicitly-sized and
runtime-sized arrays may not be redeclared).
It is a compile-time error to redeclare an array with a different underlying
member type.</p>
</div>
<div class="paragraph">
<p>Note, however, unless noted otherwise, blocks cannot be redeclared; so an unsized
array member in a user-declared block cannot be sized by a block redeclaration.</p>
</div>
<div class="paragraph">
<p>It is a compile-time error if, following any initializer, an array contains any type that
is or includes an unsized array.</p>
</div>
<div class="paragraph">
<p>It is a compile-time error if:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>an unsized array is indexed with anything other than a constant integral expression.</p>
</li>
<li>
<p>an unsized array is declared as a formal parameter to a function.</p>
</li>
<li>
<p>an unsized array is declared as the return type of a function.</p>
</li>
<li>
<p>a runtime-sized or unsized array is passed as a function argument.</p>
</li>
<li>
<p>any array is indexed using a negative constant expression.</p>
</li>
<li>
<p>an explicitly sized array is indexed with a constant expression greater than
or equal to the declared size.</p>
</li>
<li>
<p>an unsized array is redeclared with a size less than or equal to any
constant index used earlier in the shader to index the array.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Undefined behavior results from indexing an array with a non-constant
expression that&#8217;s greater than or equal to the array&#8217;s size or less than 0.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph">
<p>Some features outside the scope of GLSL, for example OpenGL or Vulkan&#8217;s "Robust
Buffer Access" features, may further constrain what behaviors are valid here.
Typically these features will prevent out-of-bounds indexing causing program
termination and may determine which values must be returned.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph">
<p>All arrays are inherently homogeneous; made of elements all having the same
type and size, with one exception.
An array of shader storage blocks whose last member is a runtime-sized array
allows the individual blocks to have different sizes and hence a different
number of elements in the trailing array.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Some examples of array declarations are:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">float frequencies[3];
uniform vec4 lightPosition[4u];
light lights[];            // Unsized. Valid in GLSL, illegal in ESSL.
const int numLights = 2;
light lights[numLights];
vec4 a[3][2];

// a shader storage block, introduced in section 4.3.7 "Buffer Variables"
buffer b {
    float u[]; // an error, unless u gets statically sized by link time
    vec4 v[];  // okay, v will be sized dynamically, if not statically
} name[3];     // when the block is arrayed, all u will be the same size,
               // but not necessarily all v, if sized dynamically</code></pre>
</div>
</div>
<div class="paragraph">
<p>An array type can be formed by specifying a non-array type
(<a href="grammar.html#type_specifier_nonarray" class="xref page">type_specifier_nonarray :</a>) followed by an <a href="grammar.html#array_specifier" class="xref page">array_specifier :</a>.
Note that in this context the construct <em>type [size]</em> does not always result in
an array of length <em>size</em> of type <em>type</em>.
For example,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">float[5]    // an array of size [5] of float
float[2][3] // an array of size [2] of array of size [3] of float,
            // not size [3] of float[2]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Such an array type can be used anywhere any other type can be used, including
as the return value from a function, as a constructor of an array and in
declarations.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">// As a function return type
float[5] foo() { }
// As an array constructor
float[5](3.4, 4.2, 5.0, 5.2, 1.1)
// In declaring an unnamed parameter
void foo(float[5])
// In normal declarations
float[5] a;

// The following 3 declarations are equivalent:
vec4 a[3][2]; // size-3 array of size-2 array of vec4
vec4[2] a[3];
vec4[3][2] a;</code></pre>
</div>
</div>
<div class="paragraph">
<p>If such an array type is unsized and used as a constructor then the size of the
array is inferred from the constructor arguments. For example,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">float a[5] = float[5](3.4, 4.2, 5.0, 5.2, 1.1);
float a[5] = float[](3.4, 4.2, 5.0, 5.2, 1.1);  // Constructor also of type float[5]</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is a compile-time error to assign either to or from a runtime-sized or unsized
array (rather than specific elements).
Note, this is a rare case that initializers and assignments appear to have
different semantics.
An initializer for an unsized array is valid and will size the array, but the
equivalent assigment is not valid.
For example,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">float a[5];
float b[];
// An initializer sizes an array ...
float c[] = a;  // c is explicitly size 5
// ... but the equivalent assignment is not valid
float d[];
d = a;          // Error. Assignment to an unsized array
// It is never valid to assign from an unsized array
float e[] = b;  // Error. b is unsized so cannot be assigned</code></pre>
</div>
</div>
<div class="paragraph">
<p>Alternatively, the initializer-list syntax can be used to initialize an
array of arrays:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">vec4 a[3][2] = { vec4[2](vec4(0.0), vec4(1.0)),
                 vec4[2](vec4(0.0), vec4(1.0)),
                 vec4[2](vec4(0.0), vec4(1.0)) };</code></pre>
</div>
</div>
<div class="paragraph">
<p>For arrays of arrays, any unsized dimension is explicitly sized by the
initializer:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">vec4 a[][] = { vec4[2](vec4(0.0), vec4(1.0)), // okay, size to a[3][2]
               vec4[2](vec4(0.0), vec4(1.0)),
               vec4[2](vec4(0.0), vec4(1.0)) };</code></pre>
</div>
</div>
<div class="paragraph">
<p>When in transparent memory (like in a uniform block), the layout is that the
inner-most (right-most in declaration) dimensions iterate faster than the
outer dimensions.
That is, for the above, the order in memory would be:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"></dt>
<dd>
<p>Low address : a[0][0] : a[0][1] : a[1][0] : a[1][1] : a[2][0] : a[2][1]
: High address</p>
</dd>
</dl>
</div>
<div class="sect3">
<h4 id="_the_length_method"><a class="anchor" href="#_the_length_method"></a>The <strong>length</strong>() Method</h4>
<div class="paragraph">
<p>The number of elements in an array can be obtained by using the <strong>length</strong>()
method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">float a[5];
a.length(); // returns 5

vec4 a[3][2];
a.length()    // returns 3
a[x].length() // returns 2</code></pre>
</div>
</div>
<div class="paragraph">
<p>The return value has type <strong>int</strong>.</p>
</div>
<div class="paragraph">
<p>It is a compile-time error to use the <strong>length</strong>() method on an unsized array.
The return value is a constant expression if and only if the array is
explicitly-sized.</p>
</div>
<div class="paragraph">
<p>When the <strong>length</strong>() method returns a compile-time constant, the expression the
<strong>length</strong>() method is applied to will be parsed and is subject to the normal
language rules but any arrays will not be dereferenced.
This means that the value returned is well-defined even if the indices are out
of bounds at runtime.
Note, however, that because indices which are constant expressions are still
checked, an error will still be generated for constant indexing out-of-bounds.</p>
</div>
<div class="paragraph">
<p>When the <strong>length</strong>() method returns a compile-time constant and the expression the
<strong>length</strong>() method is applied to contains any side effects (such as writes
to l-values within the expression, or function calls that themselves have side
effects), behavior is undefined.
A compile- or link-time error may be given by the implementation but this is
not required.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">float a, b;
float[2](a=3.0, ++b).length(); // Behavior undefined. Illegal side effects

float c[5][3];
c[7].length(); // Error. Static indexing out of bounds.
c[i].length(); // Valid, returns 3 even if i &lt; 0 or i &gt;= 5 at runtime.

struct S {
    float a[3];
} s[5];
s[i+3].a.length(); // Valid. Returns 3 for all inputs i.
s[i++].a.length(); // Behavior undefined. Illegal side-effects.

buffer B {
    float x[3];
    float y[];
} b[5];
b[i++].x.length(); // Behaviour undefined. Illegal side-effects.
b[i++].y.length(); // Valid. i is incremented and b dereferenced. The runtime size
                   // of y is returned if 0 &lt;= x &lt; 5, behavior undefined if not.</code></pre>
</div>
</div>
<div class="paragraph">
<p>The precision is determined using the same rules as for other cases where
there is no intrinsic precision.
See &#8220;<a href="#precision-qualifiers">Precision Qualifiers</a>&#8221;.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="implicit-conversions"><a class="anchor" href="#implicit-conversions"></a>Implicit Conversions</h3>
<div class="paragraph">
<p>In some situations, an expression and its type will be implicitly converted
to a different type.
The following table shows all allowed implicit conversions:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Type of expression</th>
<th class="tableblock halign-left valign-top">Can be implicitly converted to</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>int</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>uint</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>int</strong><br>
  <strong>uint</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>float</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>int</strong><br>
  <strong>uint</strong><br>
  <strong>float</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>double</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>ivec2</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>uvec2</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>ivec3</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>uvec3</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>ivec4</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>uvec4</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>ivec2</strong><br>
  <strong>uvec2</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>vec2</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>ivec3</strong><br>
  <strong>uvec3</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>vec3</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>ivec4</strong><br>
  <strong>uvec4</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>vec4</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>ivec2</strong><br>
  <strong>uvec2</strong><br>
  <strong>vec2</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>dvec2</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>ivec3</strong><br>
  <strong>uvec3</strong><br>
  <strong>vec3</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>dvec3</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>ivec4</strong><br>
  <strong>uvec4</strong><br>
  <strong>vec4</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>dvec4</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>mat2</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>dmat2</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>mat3</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>dmat3</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>mat4</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>dmat4</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>mat2x3</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>dmat2x3</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>mat2x4</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>dmat2x4</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>mat3x2</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>dmat3x2</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>mat3x4</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>dmat3x4</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>mat4x2</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>dmat4x2</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>mat4x3</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>dmat4x3</strong></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>There are no implicit array or structure conversions.
For example, an array of <strong>int</strong> cannot be implicitly converted to an array of
<strong>float</strong>.</p>
</div>
<div class="paragraph">
<p>When an implicit conversion is done, it is the same conversion that would be
done under explicit conversion, using a constructor.
The explicit conversions via constructors are described in
<a href="operators.html#conversion-and-scalar-constructors" class="xref page">Conversion and Scalar Constructors</a>.</p>
</div>
<div class="paragraph">
<p>When performing implicit conversion for binary operators, there may be
multiple data types to which the two operands can be converted.
For example, when adding an <strong>int</strong> value to a <strong>uint</strong> value, both values can
be implicitly converted to <strong>uint</strong>, <strong>float</strong>, and <strong>double</strong>.
In such cases, a floating-point type is chosen if either operand has a
floating-point type.
Otherwise, an unsigned integer type is chosen if either operand has an
unsigned integer type.
Otherwise, a signed integer type is chosen.
If operands can be implicitly converted to multiple data types deriving from
the same base data type, the type with the smallest component size is used.</p>
</div>
<div class="paragraph">
<p>The conversions in the table above are done only as indicated by other
sections of this specification.</p>
</div>
</div>
<div class="sect2">
<h3 id="initializers"><a class="anchor" href="#initializers"></a>Initializers</h3>
<div class="paragraph">
<p>At declaration, an initial value for a variable may be provided, specified
as an equals (=) followed by an initializer.
The initializer is either an <em>assignment-expression</em> or a list of
initializers enclosed in curly braces.
The grammar for the initializer is:</p>
</div>
<div class="openblock bnf">
<div class="content">
<div class="dlist">
<dl>
<dt class="hdlist1"><em>initializer</em> : </dt>
<dd>
<p><em>assignment-expression</em><br>
<strong>{</strong> <em>initializer-list</em> <strong>}</strong><br>
<strong>{</strong> <em>initializer-list</em> <strong>,</strong> <strong>}</strong></p>
</dd>
<dt class="hdlist1"><em>initializer-list</em> : </dt>
<dd>
<p><em>initializer</em><br>
<em>initializer-list</em> , <em>initializer</em></p>
</dd>
</dl>
</div>
</div>
</div>
<div class="paragraph">
<p>The <em>assignment-expression</em> is a normal expression except that a comma (<strong>,</strong>)
outside parentheses is interpreted as the end of the initializer, not as the
sequence operator.
As explained in more detail below, this allows creation of nested
initializers: The variable type and its initializer must exactly match in
terms of nesting, number of components/elements/members present at each
level, and types of components/elements/members.
An <em>assignment-expression</em> at global scope can include calls to user-defined
functions.</p>
</div>
<div class="paragraph">
<p>An <em>assignment-expression</em> in an initializer must be either the same type as
the object it initializes or be a type that can be converted to the object&#8217;s
type according to &#8220;<a href="#implicit-conversions">Implicit Conversions</a>&#8221;.
Since these include constructors, a composite variable can be initialized by
either a constructor or an initializer list; and an element in an
initializer list can be a constructor.</p>
</div>
<div class="paragraph">
<p>If an initializer is a list of initializers enclosed in curly braces, the
variable being declared must be a vector, a matrix, an array, or a
structure.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">int i = { 1 }; // illegal, i is not a composite</code></pre>
</div>
</div>
<div class="paragraph">
<p>A list of initializers enclosed in a matching set of curly braces is applied
to one composite.
This may be the variable being declared or a composite contained in the
variable being declared.
Individual initializers from the initializer list are applied to the
elements/members of the composite, in order.</p>
</div>
<div class="paragraph">
<p>If the composite has a vector type, initializers from the list are applied
to the components of the vector, in order, starting with component 0.
The number of initializers must match the number of components.</p>
</div>
<div class="paragraph">
<p>If the composite has a matrix type, initializers from the list must be
vector initializers and are applied to the columns of the matrix, in order,
starting with column 0.
The number of initializers must match the number of columns.</p>
</div>
<div class="paragraph">
<p>If the composite has a structure type, initializers from the list are
applied to the members of the structure, in the order declared in the
structure, starting with the first member.
The number of initializers must match the number of members.</p>
</div>
<div class="paragraph">
<p>Applying these rules, the following matrix declarations are equivalent:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">mat2x2 a = mat2(  vec2( 1.0, 0.0 ), vec2( 0.0, 1.0 ) );
mat2x2 b =      { vec2( 1.0, 0.0 ), vec2( 0.0, 1.0 ) };
mat2x2 c =      {     { 1.0, 0.0 },     { 0.0, 1.0 } };</code></pre>
</div>
</div>
<div class="paragraph">
<p>All of the following declarations result in a compile-time error.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">float a[2] = { 3.4, 4.2, 5.0 };         // illegal
vec2 b = { 1.0, 2.0, 3.0 };             // illegal
mat3x3 c = { vec3(0.0), vec3(1.0), vec3(2.0), vec3(3.0) }; // illegal
mat2x2 d = { 1.0, 0.0, 0.0, 1.0 };      // illegal, can't flatten nesting
struct {
    float a;
    int b;
} e = { 1.2, 2, 3 };                    // illegal</code></pre>
</div>
</div>
<div class="paragraph">
<p>In all cases, the inner-most initializer (i.e., not a list of initializers
enclosed in curly braces) applied to an object must have the same type as
the object being initialized or be a type that can be converted to the
object&#8217;s type according to &#8220;<a href="#implicit-conversions">Implicit Conversions</a>&#8221;.
In the latter case, an implicit conversion will be done on the initializer
before the assignment is done.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">struct {
    float a;
    int b;
} e = { 1.2, 2 }; // legal, all types match
struct {
    float a;
    int b;
} e = { 1, 3 };   // legal, first initializer is converted</code></pre>
</div>
</div>
<div class="paragraph">
<p>All of the following declarations result in a compile-time error.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">int a = true;                         // illegal
vec4 b[2] = { vec4(0.0), 1.0 };       // illegal
mat4x2 c = { vec3(0.0), vec3(1.0) };  // illegal

struct S1 {
    vec4 a;
    vec4 b;
};

struct {
    float s;
    float t;
} d[] = { S1(vec4(0.0), vec4(1.1)) }; // illegal</code></pre>
</div>
</div>
<div class="paragraph">
<p>If an initializer (of either form) is provided for an unsized array, the
size of the array is determined by the number of top-level (non-nested)
initializers within the initializer.
All of the following declarations create arrays explicitly sized with five
elements:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">float a[] = float[](3.4, 4.2, 5.0, 5.2, 1.1);
float b[] = { 3.4, 4.2, 5.0, 5.2, 1.1 };
float c[] = a;                          // c is explicitly size 5
float d[5] = b;                         // means the same thing</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is a compile-time error to have too few or too many initializers in an
initializer list for the composite being initialized.
That is, all elements of an array, all members of a structure, all columns
of a matrix, and all components of a vector must have exactly one
initializer expression present, with no unconsumed initializers.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="scoping"><a class="anchor" href="#scoping"></a>Scoping</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The scope of a variable is determined by where it is declared.
If it is declared outside all function definitions, it has global scope,
which starts from where it is declared and persists to the end of the shader
it is declared in.
If it is declared in a <strong>while</strong> test or a <strong>for</strong> statement, then it is scoped
to the end of the following sub-statement.
If it is declared in an <strong>if</strong> or <strong>else</strong> statement, it is scoped to the end of
that statement.
(See &#8220;<a href="statements.html#selection" class="xref page">Selection</a>&#8221; and &#8220;<a href="statements.html#iteration" class="xref page">Iteration</a>&#8221; for the
location of statements and sub-statements.) Otherwise, if it is declared as
a statement within a compound statement, it is scoped to the end of that
compound statement.
If it is declared as a parameter in a function definition, it is scoped
until the end of that function definition.
A function&#8217;s parameter declarations and body together form a single scope
nested in the global scope.
The <strong>if</strong> statement&#8217;s expression does not allow new variables to be declared,
hence does not form a new scope.</p>
</div>
<div class="paragraph">
<p>Within a declaration, the scope of a name starts immediately after the
initializer if present or immediately after the name being declared if not.
Several examples:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">int x = 1;
{
    int x = 2, y = x; // y is initialized to 2
}

struct S
{
    int x;
};

{
    S S = S(0); // 'S' is only visible as a struct and constructor
    S;          // 'S' is now visible as a variable
}

int x = x; // Error if x has not been previously defined.
           // If the previous definition of x was in this
           // same scope, this causes a redeclaration error.

int f( /* nested scope begins here */ int k)
{
    int k = k + 3; // redeclaration error of the name k
    ...
}

int f(int k)
{
    {
        int k = k + 3; // 2nd k is parameter, initializing nested first k
        int m = k;     // use of new k, which is hiding the parameter
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>For both <strong>for</strong> and <strong>while</strong> loops, the sub-statement itself does not
introduce a new scope for variable names, so the following has a
redeclaration compile-time error:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">for ( /* nested scope begins here */ int i = 0; i &lt; 10; i++) {
    int i; // redeclaration error
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The body of a <strong>do</strong>-<strong>while</strong> loop introduces a new scope lasting only between
the <strong>do</strong> and <strong>while</strong> (not including the while test expression), whether or
not the body is simple or compound:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">int i = 17;
do
    int i = 4;  // okay, in nested scope_
while (i == 0); // i is 17, scoped outside the do-while body</code></pre>
</div>
</div>
<div class="paragraph">
<p>The statement following a <strong>switch</strong> (&#8230;&#8203;) forms a nested scope.</p>
</div>
<div class="paragraph">
<p>All variable names, structure type names, and function names in a given
scope share the same name space.
Function names can be redeclared in the same scope, with the same or
different parameters, without error.
An implicitly-sized array can be redeclared in the same scope as an array of
the same base type.
Otherwise, within one compilation unit, a declared name cannot be redeclared
in the same scope; doing so results in a redeclaration compile-time error.
If a nested scope redeclares a name used in an outer scope, it hides all
existing uses of that name.
There is no way to access the hidden name or make it unhidden, without
exiting the scope that hid it.</p>
</div>
<div class="paragraph">
<p>The built-in functions are scoped in a scope outside the global scope that
users declare global variables in.
That is, a shader&#8217;s global scope, available for user-defined functions and
global variables, is nested inside the scope containing the built-in
functions.
When a function name is redeclared in a nested scope, it hides all functions
declared with that name in the outer scope.
Function declarations (prototypes) cannot occur inside of functions; they
must be at global scope, or for the built-in functions, outside the global
scope, otherwise a compile-time error results.</p>
</div>
<div class="paragraph">
<p>Shared globals are global variables declared with the same name in
independently compiled units (shaders) within the same language (i.e., same
stage, e.g. vertex) that are linked together when making a single program.
(Globals forming the interface between two different shader languages are
discussed in other sections.) Shared globals share the same name space, and
must be declared with the same type.
They will share the same storage.</p>
</div>
<div class="paragraph">
<p>Shared global arrays must have the same base type and the same explicit
size.
An array implicitly sized in one shader can be explicitly sized by another
shader in the same stage.
If no shader in a stage has an explicit size for the array, the largest
implicit size (one more than the largest index used) in that stage is used.
There is no cross-stage array sizing.
If there is no static access to an implicitly sized array within the stage
declaring it, then the array is given a size of 1, which is relevant when
the array is declared within an interface block that is shared with other
stages or the application (other unused arrays might be eliminated by the
optimizer).</p>
</div>
<div class="paragraph">
<p>Shared global scalars must have exactly the same type name and type
definition.
Structures must have the same name, sequence of type names, and type
definitions, and member names to be considered the same type.
This rule applies recursively for nested or embedded types.
If a shared global has multiple initializers, the initializers must all be
constant expressions, and they must all have the same value.
Otherwise, a link-time error will result.
(A shared global having only one initializer does not require that
initializer to be a constant expression.)</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="storage-qualifiers"><a class="anchor" href="#storage-qualifiers"></a>Storage Qualifiers</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Variable declarations may have at most one storage qualifier specified in
front of the type.
These are summarized as</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Storage Qualifier</th>
<th class="tableblock halign-left valign-top">Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;none: default&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">local read/write memory, or an input parameter to a
                      function</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>const</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a variable whose value cannot be changed</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>in</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">linkage into a shader from a previous stage, variable
                      is copied in</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>out</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">linkage out of a shader to a subsequent stage,
                      variable is copied out</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>attribute</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">compatibility profile only and vertex language only;
                      same as <strong>in</strong> when in a vertex shader</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>uniform</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">value does not change across the primitive being
                      processed, uniforms form the linkage between a shader,
                      API, and the application</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>varying</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">compatibility profile only and vertex and fragment
                      languages only; same as <strong>out</strong> when in a vertex shader
                      and same as <strong>in</strong> when in a fragment shader</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>buffer</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">value is stored in a buffer object, and can be read or
                      written both by shader invocations and the API</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>shared</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">compute shader only; variable storage is shared across
                      all work items in a workgroup</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Some input and output qualified variables can be qualified with at most one
additional auxiliary storage qualifier:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Auxiliary Storage Qualifier</th>
<th class="tableblock halign-left valign-top">Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>centroid</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">centroid-based interpolation</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>sample</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">per-sample interpolation</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>patch</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">per-tessellation-patch attributes</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Not all combinations of qualification are allowed.
Auxiliary storage qualifiers can only be used with the <strong>in</strong> or <strong>out</strong> storage
qualifiers.
Additional qualifier rules are defined in upcoming sections.</p>
</div>
<div class="paragraph">
<p>Local variables can only use the <strong>const</strong> storage qualifier (or use no
storage qualifier).</p>
</div>
<div class="paragraph">
<p>Note that function parameters can use <strong>const</strong>, <strong>in</strong>, and <strong>out</strong> qualifiers,
but as <em>parameter qualifiers</em>.
Parameter qualifiers are discussed in
&#8220;<a href="statements.html#function-calling-conventions" class="xref page">Function Calling Conventions</a>&#8221;.</p>
</div>
<div class="paragraph">
<p>Function return types and structure members do not use storage qualifiers.</p>
</div>
<div class="paragraph">
<p>Initializers in global declarations may only be used in declarations of
global variables with no storage qualifier, with a <strong>const</strong> qualifier, or
with a <strong>uniform</strong> qualifier.
Global variables without storage qualifiers that are not initialized in
their declaration or by the application will not be initialized,
but rather will enter <em>main()</em> with undefined values.</p>
</div>
<div class="paragraph">
<p>When comparing an output from one shader stage to an input of a subsequent
shader stage, the input and output don&#8217;t match if their auxiliary qualifiers
(or lack thereof) are not the same.</p>
</div>
<div class="sect2">
<h3 id="default-storage-qualifier"><a class="anchor" href="#default-storage-qualifier"></a>Default Storage Qualifier</h3>
<div class="paragraph">
<p>If no qualifier is present on a global variable, then the variable has no
linkage to the application or shaders running on other pipeline stages.
For either global or local unqualified variables, the declaration will
appear to allocate memory associated with the processor it targets.
This variable will provide read/write access to this allocated memory.</p>
</div>
</div>
<div class="sect2">
<h3 id="constant-qualifier"><a class="anchor" href="#constant-qualifier"></a>Constant Qualifier</h3>
<div class="paragraph">
<p>Named compile-time constants
or read-only variables
can be declared using
the <strong>const</strong> qualifier.
The <strong>const</strong> qualifier can be used with any of the non-void transparent basic
data types, as well as with structures and arrays of these.
It is a compile-time error to write to a <strong>const</strong> variable outside of its
declaration, so they must be initialized when declared.
For example,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">const vec3 zAxis = vec3 (0.0, 0.0, 1.0);
const float ceiling = a + b; // a and b not necessarily constants</code></pre>
</div>
</div>
<div class="paragraph">
<p>Structure members may not be qualified with <strong>const</strong>.
Structure variables can be declared as <strong>const</strong>, and initialized with a
structure
constructor or initializer.</p>
</div>
<div class="paragraph">
<p>Initializers for <strong>const</strong> declarations
at global scope
must be constant expressions, as defined in
&#8220;<a href="#constant-expressions">Constant Expressions</a>&#8221;.</p>
</div>
</div>
<div class="sect2">
<h3 id="constant-expressions"><a class="anchor" href="#constant-expressions"></a>Constant Expressions</h3>
<div class="paragraph">
<p>SPIR-V specialization constants are expressed in GLSL as <strong>const</strong> with the
layout qualifier <strong>constant_id</strong>, as described in
&#8220;<a href="#specialization-constant-qualifier">Specialization-Constant Qualifier.</a>&#8221;</p>
</div>
<div class="paragraph">
<p>A <em>constant expression</em> is one of</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A literal value (e.g. <strong>5</strong> or <strong>true</strong>).</p>
</li>
<li>
<p>A variable declared with the <strong>const</strong> qualifier and an initializer, where
the initializer is a constant expression.
This includes both <strong>const</strong> declared with a specialization-constant
layout qualifier, e.g. <strong>layout</strong>(<strong>constant_id</strong> = &#8230;&#8203;), and those declared
without a specialization-constant layout qualifier.</p>
</li>
<li>
<p>Built-in variables qualified as <strong>const</strong>.</p>
</li>
<li>
<p>An expression formed by an operator on operands that are all constant
expressions, including getting an element of a constant array, or a
member of a constant structure, or components of a constant vector.
However, the lowest precedence operators of the sequence operator (<strong>,</strong>)
and the assignment operators (<strong>=</strong>, <strong>+=</strong>, <strong>&#8230;&#8203;</strong>) are not included in the
operators that can create a constant expression.
Also, an array access with a specialization constant as an index does
not result in a constant expression.</p>
</li>
<li>
<p>Valid use of the <strong>length</strong>() method on an explicitly sized object,
whether or not the object itself is constant (implicitly sized or
run-time sized arrays do not return a constant expression).</p>
</li>
<li>
<p>A constructor whose arguments are all constant expressions.</p>
</li>
<li>
<p>For non-specialization constants only: The value returned by certain
built-in function calls whose arguments are all constant expressions,
including at least the list below.
Any other built-in function that does not access memory (not the texture
lookup functions, image access, atomic counter, etc.), that has a
non-<strong>void</strong> return type, that has no <strong>out</strong> parameter, and is not a noise
function might also be considered a constant.
When a function is called with an argument that is a specialization
constant, the result is not a constant expression.</p>
<div class="ulist">
<ul>
<li>
<p>Angle and Trigonometric Functions</p>
<div class="ulist">
<ul>
<li>
<p><strong>radians</strong></p>
</li>
<li>
<p><strong>degrees</strong></p>
</li>
<li>
<p><strong>sin</strong></p>
</li>
<li>
<p><strong>cos</strong></p>
</li>
<li>
<p><strong>asin</strong></p>
</li>
<li>
<p><strong>acos</strong></p>
</li>
</ul>
</div>
</li>
<li>
<p>Exponential Functions</p>
<div class="ulist">
<ul>
<li>
<p><strong>pow</strong></p>
</li>
<li>
<p><strong>exp</strong></p>
</li>
<li>
<p><strong>log</strong></p>
</li>
<li>
<p><strong>exp2</strong></p>
</li>
<li>
<p><strong>log2</strong></p>
</li>
<li>
<p><strong>sqrt</strong></p>
</li>
<li>
<p><strong>inversesqrt</strong></p>
</li>
</ul>
</div>
</li>
<li>
<p>Common Functions</p>
<div class="ulist">
<ul>
<li>
<p><strong>abs</strong></p>
</li>
<li>
<p><strong>sign</strong></p>
</li>
<li>
<p><strong>floor</strong></p>
</li>
<li>
<p><strong>trunc</strong></p>
</li>
<li>
<p><strong>round</strong></p>
</li>
<li>
<p><strong>ceil</strong></p>
</li>
<li>
<p><strong>mod</strong></p>
</li>
<li>
<p><strong>min</strong></p>
</li>
<li>
<p><strong>max</strong></p>
</li>
<li>
<p><strong>clamp</strong></p>
</li>
</ul>
</div>
</li>
<li>
<p>Geometric Functions</p>
<div class="ulist">
<ul>
<li>
<p><strong>length</strong></p>
</li>
<li>
<p><strong>dot</strong></p>
</li>
<li>
<p><strong>normalize</strong></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Function calls to user-defined functions (non-built-in functions) cannot
be used to form constant expressions.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A <em>constant integral expression</em> is a constant expression that evaluates to
a scalar signed or unsigned integer.</p>
</div>
<div class="paragraph">
<p>Constant expressions will be evaluated in an invariant way so as to create
the same value in multiple shaders when the same constant expressions appear
in those shaders.
See &#8220;<a href="#the-invariant-qualifier">The Invariant Qualifier</a>&#8221; for more details
on how to create invariant expressions and
&#8220;<a href="#precision-qualifiers">Precision Qualifiers</a>&#8221; for detail on how
expressions are evaluated.</p>
</div>
<div class="paragraph">
<p>Constant expressions respect the <strong>precise</strong> and <strong>invariant</strong> qualifiers but
will be always be evaluated in an invariant way, independent of the use of
such qualification, so as to create the same value in multiple shaders when
the same constant expressions appear in those shaders.
See &#8220;<a href="#the-invariant-qualifier">The Invariant Qualifier</a>&#8221; and
&#8220;<a href="#the-precise-qualifier">The Precise Qualifier</a>&#8221; for more details on how
to create invariant expressions.</p>
</div>
<div class="paragraph">
<p>Constant-expressions may be evaluated by a
host platform, and are therefore not required to compute the same value that
the same expression would evaluate to on the shader execution target.
However, the host must use the same or greater precision than the target
would use.
When the precision qualification cannot be determined, the expression is
evaluated at <strong>highp</strong>.
See &#8220;<a href="#default-precision-qualifiers">Default Precision Qualifiers</a>&#8221;.</p>
</div>
<div class="paragraph">
<p>Specialization-constant expressions are never evaluated by the compiler
front end, but instead retain the expression&#8217;s operations needed to evaluate
them later on the host.</p>
</div>
</div>
<div class="sect2">
<h3 id="input-variables"><a class="anchor" href="#input-variables"></a>Input Variables</h3>
<div class="paragraph">
<p>Shader input variables are declared with the <strong>in</strong> storage qualifier.
They form the input interface between previous stages of the API
pipeline and the declaring shader.
Input variables must be declared at global scope.
Values from the previous pipeline stage are copied into input variables at
the beginning of shader execution.
It is a compile-time error to write to a variable declared as an input.</p>
</div>
<div class="paragraph">
<p>Only the input variables that are
statically
read need to be written by the
previous stage; it is allowed to have superfluous declarations of input
variables.
This is shown in the following table.</p>
</div>
<table class="tableblock frame-all grid-all fit-content">
<colgroup>
<col>
<col>
<col>
<col>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top" colspan="2" rowspan="2"><p class="tableblock">Treatment of Mismatched Input Variables</p></td>
<td class="tableblock halign-left valign-top" colspan="3"><p class="tableblock">Consuming Shader (input variables)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">No Declaration</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Declared but no Static Use</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Declared and Static Use</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" rowspan="3"><p class="tableblock">Generating Shader (output variables)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No Declaration</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Allowed</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Allowed</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Link-Time Error</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Declared but no Static Use</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Allowed</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Allowed</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Allowed (values are undefined)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Declared and Static Use</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Allowed</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Allowed</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Allowed (values are potentially undefined)</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Consumption errors are based on static use only.
Compilation may generate a warning, but not an error, for any dynamic use
the compiler can deduce that might cause consumption of undefined values.</p>
</div>
<div class="paragraph">
<p>See &#8220;<a href="builtins.html#built-in-variables" class="xref page">Built-In Variables</a>&#8221; for a list of the built-in
input names.</p>
</div>
<div class="paragraph">
<p>Vertex shader input variables (or attributes) receive per-vertex data.
It is a compile-time error to use auxiliary storage or interpolation qualifiers
on a vertex shader input.
The values copied in are established by the API or through the use
of the layout identifier <strong>location</strong>.</p>
</div>
<div class="paragraph">
<p>It is a compile-time error to declare a vertex shader input with, or that
contains, any of the following types:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A <a href="#booleans">boolean type</a></p>
</li>
<li>
<p>An <a href="#opaque-types">opaque type</a></p>
</li>
<li>
<p>A structure</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Example declarations in a vertex shader:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">in vec4 position;
in vec3 normal;
in vec2 texCoord[4];</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is expected that graphics hardware will have a small number of fixed
vector locations for passing vertex inputs.
Therefore, the OpenGL Shading Language defines each non-matrix input variable as taking up
one such vector location.
There is an implementation-dependent limit on the number of locations that
can be used, and if this is exceeded it will cause a link-time error.
(Declared input variables that are not statically used do not count against
this limit.) A scalar input counts the same amount against this limit as a
<strong>vec4</strong>, so applications may want to consider packing groups of four
unrelated float inputs together into a vector to better utilize the
capabilities of the underlying hardware.
A matrix input will use up multiple locations.
The number of locations used will equal the number of columns in the matrix.</p>
</div>
<div class="paragraph">
<p>Tessellation control, evaluation, and geometry shader input variables get
the per-vertex values written out by output variables of the same names in
the previous active shader stage.
For these inputs, <strong>centroid</strong> and interpolation qualifiers are allowed, but
have no effect.
Since tessellation control, tessellation evaluation, and geometry shaders
operate on a set of vertices, each input variable (or input block, see
<a href="#interface-blocks">Interface Blocks</a> below) needs to be declared as an array.
For example,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">in float foo[]; // geometry shader input for vertex "out float foo"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Each element of such an array corresponds to one vertex of the primitive
being processed.
Each array can optionally have a size declared.
For geometry shaders, the array size will be set by, (or if provided must be
consistent with) the input <strong>layout</strong> declaration(s) establishing the type of
input primitive, as described later in &#8220;<a href="#input-layout-qualifiers">Input Layout Qualifiers</a>&#8221;.</p>
</div>
<div class="paragraph">
<p>Some inputs and outputs are <em>arrayed</em>, meaning that for an interface between
two shader stages either the input or output declaration requires an extra
level of array indexing for the declarations to match.
For example, with the interface between a vertex shader and a geometry
shader, vertex shader output variables and geometry shader input variables
of the same name must have matching types, except that the geometry shader
will have one more array dimension than the vertex shader, to allow for
vertex indexing.
If such an arrayed interface variable is not declared with the necessary
additional input or output array dimension, a link-time error will result.
Geometry shader inputs, tessellation control shader inputs and outputs, and
tessellation evaluation inputs all have an additional level of arrayness
relative to other shader inputs and outputs.
These inputs and outputs are known as <em>per-vertex-arrayed</em> inputs and
outputs.
Component limits for arrayed interfaces (e.g.
<em>gl_MaxTessControlInputComponents</em>) are limits per vertex, not limits for
the entire interface.</p>
</div>
<div class="paragraph">
<p>For non-arrayed interfaces (meaning array dimensionally stays the same
between stages), it is a link-time error if the input variable is not
declared with the same type, including array dimensionality, as the matching
output variable.</p>
</div>
<div class="paragraph">
<p>The link-time type-matching rules apply to all declared input and output
variables, whether or not they are used.</p>
</div>
<div class="paragraph">
<p>Additionally, tessellation evaluation shaders support per-patch input
variables declared with the <strong>patch</strong> and <strong>in</strong> qualifiers.
Per-patch input variables are filled with the values of per-patch output
variables written by the tessellation control shader.
Per-patch inputs may be declared as one-dimensional arrays, but are not
indexed by vertex number.
Applying the <strong>patch</strong> qualifier to inputs can only be done in tessellation
evaluation shaders.
As with other input variables, per-patch inputs must be declared using the
same type and qualification as per-patch outputs from the previous
(tessellation control) shader stage.
It is a compile-time error to use <strong>patch</strong> with inputs in any other stage.</p>
</div>
<div class="paragraph">
<p>It is a compile-time error to declare a tessellation control, tessellation
evaluation or geometry shader input with, or that contains, any of the
following types:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A <a href="#booleans">boolean type</a></p>
</li>
<li>
<p>An <a href="#opaque-types">opaque type</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Fragment shader inputs get per-fragment values, typically interpolated from
a previous stage&#8217;s outputs.
The auxiliary storage qualifiers <strong>centroid</strong> and <strong>sample</strong> can also be
applied, as well as the interpolation qualifiers <strong>flat</strong>, <strong>noperspective</strong>,
and <strong>smooth.</strong></p>
</div>
<div class="paragraph">
<p>It is a compile-time error to declare a fragment shader input with, or that
contains, any of the following types:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A <a href="#booleans">boolean type</a></p>
</li>
<li>
<p>An <a href="#opaque-types">opaque type</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Fragment shader inputs that are, or contain, integral
or double-precision floating-point
types must be
qualified with the interpolation qualifier <strong>flat</strong>.</p>
</div>
<div class="paragraph">
<p>Fragment inputs are declared as in the following examples:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">in vec3 normal;
centroid in vec2 TexCoord;
noperspective in float temperature;
flat in vec3 myColor;
noperspective centroid in vec2 myTexCoord;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The fragment shader inputs form an interface with the last active shader in
the vertex processing pipeline.
For this interface, the last active shader stage output variables and
fragment shader input variables of the same name must match in type and
qualification, with a few exceptions: The storage qualifiers must, of
course, differ (one is <strong>in</strong> and one is <strong>out</strong>).
Also,
interpolation qualification (e.g. <strong>flat</strong>) and
auxiliary qualification (e.g. <strong>centroid</strong>) may differ.
These mismatches are allowed between any pair of stages.
When
interpolation or
auxiliary qualifiers do not match, those provided in
the fragment shader supersede those provided in previous stages.
If any such qualifiers are completely missing in the fragment shaders, then
the default is used, rather than any qualifiers that may have been declared
in previous stages.
That is, what matters is what is declared in the fragment shaders, not what
is declared in shaders in previous stages.</p>
</div>
<div class="paragraph">
<p>When an interface between shader stages is formed using shaders from two
separate program objects, it is not possible to detect mismatches between
inputs and outputs when the programs are linked.
When there are mismatches between inputs and outputs on such interfaces,
the values passed across the interface will be partially or completely
undefined.</p>
</div>
<div class="paragraph">
<p>Shaders can ensure matches across such interfaces either by using input and
output layout qualifiers (sections &#8220;<a href="#input-layout-qualifiers">Input Layout Qualifiers</a>&#8221; and &#8220;<a href="#output-layout-qualifiers">Output Layout Qualifiers</a>&#8221;) or by using identical input and output declarations of
blocks or variables.
Complete rules for interface matching are found in section 7.4.1 &#8220;Shader
Interface Matching&#8221; of the <a href="references.html#references" class="xref page">OpenGL Specification</a>.</p>
</div>
<div class="paragraph">
<p>Compute shaders do not permit user-defined input variables and do not form a
formal interface with any other shader stage.
See &#8220;<a href="builtins.html#compute-shader-special-variables" class="xref page">Compute Shader Special Variables</a>&#8221; for a description of built-in compute shader input variables.
All other input to a compute shader is retrieved explicitly through image
loads, texture fetches, loads from uniforms or uniform buffers, or other
user supplied code.
Redeclaration of built-in input variables in compute shaders is not
permitted.</p>
</div>
</div>
<div class="sect2">
<h3 id="uniform-variables"><a class="anchor" href="#uniform-variables"></a>Uniform Variables</h3>
<div class="paragraph">
<p>The <strong>uniform</strong> qualifier is used to declare global variables whose values are
the same across the entire primitive being processed.
All <strong>uniform</strong> variables are read-only and are initialized externally either
at link time or through the API.
The link-time initial value is either the value of the variable&#8217;s
initializer, if present, or 0 if no initializer is present.
Opaque types cannot have initializers, or a compile-time error results.
When targeting Vulkan, it is a compile-time error to declare <strong>uniform</strong>
variables outside a block.</p>
</div>
<div class="paragraph">
<p>Example declarations are:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">uniform vec4 lightPosition;
uniform vec3 color = vec3(0.7, 0.7, 0.2); // value assigned at link time</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <strong>uniform</strong> qualifier can be used with any of the basic data types, or
when declaring a variable whose type is a structure, or an array of any of
these.</p>
</div>
<div class="paragraph">
<p>There is an implementation-dependent limit on the amount of storage for
uniforms that can be used for each type of shader and if this is exceeded it
will cause a compile-time or link-time error.
Uniform variables that are declared but not
used do not count against this limit.
The number of user-defined uniform variables and the number of built-in
uniform variables that are used within a shader are added together to
determine whether available uniform storage has been exceeded.</p>
</div>
<div class="paragraph">
<p>Uniforms in shaders all share a single global name space when linked into a
program or separable program.
Hence, the types,
initializers,
and any location specifiers of all statically used uniform variables with the
same name must match across all shaders that are linked into a single program.
However it is not required to repeat the
initializer or
location specifier in all the linked shaders.
While this single uniform name space is cross stage, a uniform variable
name&#8217;s scope is per stage: If a uniform variable name is declared in one
stage (e.g. a vertex shader) but not in another (e.g. a fragment shader),
then that name is still available in the other stage for a different use.</p>
</div>
</div>
<div class="sect2">
<h3 id="output-variables"><a class="anchor" href="#output-variables"></a>Output Variables</h3>
<div class="paragraph">
<p>Shader output variables are declared with the <strong>out</strong> storage qualifier.
They form the output interface between the declaring shader and the
subsequent stages of the API pipeline.
Output variables must be declared at global scope.
During shader execution they will behave as normal unqualified global
variables.
Their values are copied out to the subsequent pipeline stage on shader exit.
Only output variables that are read by the subsequent pipeline stage need to
be written; it is allowed to have superfluous declarations of output
variables.</p>
</div>
<div class="paragraph">
<p>There is <em>not</em> an <strong>inout</strong> storage qualifier for declaring a single variable
name as both input and output to a shader.
Also, a variable cannot be declared with both the <strong>in</strong> and the <strong>out</strong>
qualifiers, this will result in a compile-time or link-time error.
Output variables must be declared with different names than input variables.
However, nesting an input or output inside an interface block with an
instance name allows the same names with one referenced through a block
instance name.</p>
</div>
<div class="paragraph">
<p>Vertex, tessellation evaluation, and geometry output variables output
per-vertex data and are declared using the <strong>out</strong> storage qualifier.
Applying <strong>patch</strong> to an output can only be done in a tessellation control
shader.
It is a compile-time error to use <strong>patch</strong> on outputs in any other stage.</p>
</div>
<div class="paragraph">
<p>It is a compile-time error to declare a vertex, tessellation evaluation,
tessellation control, or geometry shader output with, or that contains, any
of the following types:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A <a href="#booleans">boolean type</a></p>
</li>
<li>
<p>An <a href="#opaque-types">opaque type</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Individual outputs are declared as in the following examples:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">out vec3 normal;
centroid out vec2 TexCoord;
invariant centroid out vec4 Color;
flat out vec3 myColor;
sample out vec4 perSampleColor;</code></pre>
</div>
</div>
<div class="paragraph">
<p>These can also appear in interface blocks, as described in
&#8220;<a href="#interface-blocks">Interface Blocks</a>&#8221;.
Interface blocks allow simpler addition of arrays to the interface from
vertex to geometry shader.
They also allow a fragment shader to have the same input interface as a
geometry shader for a given vertex shader.</p>
</div>
<div class="paragraph">
<p>Tessellation control shader output variables are used to output
per-vertex and per-patch data.
Per-vertex output variables are arrayed (see <em>arrayed</em> under
&#8220;<a href="#input-variables">Input Variables</a>&#8221;) and declared using the <strong>out</strong>
qualifier without the <strong>patch</strong> qualifier.
Per-patch output variables are declared using the <strong>patch</strong> and <strong>out</strong>
qualifiers.</p>
</div>
<div class="paragraph">
<p>Since tessellation control shaders produce an arrayed primitive comprising
multiple vertices, each per-vertex output variable (or output block, see
<a href="#interface-blocks">Interface Blocks</a> below) needs to be declared as an array.
For example,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">out float foo[]; // feeds next stage input "in float foo[]"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Each element of such an array corresponds to one vertex of the primitive
being produced.
Each array can optionally have a size declared.
The array size will be set by (or if provided must be consistent with) the
output layout declaration(s) establishing the number of vertices in the
output patch, as described later in
&#8220;<a href="#tessellation-control-outputs">Tessellation Control Outputs</a>&#8221;.</p>
</div>
<div class="paragraph">
<p>Each tessellation control shader invocation has a corresponding output patch
vertex, and may assign values to per-vertex outputs only if they belong to
that corresponding vertex.
If a per-vertex output variable is used as an l-value, it is a compile-time
or link-time error if the expression indicating the vertex index is not the
identifier <em>gl_InvocationID</em>.</p>
</div>
<div class="paragraph">
<p>The order of execution of a tessellation control shader invocation relative
to the other invocations for the same input patch is undefined unless the
built-in function <strong>barrier</strong>() is used.
This provides some control over relative execution order.
When a shader invocation calls <strong>barrier</strong>(), its execution pauses until all
other invocations have reached the same point of execution.
Output variable assignments performed by any invocation executed prior to
calling <strong>barrier</strong>() will be visible to any other invocation after the call
to <strong>barrier</strong>() returns.</p>
</div>
<div class="paragraph">
<p>Because tessellation control shader invocations execute in undefined order
between barriers, the values of per-vertex or per-patch output variables
will sometimes be undefined.
Consider the beginning and end of shader execution and each call to
<strong>barrier</strong>() as synchronization points.
The value of an output variable will be undefined in any of the three
following cases:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>At the beginning of execution.</p>
</li>
<li>
<p>At each synchronization point, unless</p>
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>the value was well-defined after the previous synchronization point and
was not written by any invocation since, or</p>
</li>
<li>
<p>the value was written by exactly one shader invocation since the previous
synchronization point, or</p>
</li>
<li>
<p>the value was written by multiple shader invocations since the previous
synchronization point, and the last write performed by all such
invocations wrote the same value.</p>
</li>
</ul>
</div>
</div>
</div>
</li>
<li>
<p>When read by a shader invocation, if</p>
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>the value was undefined at the previous synchronization point and has not
been written by the same shader invocation since, or</p>
</li>
<li>
<p>the output variable is written to by any other shader invocation between
the previous and next synchronization points, even if that assignment
occurs in code following the read.</p>
</li>
</ul>
</div>
</div>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>Fragment outputs output per-fragment data and are declared using the <strong>out</strong>
storage qualifier.
It is a compile-time error to use auxiliary storage qualifiers or
interpolation qualifiers in a fragment shader output declaration.
It is a compile-time error to declare a fragment shader output with, or that
contains, any of the following types:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A <a href="#booleans">boolean type</a></p>
</li>
<li>
<p>A double-precision scalar or vector (<strong>double</strong>, <strong>dvec2</strong>, <strong>dvec3</strong>,
<strong>dvec4</strong>)</p>
</li>
<li>
<p>An <a href="#opaque-types">opaque type</a></p>
</li>
<li>
<p>A matrix type</p>
</li>
<li>
<p>A structure</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Fragment outputs are declared as in the following examples:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">out vec4 FragmentColor;
out uint Luminosity;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Compute shaders have no built-in output variables, do not support
user-defined output variables and do not form a formal interface with any
other shader stage.
All outputs from a compute shader take the form of the side effects such as
image stores and operations on atomic counters.</p>
</div>
</div>
<div class="sect2">
<h3 id="buffer-variables"><a class="anchor" href="#buffer-variables"></a>Buffer Variables</h3>
<div class="paragraph">
<p>The <strong>buffer</strong> qualifier is used to declare global variables whose values are
stored in the data store of a buffer object bound through the API.
Buffer variables can be read and written, with the underlying storage shared
among all active shader invocations.
Buffer variable memory reads and writes within a single shader invocation
are processed in order.
However, the order of reads and writes performed in one invocation relative
to those performed by another invocation is largely undefined.
Buffer variables may be qualified with memory qualifiers affecting how the
underlying memory is accessed, as described in &#8220;<a href="#memory-qualifiers">Memory Qualifiers</a>&#8221;.</p>
</div>
<div class="paragraph">
<p>The <strong>buffer</strong> qualifier can be used to declare interface blocks (see
&#8220;<a href="#interface-blocks">Interface Blocks</a>&#8221;), which are then referred to as
shader storage blocks.
It is a compile-time error to declare buffer variables outside a block.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">// use buffer to create a buffer block (shader storage block)
buffer BufferName { // externally visible name of buffer
    int count;      // typed, shared memory...
    ...             // ...
    vec4 v[];       // last member may be an array that is not sized
                    // until after link time (dynamically sized)
} Name;             // name of block within the shader</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are implementation-dependent limits on the number of shader storage
blocks used for each type of shader, the combined number of shader storage
blocks used for a program, and the amount of storage required by each
individual shader storage block.
If any of these limits are exceeded, it will cause a compile-time or
link-time error.</p>
</div>
<div class="paragraph">
<p>If multiple shaders are linked together, then they will share a single
global buffer variable name space.
Hence, the types of all declared buffer variables with the same name must
match across all shaders that are linked into a single program.</p>
</div>
</div>
<div class="sect2">
<h3 id="shared-variables"><a class="anchor" href="#shared-variables"></a>Shared Variables</h3>
<div class="paragraph">
<p>The <strong>shared</strong> qualifier is used to declare global variables that have storage
shared between all work items in a compute shader workgroup.
Variables declared as <strong>shared</strong> may only be used in compute shaders (see
&#8220;<a href="overview.html#compute-processor" class="xref page">Compute Processor</a>&#8221;).
Any other declaration of a <strong>shared</strong> variable is a compile-time error.
Shared variables are implicitly coherent (see
&#8220;<a href="#memory-qualifiers">Memory Qualifiers</a>&#8221;).</p>
</div>
<div class="paragraph">
<p>Variables declared as <strong>shared</strong> may not have initializers and their contents
are undefined at the beginning of shader execution.
Any data written to <strong>shared</strong> variables will be visible to other work items
(executing the same shader) within the same workgroup.</p>
</div>
<div class="paragraph">
<p>In the absence of synchronization, the order of reads and writes to the same
<strong>shared</strong> variable by different invocations of a shader is not defined.</p>
</div>
<div class="paragraph">
<p>In order to achieve ordering with respect to reads and writes to <strong>shared</strong>
variables, control flow barriers must be employed using the <strong>barrier</strong>() function
(see &#8220;<a href="builtinfunctions.html#shader-invocation-control-functions" class="xref page">Shader Invocation Control Functions</a>&#8221;).</p>
</div>
<div class="paragraph">
<p>There is a limit to the total size of all variables declared as <strong>shared</strong> in a
single program.
This limit, expressed in units of basic machine units may be determined by
using the OpenGL API to query the value of
MAX_COMPUTE_SHARED_MEMORY_SIZE.</p>
</div>
</div>
<div class="sect2">
<h3 id="interface-blocks"><a class="anchor" href="#interface-blocks"></a>Interface Blocks</h3>
<div class="paragraph">
<p>Input, output, uniform, and buffer variable declarations can be grouped into
named interface blocks to provide coarser granularity backing than is
achievable with individual declarations.
They can have an optional instance name, used in the shader to reference
their members.
An output block of one programmable stage is backed by a corresponding input
block in the subsequent programmable stage.
A <em>uniform block</em> is backed by the application with a buffer object.
A <em>buffer block</em>, also known as a <em>shader storage block</em>, is also backed
by the application with a buffer object.
It is a compile-time error to have an input block in a vertex shader or an
output block in a fragment shader.
These uses are reserved for future use.</p>
</div>
<div class="paragraph">
<p>An interface block declaration is defined in the grammar as follows:</p>
</div>
<div class="openblock bnf">
<div class="content">
<div class="dlist">
<dl>
<dt class="hdlist1"><em>interface-block</em> : </dt>
<dd>
<p><em>type_qualifier</em> <em>block-name</em> <strong>{</strong> <em>member-list</em> <strong>}</strong> <em>instance-name<sub>opt</sub></em> <strong>;</strong></p>
</dd>
<dt class="hdlist1"><em>block-name</em> : </dt>
<dd>
<p><em>identifier</em></p>
</dd>
<dt class="hdlist1"><em>member-list</em> : </dt>
<dd>
<p><em>member-declaration</em><br>
<em>member-declaration</em> <em>member-list</em></p>
</dd>
<dt class="hdlist1"><em>member-declaration</em> : </dt>
<dd>
<p><em>layout-qualifier<sub>opt</sub></em> <em>qualifiers<sub>opt</sub></em> <em>type</em> <em>declarators</em> <strong>;</strong></p>
</dd>
</dl>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>instance-name</em> : </dt>
<dd>
<p><em>identifier</em><br>
<em>identifier</em> <em>array-specifier</em><br></p>
</dd>
</dl>
</div>
</div>
</div>
<div class="paragraph">
<p>Each of the above elements is discussed below.</p>
</div>
<div class="paragraph">
<p>First, an example,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">uniform Transform {
    mat4 ModelViewMatrix;
    mat4 ModelViewProjectionMatrix;
    uniform mat3 NormalMatrix;      // allowed restatement of qualifier
    float Deformation;
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>The above establishes a uniform block named &#8220;Transform&#8221; with four uniforms
grouped inside it.</p>
</div>
<div class="paragraph">
<p><em>type-qualifier</em> determines the interface of which the block will be a part
and, optionally, additional qualifiers that are applied to the block.
It is a compile-time error if it does not include one of the storage qualifiers
<strong>in</strong>, <strong>out</strong>, <strong>uniform</strong> or <strong>buffer</strong>.
It may optionally include <a href="#layout-qualifiers">layout qualifiers</a>, the
<a href="#storage-qualifiers">auxiliary storage qualifier</a> <strong>patch</strong>, and the
<a href="#the-precise-qualifier">precise qualifier</a>.
<strong>buffer</strong> blocks may additionally include <a href="#memory-qualifiers">Memory Qualifiers</a>.
It is a compile-time error to include any other qualifiers.</p>
</div>
<div class="paragraph">
<p><em>member-list</em> declares the variables that are to be grouped into the block.
Types and declarators are the same as for other input, output, uniform, and
buffer variable declarations outside blocks, with these exceptions:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Initializers are not allowed</p>
</li>
<li>
<p>Opaque types are not allowed</p>
</li>
<li>
<p>Structure definitions cannot be nested inside a block</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Any of these would result in a compile-time error.</p>
</div>
<div class="paragraph">
<p>If no optional qualifier is used in a member-declaration, the qualification
of the member includes all <strong>in</strong>, <strong>out</strong>, <strong>patch</strong>, <strong>uniform</strong>, or <strong>buffer</strong> as
determined by <em>interface-qualifier</em>.
If optional qualifiers are used, they can include interpolation qualifiers,
auxiliary storage qualifiers, precision qualifiers,
and storage qualifiers and they must declare
an input, output, or uniform member consistent with the interface qualifier
of the block: Input variables, output variables, uniform variables, and
<strong>buffer</strong> members can only be in <strong>in</strong> blocks, <strong>out</strong> blocks, <strong>uniform</strong> blocks,
and shader storage blocks, respectively.</p>
</div>
<div class="paragraph">
<p>Repeating the <strong>in</strong>, <strong>out</strong>, <strong>patch</strong>, <strong>uniform</strong>, or <strong>buffer</strong> interface
qualifier for a member&#8217;s storage qualifier is optional.
For example,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">in Material {
    smooth in vec4 Color1; // legal, input inside in block
    smooth vec4 Color2;    // legal, 'in' inherited from 'in Material'
    vec2 TexCoord;         // legal, TexCoord is an input
    uniform float Atten;   // illegal, mismatched storage qualifier
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>Members of <strong>uniform</strong> or <strong>buffer</strong> storage blocks are
always represented in memory as <strong>highp</strong>, regardless of any precision
qualifier associated with the declaration. When values are read from
or written to such variables they are converted to or from the declared
precision as described in
<a href="#conversion-between-precisions">Conversion Between Precisions</a>.
Operations on the values within the shader will take place using the declared
precision as normal.</p>
</div>
<div class="paragraph">
<p>A <em>shader interface</em> is defined to be one of these:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>All the uniform variables and uniform blocks declared in a program.
This spans all compilation units linked together within one program.</p>
</li>
<li>
<p>All the <strong>buffer</strong> blocks declared in a program.</p>
</li>
<li>
<p>The boundary between adjacent programmable pipeline stages: This spans
all the outputs declared in all compilation units of the first stage and
all the inputs declared in all compilation units of the second stage.
Note that for the purposes of this definition, the fragment shader and
the preceding shader are considered to have a shared boundary even
though in practice, all values passed to the fragment shader first pass
through the rasterizer and interpolator.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The block name (<em>block-name</em>) is used to match within shader interfaces: an
output block of one pipeline stage will be matched to an input block with
the same name in the subsequent pipeline stage.
For uniform or shader storage blocks, the application uses the block name to
identify the block.
Block names have no other use within a shader beyond interface matching; it
is a compile-time error
to use a block name at global scope for anything other than as a
block name (e.g. use of a block name for a global variable name or function
name is currently reserved).
It is a compile-time error to use the same block name for more than one
block declaration in the same shader interface (as defined above) within one
shader, even if the block contents are identical.</p>
</div>
<div class="paragraph">
<p>Matched block names within a shader interface (as defined above) must match
in terms of having the same number of declarations with the same sequence of
types and the same sequence of member names, as well as having matching
member-wise layout qualification
(see next section).
Matched uniform or shader storage block names (but not input or output block
names) must also either all be lacking an instance name or all having an
instance name, putting their members at the same scoping level.
When instance names are present on matched block names, it is allowed for
the instance names to differ; they need not match for the blocks to match.
Furthermore, if a matching block is declared as an array, then the array
sizes must also match (or follow array matching rules for the shader
interface between consecutive shader stages).
Any mismatch will generate a link-time error.
A block name is allowed to have different definitions in different shader
interfaces within the same shader, allowing, for example, an input block and
output block to have the same name.</p>
</div>
<div class="paragraph">
<p>If an instance name (<em>instance-name</em>) is not used, the names declared inside
the block are scoped at the global level and accessed as if they were
declared outside the block.
If an instance name (<em>instance-name</em>) is used, then it puts all the members
inside a scope within its own name space, accessed with the field selector
(<strong>.</strong>) operator (analogously to structures).
For example,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">in Light {
    vec4 LightPos;
    vec3 LightColor;
};
in ColoredTexture {
    vec4 Color;
    vec2 TexCoord;
} Material;           // instance name
vec3 Color;           // different Color than Material.Color
vec4 LightPos;        // illegal, already defined
...
... = LightPos;       // accessing LightPos
... = Material.Color; // accessing Color in ColoredTexture block</code></pre>
</div>
</div>
<div class="paragraph">
<p>Outside the shading language (i.e., in the API), members are similarly
identified except the block name is always used in place of the instance
name (API accesses are to shader interfaces, not to shaders).
If there is no instance name, then the API does not use the block name to
access a member, just the member name.</p>
</div>
<div class="paragraph">
<p>Within a shader interface, all declarations of the same global name must be
for the same object and must match in type and in whether they declare a
variable or member of a block with no instance name.
The API also needs this name to uniquely identify an object in the shader
interface.
It is a link-time error if any particular shader interface contains</p>
</div>
<div class="ulist">
<ul>
<li>
<p>two different blocks, each having no instance name, and each having a
member of the same name, or</p>
</li>
<li>
<p>a variable outside a block, and a block with no instance name, where the
variable has the same name as a member in the block.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">out Vertex {
    vec4 Position;  // API transform/feedback will use "Vertex.Position"
    vec2 Texture;
} Coords;           // shader will use "Coords.Position"
out Vertex2 {
    vec4 Color;     // API will use "Color"
    float Color2;
};

// in same program as Vertex2 above:
out Vertex3 {
    float Intensity;
    vec4 Color;     // ERROR, name collision with Color in Vertex2
};
float Color2;       // ERROR, collides with Color2 in Vertex2</code></pre>
</div>
</div>
<div class="paragraph">
<p>For blocks declared as arrays, the array index must also be included when
accessing members, as in this example</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">uniform Transform { // API uses "Transform[2]" to refer to instance 2
    mat4 ModelViewMatrix;
    mat4 ModelViewProjectionMatrix;
    vec4 a[]; // array will get implicitly sized
    float Deformation;
} transforms[4];
...
... = transforms[2].ModelViewMatrix; // shader access of instance 2
// API uses "Transform.ModelViewMatrix" to query an offset or other query
transforms[x].a.length(); // same length for 'a' for all x
Transform[x];             // illegal, must use 'transforms'
Transform.a.length();     // illegal, must use 'transforms'
...transforms[2].a[3]...  // if these are the only two dereferences of 'a',
...transforms[3].a[7]...  // then 'a' must be size 8, for all
transforms[x]</code></pre>
</div>
</div>
<div class="paragraph">
<p>For uniform or shader storage blocks declared as an array, each individual
array element corresponds to a separate buffer object bind range, backing
one instance of the block.
As the array size indicates the number of buffer objects needed, uniform and
shader storage block array declarations must specify an array size.
A uniform
or shader storage
block array can only be indexed with a
dynamically uniform integral expression, otherwise results are undefined.</p>
</div>
<div class="paragraph">
<p>When using OpenGL API entry points to identify the name of an individual
block in an array of blocks, the name string may include an array index
(e.g. <em>Transform[2]</em>).
When using OpenGL API entry points to refer to offsets or other
characteristics of a block member, an array index must not be specified
(e.g. <em>Transform.ModelViewMatrix</em>).</p>
</div>
<div class="paragraph">
<p>Tessellation control, tessellation evaluation and geometry shader input
blocks must be declared as arrays and follow the array declaration and
linking rules for all shader inputs for the respective stages.
All other input and output block arrays must specify an array size.</p>
</div>
<div class="paragraph">
<p>There are implementation-dependent limits on the number of uniform blocks
and the number of shader storage blocks that can be used per stage.
If either limit is exceeded, it will cause a link-time error.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="layout-qualifiers"><a class="anchor" href="#layout-qualifiers"></a>Layout Qualifiers</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Layout qualifiers can appear in several forms of declaration.
They can appear as part of an interface block definition or block member, as
shown in the grammar in the previous section.
They can also appear with just an <em>interface-qualifier</em> to establish layouts
of other declarations made with that qualifier:</p>
</div>
<div class="openblock bnf">
<div class="content">
<div class="paragraph">
<p><em>layout-qualifier</em> <em>interface-qualifier</em> <strong>;</strong></p>
</div>
</div>
</div>
<div class="paragraph">
<p>Or, they can appear with an individual variable declared with an interface
qualifier:</p>
</div>
<div class="openblock bnf">
<div class="content">
<div class="paragraph">
<p><em>layout-qualifier</em> <em>interface-qualifier</em> <em>declaration</em> <strong>;</strong></p>
</div>
</div>
</div>
<div class="paragraph">
<p>Declarations of layouts can only be made at global scope or block members,
and only where indicated in the following subsections; their details are
specific to what the interface qualifier is, and are discussed individually.</p>
</div>
<div class="paragraph">
<p>The <em>layout-qualifier</em> expands to:</p>
</div>
<div class="openblock bnf">
<div class="content">
<div class="dlist">
<dl>
<dt class="hdlist1"><em>layout-qualifier</em> : </dt>
<dd>
<p><strong>layout</strong> <strong>(</strong> <em>layout-qualifier-id-list</em> <strong>)</strong></p>
</dd>
<dt class="hdlist1"><em>layout-qualifier-id-list</em> : </dt>
<dd>
<p><em>layout-qualifier-id</em><br>
<em>layout-qualifier-id</em> <strong>,</strong> <em>layout-qualifier-id-list</em></p>
</dd>
<dt class="hdlist1"><em>layout-qualifier-id</em> : </dt>
<dd>
<p><em>layout-qualifier-name</em><br>
<em>layout-qualifier-name</em> <strong>=</strong> <em>layout-qualifier-value</em><br>
<strong>shared</strong></p>
</dd>
</dl>
</div>
</div>
</div>
<div class="openblock bnf">
<div class="content">
<div class="dlist">
<dl>
<dt class="hdlist1"><em>layout-qualifier-value</em> : </dt>
<dd>
<p><em>integer-constant-expression</em></p>
</dd>
</dl>
</div>
</div>
</div>
<div class="paragraph">
<p>The tokens used for <em>layout-qualifier-name</em> are identifiers, not keywords,
however, the <strong>shared</strong> keyword is allowed as a <em>layout-qualifier-id</em>.
Generally, they can be listed in any order.
Order-dependent meanings exist only if explicitly called out below.
Similarly, these identifiers are not case sensitive, unless explicitly noted
otherwise.</p>
</div>
<div class="paragraph">
<p>More than one layout qualifier may appear in a single declaration.
Additionally, the same <em>layout-qualifier-name</em> can occur multiple times
within a layout qualifier or across multiple layout qualifiers in the same
declaration.
When the same <em>layout-qualifier-name</em> occurs multiple times, in a single
declaration, the last occurrence overrides the former occurrence(s).
Further, if such a <em>layout-qualifier-name</em> will affect subsequent
declarations or other observable behavior, it is only the last occurrence
that will have any effect, behaving as if the earlier occurrence(s) within
the declaration are not present.
This is also true for overriding <em>layout-qualifier-name</em>, where one
overrides the other (e.g. <strong>row_major</strong> vs.
<strong>column_major</strong>); only the last occurrence has any effect.</p>
</div>
<div class="paragraph">
<p><em>integer-constant-expression</em> is defined in
&#8220;<a href="#constant-expressions">Constant Expressions</a>&#8221; as <em>constant integral
expression</em>, with it being a compile-time error for
<em>integer-constant-expression</em> to be a specialization constant.</p>
</div>
<div class="paragraph">
<p>The following table summarizes the use of layout qualifiers.
It shows for each one what kinds of declarations it may be applied to.
These are all discussed in detail in the following sections.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.667%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-middle">Layout Qualifier</th>
<th class="tableblock halign-center valign-middle">Qualifier Only</th>
<th class="tableblock halign-center valign-middle">Individual Variable</th>
<th class="tableblock halign-center valign-middle">Block</th>
<th class="tableblock halign-center valign-middle">Block Member</th>
<th class="tableblock halign-left valign-middle">Allowed Interfaces</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-middle"><p class="tableblock"><strong>shared</strong><br>
  <strong>packed</strong><br>
  <strong>std140</strong><br>
  <strong>std430</strong></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock">X</p></td>
<td class="tableblock halign-center valign-middle"></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock">X</p></td>
<td class="tableblock halign-center valign-middle"></td>
<td class="tableblock halign-left valign-middle" rowspan="5"><p class="tableblock"><strong>uniform</strong> / <strong>buffer</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle"><p class="tableblock"><strong>row_major</strong><br>
  <strong>column_major</strong></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock">X</p></td>
<td class="tableblock halign-center valign-middle"></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock">X</p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle"><p class="tableblock"><strong>binding</strong> =</p></td>
<td class="tableblock halign-center valign-middle"></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock">opaque types only</p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock">X</p></td>
<td class="tableblock halign-center valign-middle"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle"><p class="tableblock"><strong>offset</strong> =</p></td>
<td class="tableblock halign-center valign-middle"></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock">atomic counters only</p></td>
<td class="tableblock halign-center valign-middle"></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle"><p class="tableblock"><strong>align</strong> =</p></td>
<td class="tableblock halign-center valign-middle"></td>
<td class="tableblock halign-center valign-middle"></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock">X</p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle"><p class="tableblock"><strong>set</strong> =</p></td>
<td class="tableblock halign-center valign-middle"></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock">opaque types only</p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock">X</p></td>
<td class="tableblock halign-center valign-middle"></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock"><strong>uniform</strong> / <strong>buffer</strong> (Vulkan only)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle"><p class="tableblock"><strong>push_constant</strong></p></td>
<td class="tableblock halign-center valign-middle"></td>
<td class="tableblock halign-center valign-middle"></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock">X</p></td>
<td class="tableblock halign-center valign-middle"></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock"><strong>uniform</strong> (Vulkan only)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle"><p class="tableblock"><strong>input_attachment_index</strong> =</p></td>
<td class="tableblock halign-center valign-middle"></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock">subpass types only</p></td>
<td class="tableblock halign-center valign-middle"></td>
<td class="tableblock halign-center valign-middle"></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock"><strong>uniform</strong> (Vulkan only)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle"><p class="tableblock"><strong>location</strong> =</p></td>
<td class="tableblock halign-center valign-middle"></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock">X</p></td>
<td class="tableblock halign-center valign-middle"></td>
<td class="tableblock halign-center valign-middle"></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock"><strong>uniform</strong> / <strong>buffer</strong> and subroutine variables</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle"><p class="tableblock"><strong>location</strong> =</p></td>
<td class="tableblock halign-center valign-middle"></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock">X</p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock">X</p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock">X<sup>1</sup></p></td>
<td class="tableblock halign-left valign-middle" rowspan="2"><p class="tableblock">all <strong>in</strong> / <strong>out</strong>, except for compute</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle"><p class="tableblock"><strong>component</strong> =</p></td>
<td class="tableblock halign-center valign-middle"></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock">X</p></td>
<td class="tableblock halign-center valign-middle"></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle"><p class="tableblock"><strong>index</strong> =</p></td>
<td class="tableblock halign-center valign-middle"></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock">X</p></td>
<td class="tableblock halign-center valign-middle"></td>
<td class="tableblock halign-center valign-middle"></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">fragment <strong>out</strong> and subroutine functions</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle"><p class="tableblock"><strong>triangles</strong><br>
  <strong>quads</strong><br>
  <strong>isolines</strong></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock">X</p></td>
<td class="tableblock halign-center valign-middle"></td>
<td class="tableblock halign-center valign-middle"></td>
<td class="tableblock halign-center valign-middle"></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">tessellation evaluation <strong>in</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle"><p class="tableblock"><strong>equal_spacing</strong><br>
  <strong>fractional_even_spacing</strong><br>
  <strong>fractional_odd_spacing</strong></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock">X</p></td>
<td class="tableblock halign-center valign-middle"></td>
<td class="tableblock halign-center valign-middle"></td>
<td class="tableblock halign-center valign-middle"></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">tessellation evaluation <strong>in</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle"><p class="tableblock"><strong>cw</strong><br>
  <strong>ccw</strong></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock">X</p></td>
<td class="tableblock halign-center valign-middle"></td>
<td class="tableblock halign-center valign-middle"></td>
<td class="tableblock halign-center valign-middle"></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">tessellation evaluation <strong>in</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle"><p class="tableblock"><strong>point_mode</strong></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock">X</p></td>
<td class="tableblock halign-center valign-middle"></td>
<td class="tableblock halign-center valign-middle"></td>
<td class="tableblock halign-center valign-middle"></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">tessellation evaluation <strong>in</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle"><p class="tableblock"><strong>points</strong></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock">X</p></td>
<td class="tableblock halign-center valign-middle"></td>
<td class="tableblock halign-center valign-middle"></td>
<td class="tableblock halign-center valign-middle"></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">geometry <strong>in</strong>/<strong>out</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle"><p class="tableblock">[ <strong>points</strong> ]<br>
  <strong>lines</strong><br>
  <strong>lines_adjacency</strong><br>
  <strong>triangles</strong><br>
  <strong>triangles_adjacency</strong></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock">X</p></td>
<td class="tableblock halign-center valign-middle"></td>
<td class="tableblock halign-center valign-middle"></td>
<td class="tableblock halign-center valign-middle"></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">geometry <strong>in</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle"><p class="tableblock"><strong>invocations</strong> =</p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock">X</p></td>
<td class="tableblock halign-center valign-middle"></td>
<td class="tableblock halign-center valign-middle"></td>
<td class="tableblock halign-center valign-middle"></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">geometry <strong>in</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle"><p class="tableblock"><strong>origin_upper_left</strong><br>
  <strong>pixel_center_integer</strong></p></td>
<td class="tableblock halign-center valign-middle"></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><em>gl_FragCoord</em> only</p></td>
<td class="tableblock halign-center valign-middle"></td>
<td class="tableblock halign-center valign-middle"></td>
<td class="tableblock halign-left valign-middle" rowspan="2"><p class="tableblock">fragment <strong>in</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle"><p class="tableblock"><strong>early_fragment_tests</strong></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock">X</p></td>
<td class="tableblock halign-center valign-middle"></td>
<td class="tableblock halign-center valign-middle"></td>
<td class="tableblock halign-center valign-middle"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle"><p class="tableblock"><strong>local_size_x</strong> =<br>
  <strong>local_size_y</strong> =<br>
  <strong>local_size_z</strong> =</p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock">X</p></td>
<td class="tableblock halign-center valign-middle"></td>
<td class="tableblock halign-center valign-middle"></td>
<td class="tableblock halign-center valign-middle"></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">compute <strong>in</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle"><p class="tableblock"><strong>local_size_x_id</strong> =<br>
  <strong>local_size_y_id</strong> =<br>
  <strong>local_size_z_id</strong> =</p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock">X</p></td>
<td class="tableblock halign-center valign-middle"></td>
<td class="tableblock halign-center valign-middle"></td>
<td class="tableblock halign-center valign-middle"></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">compute <strong>in</strong> (SPIR-V only)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle"><p class="tableblock"><strong>xfb_buffer</strong> =<br>
  <strong>xfb_stride</strong> =</p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock">X</p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock">X</p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock">X</p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock">X</p></td>
<td class="tableblock halign-left valign-middle" rowspan="2"><p class="tableblock">vertex, tessellation, and geometry <strong>out</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle"><p class="tableblock"><strong>xfb_offset</strong> =</p></td>
<td class="tableblock halign-center valign-middle"></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock">X</p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock">X</p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle"><p class="tableblock"><strong>vertices</strong> =</p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock">X</p></td>
<td class="tableblock halign-center valign-middle"></td>
<td class="tableblock halign-center valign-middle"></td>
<td class="tableblock halign-center valign-middle"></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">tessellation control <strong>out</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle"><p class="tableblock">[ <strong>points</strong> ]<br>
  <strong>line_strip</strong><br>
  <strong>triangle_strip</strong></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock">X</p></td>
<td class="tableblock halign-center valign-middle"></td>
<td class="tableblock halign-center valign-middle"></td>
<td class="tableblock halign-center valign-middle"></td>
<td class="tableblock halign-left valign-middle" rowspan="3"><p class="tableblock">geometry <strong>out</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle"><p class="tableblock"><strong>max_vertices</strong> =</p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock">X</p></td>
<td class="tableblock halign-center valign-middle"></td>
<td class="tableblock halign-center valign-middle"></td>
<td class="tableblock halign-center valign-middle"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle"><p class="tableblock"><strong>stream</strong> =</p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock">X</p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock">X</p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock">X</p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle"><p class="tableblock"><strong>depth_any</strong><br>
  <strong>depth_greater</strong><br>
  <strong>depth_less</strong><br>
  <strong>depth_unchanged</strong></p></td>
<td class="tableblock halign-center valign-middle"></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><em>gl_FragDepth</em> only</p></td>
<td class="tableblock halign-center valign-middle"></td>
<td class="tableblock halign-center valign-middle"></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">fragment <strong>out</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle"><p class="tableblock"><strong>constant_id</strong> =</p></td>
<td class="tableblock halign-center valign-middle"></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock">scalar only</p></td>
<td class="tableblock halign-center valign-middle"></td>
<td class="tableblock halign-center valign-middle"></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock"><strong>const</strong> (SPIR-V only)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-middle"><p class="tableblock"><strong>rgba32f</strong><br>
  <strong>rgba16f</strong><br>
  <strong>rg32f</strong><br>
  <strong>rg16f</strong><br>
  <strong>r11f_g11f_b10f</strong><br>
  <strong>r32f</strong><br>
  <strong>r16f</strong><br>
  <strong>rgba16</strong><br>
  <strong>rgb10_a2</strong><br>
  <strong>rgba8</strong><br>
  <strong>rg16</strong><br>
  <strong>rg8</strong><br>
  <strong>r16</strong><br>
  <strong>r8</strong><br>
  <strong>rgba16_snorm</strong><br>
  <strong>rgba8_snorm</strong><br>
  <strong>rg16_snorm</strong><br>
  <strong>rg8_snorm</strong><br>
  <strong>r16_snorm</strong><br>
  <strong>r8_snorm</strong><br>
  <strong>rgba32i</strong><br>
  <strong>rgba16i</strong><br>
  <strong>rgba8i</strong><br>
  <strong>rg32i</strong><br>
  <strong>rg16i</strong><br>
  <strong>rg8i</strong><br>
  <strong>r32i</strong><br>
  <strong>r16i</strong><br>
  <strong>r8i</strong><br>
  <strong>rgba32ui</strong><br>
  <strong>rgba16ui</strong><br>
<strong>rgb10_a2ui</strong><br>
  <strong>rgba8ui</strong><br>
  <strong>rg32ui</strong><br>
  <strong>rg16ui</strong><br>
  <strong>rg8ui</strong><br>
  <strong>r32ui</strong><br>
  <strong>r16ui</strong><br>
  <strong>r8ui</strong></p></td>
<td class="tableblock halign-center valign-middle"></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock">image types only</p></td>
<td class="tableblock halign-center valign-middle"></td>
<td class="tableblock halign-center valign-middle"></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock"><strong>uniform</strong></p></td>
</tr>
</tbody>
</table>
<div class="dlist">
<dl>
<dt class="hdlist1">1</dt>
<dd>
<p>Location qualifiers are not allowed for members of an arrayed block,
except for per-vertex-arrays (see &#8220;<a href="#interface-blocks">Interface    Blocks</a>&#8221;).</p>
</dd>
</dl>
</div>
<div class="sect2">
<h3 id="input-layout-qualifiers"><a class="anchor" href="#input-layout-qualifiers"></a>Input Layout Qualifiers</h3>
<div class="paragraph">
<p>Layout qualifiers specific to a particular shader language are discussed in
separate sections below.</p>
</div>
<div class="paragraph">
<p>All shaders except compute shaders allow <strong>location</strong> layout qualifiers on
input variable declarations, input block declarations, and input block
member declarations.
Of these, variables and block members (but not blocks) additionally allow
the <strong>component</strong> layout qualifier.</p>
</div>
<div class="openblock bnf">
<div class="content">
<div class="dlist">
<dl>
<dt class="hdlist1"><em>layout-qualifier-id</em> : </dt>
<dd>
<p><strong>location</strong> <strong>=</strong> <em>layout-qualifier-value</em><br>
<strong>component</strong> <strong>=</strong> <em>layout-qualifier-value</em></p>
</dd>
</dl>
</div>
</div>
</div>
<div class="paragraph">
<p>For example,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">layout(location = 3) in vec4 normal;
const int start = 6;
layout(location = start + 2) in vec4 v;</code></pre>
</div>
</div>
<div class="paragraph">
<p>will establish that the shader input <em>normal</em> is assigned to vector location
number
3 and <em>v</em> is assigned location number 8.
For vertex shader inputs, the location specifies the number of the
vertex attribute from which input values are taken.
For inputs of all other shader types, the location specifies a vector number
that can be used to match against outputs from a previous shader stage, even
if that shader is in a different program object.</p>
</div>
<div class="paragraph">
<p>The following language describes how many locations are consumed by a given
type.
However, geometry shader inputs, tessellation control shader inputs and
outputs, and tessellation evaluation inputs all have an additional level of
arrayness relative to other shader inputs and outputs.
This outer array level is removed from the type before considering how many
locations the type consumes.</p>
</div>
<div class="paragraph">
<p>Except when targeting Vulkan,
if a vertex shader input is any scalar or vector type, it will consume a
single location.
If a non-vertex shader input, or any stage input when targeting Vulkan,
is a scalar or vector type other than <strong>dvec3</strong>
or <strong>dvec4</strong>, it will consume a single location, while types <strong>dvec3</strong> or
<strong>dvec4</strong> will consume two consecutive locations.</p>
</div>
<div class="paragraph">
<p>If the declared input (after potentially removing an outer array level as
just described above) is an array of size <em>n</em> and each of the elements takes
<em>m</em> locations, it will be assigned <em>m</em> * <em>n</em> consecutive locations starting
with the location specified.
For example,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">layout(location = 6) in vec4 colors[3];</code></pre>
</div>
</div>
<div class="paragraph">
<p>will establish that the shader input <em>colors</em> is assigned to vector location
numbers 6, 7, and 8.</p>
</div>
<div class="paragraph">
<p>If the declared input is an <em>n</em> × <em>m</em>
matrix, it will be assigned multiple locations starting with the location
specified.
The number of locations assigned for each matrix will be the same as for an
<em>n</em>-element array of <em>m</em>-component vectors.
For example,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">layout(location = 9) in mat4 transforms[2];</code></pre>
</div>
</div>
<div class="paragraph">
<p>will establish that shader input <em>transforms</em> is assigned to vector
locations 9-16, with <em>transforms[0]</em> being assigned to locations 9-12, and
<em>transforms[1]</em> being assigned to locations 13-16.</p>
</div>
<div class="paragraph">
<p>If the declared input is a structure or block, its members will be assigned
consecutive locations in their order of declaration, with the first member
assigned the location provided in the layout qualifier.
For a structure, this process applies to the entire structure.
It is a compile-time error to use a <strong>location</strong> qualifier on a member of a
structure.
For a block, this process applies to the entire block, or until the first
member is reached that has a <strong>location</strong> layout qualifier.</p>
</div>
<div class="paragraph">
<p>When a block member is declared with a <strong>location</strong> qualifier, its location
comes from that qualifier; the member&#8217;s <strong>location</strong> qualifier overrides the
block-level declaration.
Subsequent members are again assigned consecutive locations, based on the
newest location, until the next member declared with a <strong>location</strong> qualifier.
The values used for locations do not have to be declared in increasing
order.</p>
</div>
<div class="paragraph">
<p>If a block has no block-level <strong>location</strong> layout qualifier, it is required
that either all or none of its members have a <strong>location</strong> layout qualifier,
or a compile-time error results.
For some blocks declared as arrays, the <strong>location</strong> can only be applied at
the block level: When a block is declared as an array where additional
locations are needed for each member for each block array element, it is a
compile-time error to specify locations on the block members.
For <em>arrayed</em> interfaces (those generally having an extra level of arrayness
due to interface expansion), the outer array is stripped before applying
this rule.</p>
</div>
<div class="paragraph">
<p>When generating SPIR-V, all <strong>in</strong> and <strong>out</strong> qualified user-declared (non
built-in) variables and blocks (or all their members) must have a
shader-specified <strong>location</strong>.
Otherwise, a compile-time error is generated.</p>
</div>
<div class="paragraph">
<p>The locations consumed by block and structure members are determined by
applying the rules above recursively as though the structure member were
declared as an input variable of the same type.
For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">layout(location = 3) in struct S
{
    vec3 a;                      // gets location 3
    mat2 b;                      // gets locations 4 and 5
    vec4 c[2];                   // gets locations 6 and 7
    layout(location = 8) vec2 A; // ERROR, can't use on struct member
} s;
layout(location = 4) in block
{
    vec4 d;                      // gets location 4
    vec4 e;                      // gets location 5
    layout(location = 7) vec4 f; // gets location 7
    vec4 g;                      // gets location 8
    layout(location = 1) vec4 h; // gets location 1
    vec4 i;                      // gets location 2
    vec4 j;                      // gets location 3
    vec4 k;                      // ERROR, location 4 already used
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>The number of input locations available to a shader is limited.
For vertex shaders, the limit is the advertised number of vertex attributes.
For all other shaders, the limit is implementation-dependent and must be no
less than one fourth of the advertised maximum input component count.</p>
</div>
<div class="paragraph">
<p>A program will fail to link if any attached shader uses a location greater
than or equal to the number of supported locations, unless device-dependent
optimizations are able to make the program fit within available hardware
resources.</p>
</div>
<div class="paragraph">
<p>A program will fail to link if explicit location assignments leave the
linker unable to find space for other variables without explicit
assignments.</p>
</div>
<div class="paragraph">
<p>For the purposes of determining if a non-vertex input matches an output from
a previous shader stage, the <strong>location</strong> layout qualifier (if any) must
match.</p>
</div>
<div class="paragraph">
<p>If a vertex shader input variable with no location assigned in the shader
text has a location specified through the OpenGL API, the API-assigned
location will be used.
Otherwise, such variables will be assigned a location by the linker.
See section 11.1.1 &#8220;Vertex Attributes&#8221; of the <a href="references.html#references" class="xref page">OpenGL Specification</a> for
more details.
A link-time error will occur if an input variable is declared in multiple
shaders of the same language with conflicting locations.</p>
</div>
<div class="paragraph">
<p>The <strong>component</strong> qualifier allows the location to be more finely specified
for scalars and vectors, down to the individual components within a location
that are consumed.
It is a compile-time error to use <strong>component</strong> without also specifying the
<strong>location</strong> qualifier (order does not matter).
The components within a location are 0, 1, 2, and 3.
A variable or block member starting at component <em>N</em> will consume components
<em>N</em>, <em>N+1</em>, <em>N+2</em>, &#8230;&#8203;
up through its size.
It is a compile-time error if this sequence of components gets larger than
3.
A scalar <strong>double</strong> will consume two of these components, and a <strong>dvec2</strong> will
consume all four components available within a location.
A <strong>dvec3</strong> or <strong>dvec4</strong> can only be declared without specifying a <strong>component</strong>.
A <strong>dvec3</strong> will consume all four components of the first location and
components 0 and 1 of the second location.
This leaves components 2 and 3 available for other component-qualified
declarations.</p>
</div>
<div class="paragraph">
<p>For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">// a consumes components 2 and 3 of location 4
layout(location = 4, component = 2) in vec2 a;

// b consumes component 1 of location 4
layout(location = 4, component = 1) in float b;

// ERROR: c overflows component 3
layout(location = 3, component = 2) in vec3 c;

// d consumes components 2 and 3 of location 5
layout(location = 5, component = 2) in double d;

// ERROR: e overflows component 3 of location 6
layout(location = 6, component = 2) in dvec2 e;

// ERROR: f overlaps with g
layout(location = 7, component = 0) in vec2 f;
layout(location = 7, component = 1) in float g;

layout(location = 8) in dvec3 h; // components 0,1,2 and 3 of location 8
                                 // and components 0 and 1 of location 9
layout(location = 9, component = 2) in double i; // okay, compts 2 and 3</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the variable is an array, each element of the array, in order, is
assigned to consecutive locations, but all at the same specified component
within each location.
For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">// component 3 is consumed in each of 6 locations
layout(location = 2, component = 3) in float d[6];</code></pre>
</div>
</div>
<div class="paragraph">
<p>That is, location 2 component 3 will hold <em>d[0]</em>, location 3 component 3
will hold <em>d[1]</em>, &#8230;&#8203;, up through location 7 component 3 holding <em>d[5]</em>.</p>
</div>
<div class="paragraph">
<p>This allows packing of two arrays into the same set of locations:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">// e consumes beginning (components 0, 1 and 2) of each of 6 slots
layout(location = 0, component = 0) in vec3 e[6];

// f consumes last component of the same 6 slots
layout(location = 0, component = 3) in float f[6];</code></pre>
</div>
</div>
<div class="paragraph">
<p>If applying this to an array of arrays, all levels of arrayness are removed
to get to the elements that are assigned per location to the specified
component.
These non-arrayed elements will fill the locations in the order specified
for arrays of arrays in &#8220;<a href="#arrays">Arrays</a>&#8221;.</p>
</div>
<div class="paragraph">
<p>It is a compile-time error to apply the <strong>component</strong> qualifier to a matrix, a
structure, a block, or an array containing any of these.
It is a compile-time error to use <strong>component</strong> 1 or 3 as the beginning of a
<strong>double</strong> or <strong>dvec2</strong>.
It is a link-time error to specify different components for the same
variable within a program.</p>
</div>
<div class="paragraph">
<p><em>Location aliasing</em> is causing two variables or block members to have the
same location number.
<em>Component aliasing</em> is assigning the same (or overlapping) component
numbers for two location aliases.
(Recall if <strong>component</strong> is not used, components are assigned starting with
0.)
With one exception, location aliasing is allowed only if it does not
cause component aliasing; it is a compile-time or link-time error to cause
component aliasing.
Further, when location aliasing, the aliases sharing the location must have
the same underlying numerical type and bit width  (floating-point or integer,
32-bit versus 64-bit, etc.) and the same
auxiliary storage and interpolation qualification.
The one exception where component aliasing is permitted is
when targeting OpenGL for two input
variables (not block members) to a vertex shader, which are allowed to have
component aliasing.
This vertex-variable component aliasing is intended only to support vertex
shaders where each execution path accesses at most one input per
aliased component.
Implementations are permitted, but not required, to generate link-time
errors if they detect that every path through the vertex shader executable
accesses multiple inputs aliased to any single component.</p>
</div>
<div class="sect3">
<h4 id="tessellation-evaluation-inputs"><a class="anchor" href="#tessellation-evaluation-inputs"></a>Tessellation Evaluation Inputs</h4>
<div class="paragraph">
<p>Additional input layout qualifier identifiers allowed for tessellation
evaluation shaders are described below.</p>
</div>
<div class="openblock bnf">
<div class="content">
<div class="dlist">
<dl>
<dt class="hdlist1"><em>layout-qualifier-id</em> : </dt>
<dd>
<p><em>primitive_mode</em><br>
<em>vertex_spacing</em><br>
<em>ordering</em><br>
<em>point_mode</em></p>
</dd>
</dl>
</div>
</div>
</div>
<div class="paragraph">
<p>The <strong>primitive-mode</strong> is used to specify a tessellation primitive mode to be
used by the tessellation primitive generator.</p>
</div>
<div class="openblock bnf">
<div class="content">
<div class="dlist">
<dl>
<dt class="hdlist1"><em>primitive-mode</em>: </dt>
<dd>
<p><strong>triangles</strong><br>
<strong>quads</strong><br>
<strong>isolines</strong></p>
</dd>
</dl>
</div>
</div>
</div>
<div class="paragraph">
<p>If present, the <em>primitive-mode</em> specifies that the tessellation primitive
generator should subdivide a triangle into smaller triangles, a quad into
triangles, or a quad into a collection of lines, respectively.</p>
</div>
<div class="paragraph">
<p>A second group of layout identifiers, <em>vertex spacing</em>, is used to specify
the spacing used by the tessellation primitive generator when subdividing an
edge.</p>
</div>
<div class="openblock bnf">
<div class="content">
<div class="dlist">
<dl>
<dt class="hdlist1"><em>vertex-spacing</em>: </dt>
<dd>
<p><strong>equal_spacing</strong><br>
<strong>fractional_even_spacing</strong><br>
<strong>fractional_odd_spacing</strong></p>
</dd>
</dl>
</div>
</div>
</div>
<div class="paragraph">
<p><strong>equal_spacing</strong> specifies that edges should be divided into a collection of
equal-sized segments;</p>
</div>
<div class="paragraph">
<p><strong>fractional_even_spacing</strong> specifies that edges should be divided into an
even number of equal-length segments plus two additional shorter
&#8220;fractional&#8221; segments; or</p>
</div>
<div class="paragraph">
<p><strong>fractional_odd_spacing</strong> specifies that edges should be divided into an odd
number of equal-length segments plus two additional shorter &#8220;fractional&#8221;
segments.</p>
</div>
<div class="paragraph">
<p>A third group of layout identifiers, <em>ordering</em>, specifies whether the
tessellation primitive generator produces triangles in clockwise or
counter-clockwise order, according to the coordinate system depicted in the
<a href="references.html#references" class="xref page">OpenGL Specification</a>.</p>
</div>
<div class="openblock bnf">
<div class="content">
<div class="dlist">
<dl>
<dt class="hdlist1"><em>ordering</em>: </dt>
<dd>
<p><strong>cw</strong><br>
<strong>ccw</strong></p>
</dd>
</dl>
</div>
</div>
</div>
<div class="paragraph">
<p>The identifiers <strong>cw</strong> and <strong>ccw</strong> indicate clockwise and counter-clockwise
triangles, respectively.
If the tessellation primitive generator does not produce triangles, the
order is ignored.</p>
</div>
<div class="paragraph">
<p>Finally, <em>point mode</em> indicates that the tessellation primitive generator
should produce one point for each distinct vertex in the subdivided
primitive, rather than generating lines or triangles.</p>
</div>
<div class="openblock bnf">
<div class="content">
<div class="dlist">
<dl>
<dt class="hdlist1"><em>point-mode</em>: </dt>
<dd>
<p><strong>point_mode</strong></p>
</dd>
</dl>
</div>
</div>
</div>
<div class="paragraph">
<p>Any or all of these identifiers may be specified one or more times in a
single input layout declaration.
If primitive mode, vertex spacing, or ordering is declared more than once in
the tessellation evaluation shaders of a program, all such declarations must
use the same identifier.</p>
</div>
<div class="paragraph">
<p>At least one tessellation evaluation shader (compilation unit) in a program
must declare a primitive mode in its input layout.
Declaring vertex spacing, ordering, or point mode identifiers is optional.
It is not required that all tessellation evaluation shaders in a program
declare a primitive mode.
If spacing or vertex ordering declarations are omitted, the tessellation
primitive generator will use equal spacing or counter-clockwise vertex
ordering, respectively.
If a point mode declaration is omitted, the tessellation primitive generator
will produce lines or triangles according to the primitive mode.</p>
</div>
</div>
<div class="sect3">
<h4 id="geometry-shader-inputs"><a class="anchor" href="#geometry-shader-inputs"></a>Geometry Shader Inputs</h4>
<div class="paragraph">
<p>Additional layout qualifier identifiers for geometry shader inputs include
<em>primitive</em> identifiers and an <em>invocation count</em> identifier:</p>
</div>
<div class="openblock bnf">
<div class="content">
<div class="dlist">
<dl>
<dt class="hdlist1"><em>layout-qualifier-id</em> : </dt>
<dd>
<p><strong>points</strong><br>
<strong>lines</strong><br>
<strong>lines_adjacency</strong><br>
<strong>triangles</strong><br>
<strong>triangles_adjacency</strong><br>
<strong>invocations</strong> <strong>=</strong> <em>layout-qualifier-value</em></p>
</dd>
</dl>
</div>
</div>
</div>
<div class="paragraph">
<p>The identifiers <strong>points</strong>, <strong>lines</strong>, <strong>lines_adjacency</strong>, <strong>triangles</strong>, and
<strong>triangles_adjacency</strong> are used to specify the type of input primitive
accepted by the geometry shader, and only one of these is accepted.
At least one geometry shader (compilation unit) in a program must declare
this input primitive layout, and all geometry shader input layout
declarations in a program must declare the same layout.
It is not required that all geometry shaders in a program declare an input
primitive layout.</p>
</div>
<div class="paragraph">
<p>The identifier <strong>invocations</strong> is used to specify the number of times the
geometry shader executable is invoked for each input primitive received.
Invocation count declarations are optional.
If no invocation count is declared in any geometry shader in a program, the
geometry shader will be run once for each input primitive.
If an invocation count is declared, all such declarations must specify the
same count.
If a shader specifies an invocation count greater than the
implementation-dependent maximum, or less than or equal to zero,
a compile-time error results.</p>
</div>
<div class="paragraph">
<p>For example,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">layout(triangles, invocations = 6) in;</code></pre>
</div>
</div>
<div class="paragraph">
<p>will establish that all inputs to the geometry shader are triangles and that
the geometry shader executable is run six times for each triangle processed.</p>
</div>
<div class="paragraph">
<p>All geometry shader input unsized array declarations will be sized by an
earlier input primitive layout qualifier, when present, as per the following
table.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Layout</th>
<th class="tableblock halign-left valign-top">Size of Input Arrays</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>points</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>lines</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>lines_adjacency</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>triangles</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">3</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>triangles_adjacency</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">6</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The intrinsically declared input array <em>gl_in[]</em> will also be sized by any
input primitive-layout declaration.
Hence, the expression</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">gl_in.length()</code></pre>
</div>
</div>
<div class="paragraph">
<p>will return the value from the table above.</p>
</div>
<div class="paragraph">
<p>For inputs declared without an array size, including intrinsically declared
inputs (i.e., <em>gl_in</em>), a layout must be declared before any use of the
method <strong>length</strong>() or other any array use that requires the array size to be
known.</p>
</div>
<div class="paragraph">
<p>It is a compile-time error if a layout declaration&#8217;s array size (from the
table above) does not match all the explicit array sizes specified in
declarations of an input variables in the same shader.
The following includes examples of compile-time errors:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">// code sequence within one shader...
in vec4 Color1[];     // legal, size still unknown
in vec4 Color2[2];    // legal, size is 2
in vec4 Color3[3];    // illegal, input sizes are inconsistent
layout(lines) in;     // legal for Color2, input size is 2, matching Color2
in vec4 Color4[3];    // illegal, contradicts layout of lines
layout(lines) in;     // legal, matches other layout() declaration
layout(triangles) in; // illegal, does not match earlier layout() declaration</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is a link-time error if not all provided sizes (sized input arrays and
layout size) match across all geometry shaders in a program.</p>
</div>
</div>
<div class="sect3">
<h4 id="fragment-shader-inputs"><a class="anchor" href="#fragment-shader-inputs"></a>Fragment Shader Inputs</h4>
<div class="paragraph">
<p>Additional fragment layout qualifier identifiers include the following for
<em>gl_FragCoord</em> :</p>
</div>
<div class="openblock bnf">
<div class="content">
<div class="dlist">
<dl>
<dt class="hdlist1"><em>layout-qualifier-id</em> : </dt>
<dd>
<p><strong>origin_upper_left</strong><br>
<strong>pixel_center_integer</strong></p>
</dd>
</dl>
</div>
</div>
</div>
<div class="paragraph">
<p>By default, <em>gl_FragCoord</em> in OpenGL assumes a lower-left origin for window
coordinates and assumes pixel centers are located at half-pixel coordinates.
For example, the (<em>x, y</em>) location (0.5, 0.5) is returned for the
lower-left-most pixel in a window.
The origin can be changed by redeclaring <em>gl_FragCoord</em> with the
<strong>origin_upper_left</strong> qualifier, moving the origin of <em>gl_FragCoord</em> to the
upper left of the window, with <em>y</em> increasing in value toward the bottom of
the window.
The values returned can also be shifted by half a pixel in both <em>x</em> and <em>y</em>
by <strong>pixel_center_integer</strong> so it appears the pixels are centered at whole
number pixel offsets.
This moves the (<em>x</em>, <em>y</em>) value returned by <em>gl_FragCoord</em> of (0.5, 0.5) by
default, to (0.0, 0.0) with <strong>pixel_center_integer</strong>.</p>
</div>
<div class="paragraph">
<p>Targeting Vulkan will assume and require an upper-left origin for <em>gl_FragCoord</em>
with pixel centers located at half-pixel coordinates.
This origin can be explicitly set by redeclaring <em>gl_FragCoord</em> with the
<strong>origin_upper_left</strong> identifier.</p>
</div>
<div class="paragraph">
<p>Redeclarations are done as follows</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">in vec4 gl_FragCoord; // redeclaration that changes nothing is allowed

// All the following are allowed redeclaration that change behavior
layout(origin_upper_left) in vec4 gl_FragCoord;
layout(pixel_center_integer) in vec4 gl_FragCoord;
layout(origin_upper_left, pixel_center_integer) in vec4 gl_FragCoord;</code></pre>
</div>
</div>
<div class="paragraph">
<p>If <em>gl_FragCoord</em> is redeclared in any fragment shader in a program, it must
be redeclared in all the fragment shaders in that program that have a static
use <em>gl_FragCoord</em>.
All redeclarations of <em>gl_FragCoord</em> in all fragment shaders in a single
program must have the same set of qualifiers.
Within any shader, the first redeclarations of <em>gl_FragCoord</em> must appear
before any use of <em>gl_FragCoord</em>.
The built-in <em>gl_FragCoord</em> is only predeclared in fragment shaders, so
redeclaring it in any other shader language results in a compile-time error.</p>
</div>
<div class="paragraph">
<p>Redeclaring <em>glFragCoord</em> with <strong>origin_upper_left</strong> and/or
<strong>pixel_center_integer</strong> qualifiers only affects <em>gl_FragCoord.x</em> and
<em>gl_FragCoord.y</em>.
It has no effect on rasterization, transformation, or any other part of the
API pipeline or language features.</p>
</div>
<div class="paragraph">
<p>Fragment shaders allow the following layout qualifier on <strong>in</strong> only (not with
variable declarations):</p>
</div>
<div class="openblock bnf">
<div class="content">
<div class="dlist">
<dl>
<dt class="hdlist1"><em>layout-qualifier-id</em> : </dt>
<dd>
<p><strong>early_fragment_tests</strong></p>
</dd>
</dl>
</div>
</div>
</div>
<div class="paragraph">
<p>to request that fragment tests be performed before fragment shader
execution, as described in section 15.2.4 &#8220;Early Fragment Tests&#8221; of the
<a href="references.html#references" class="xref page">OpenGL Specification</a>.</p>
</div>
<div class="paragraph">
<p>For example,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">layout(early_fragment_tests) in;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Specifying this will make per-fragment tests be performed before fragment
shader execution.
If this is not declared, per-fragment tests will be performed after fragment
shader execution.
Only one fragment shader (compilation unit) need declare this, though more
than one can.
If at least one declares this, then it is enabled.</p>
</div>
</div>
<div class="sect3">
<h4 id="compute-shader-inputs"><a class="anchor" href="#compute-shader-inputs"></a>Compute Shader Inputs</h4>
<div class="paragraph">
<p>There are no layout location qualifiers for compute shader inputs.</p>
</div>
<div class="paragraph">
<p>Layout qualifier identifiers for compute shader inputs are the workgroup
size qualifiers:</p>
</div>
<div class="openblock bnf">
<div class="content">
<div class="dlist">
<dl>
<dt class="hdlist1"><em>layout-qualifier-id</em> : </dt>
<dd>
<p><strong>local_size_x</strong> <strong>=</strong> <em>layout-qualifier-value</em><br>
<strong>local_size_y</strong> <strong>=</strong> <em>layout-qualifier-value</em><br>
<strong>local_size_z</strong> <strong>=</strong> <em>layout-qualifier-value</em></p>
</dd>
</dl>
</div>
</div>
</div>
<div class="paragraph">
<p>The <strong>local_size_x</strong>, <strong>local_size_y</strong>, and <strong>local_size_z</strong> qualifiers are used
to declare a fixed workgroup size by the compute shader in the first,
second, and third dimension, respectively.
If a shader does not specify a size for one of the dimensions, that
dimension will have a size of 1.</p>
</div>
<div class="paragraph">
<p>For example, the following declaration in a compute shader</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">layout(local_size_x = 32, local_size_y = 32) in;</code></pre>
</div>
</div>
<div class="paragraph">
<p>is used to declare a two-dimensional compute shader with a workgroup size of 32
X 32 elements, which is equivalent to a three-dimensional compute shader
where the third dimension has size one.</p>
</div>
<div class="paragraph">
<p>As another example, the declaration</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">layout(local_size_x = 8) in;</code></pre>
</div>
</div>
<div class="paragraph">
<p>effectively specifies that a one-dimensional compute shader is being
compiled, and its size is 8 elements.</p>
</div>
<div class="paragraph">
<p>If the fixed workgroup size of the shader in any dimension is less than
or equal to zero or greater than the maximum size supported by the
implementation for that dimension, a compile-time error results.
Also, if such a layout qualifier is declared more than once in the same
shader, all those declarations must set the same set of workgroup
sizes and set them to the same values; otherwise a compile-time error
results.
If multiple compute shaders attached to a single program object declare a
fixed workgroup size, the declarations must be identical; otherwise a
link-time error results.</p>
</div>
<div class="paragraph">
<p>Furthermore, if a program object contains any compute shaders, at least one
must contain an input layout qualifier specifying a fixed workgroup size
for the program, or a link-time error will occur.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="output-layout-qualifiers"><a class="anchor" href="#output-layout-qualifiers"></a>Output Layout Qualifiers</h3>
<div class="paragraph">
<p>Some output layout qualifiers apply to all shader stages and some apply only
to specific stages.
The latter are discussed in separate sections below.</p>
</div>
<div class="paragraph">
<p>As with input layout qualifiers, all shaders except compute shaders allow
<strong>location</strong> layout qualifiers on output variable declarations, output block
declarations, and output block member declarations.
Of these, variables and block members (but not blocks) additionally allow
the <strong>component</strong> layout qualifier.</p>
</div>
<div class="openblock bnf">
<div class="content">
<div class="dlist">
<dl>
<dt class="hdlist1"><em>layout-qualifier-id</em> : </dt>
<dd>
<p><strong>location</strong> <strong>=</strong> <em>layout-qualifier-value</em><br>
<strong>component</strong> <strong>=</strong> <em>layout-qualifier-value</em></p>
</dd>
</dl>
</div>
</div>
</div>
<div class="paragraph">
<p>The usage and rules for applying the <strong>location</strong> qualifier
and the <strong>component</strong> qualifier
to blocks and structures are exactly as described in
&#8220;<a href="#input-layout-qualifiers">Input Layout Qualifiers</a>&#8221;.
No component aliasing of output variables or members is allowed.</p>
</div>
<div class="paragraph">
<p>Fragment shaders allow an additional <strong>index</strong> output layout qualifier:</p>
</div>
<div class="openblock bnf">
<div class="content">
<div class="dlist">
<dl>
<dt class="hdlist1"><em>layout-qualifier-id</em> : </dt>
<dd>
<p><strong>index</strong> <strong>=</strong> <em>layout-qualifier-value</em></p>
</dd>
</dl>
</div>
</div>
</div>
<div class="paragraph">
<p>Each of these qualifiers may appear at most once.
If <strong>index</strong> is specified, <strong>location</strong> must also be specified.
If <strong>index</strong> is not specified, the value 0 is used.
For example, in a fragment shader,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">layout(location = 3) out vec4 color;</code></pre>
</div>
</div>
<div class="paragraph">
<p>will establish that the fragment shader output <em>color</em> is assigned to
fragment color 3 as the first (index zero) input to the blend equation.
And,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">layout(location = 3, index = 1) out vec4 factor;</code></pre>
</div>
</div>
<div class="paragraph">
<p>will establish that the fragment shader output <em>factor</em> is assigned to
fragment color 3 as the second (index one) input to the blend equation.</p>
</div>
<div class="paragraph">
<p>For fragment shader outputs, the location
and index specify
the color output number
and index
receiving the values of the output.
For outputs of all other shader stages, the location specifies a vector
number that can be used to match against inputs in a subsequent shader
stage, even if that shader is in a different program object.</p>
</div>
<div class="paragraph">
<p>If a declared output is a scalar or vector type other than <strong>dvec3</strong> or
<strong>dvec4</strong>, it will consume a single location.
Outputs of type <strong>dvec3</strong> or <strong>dvec4</strong> will consume two consecutive locations.
Outputs of type <strong>double</strong> and <strong>dvec2</strong> will consume only a single location, in
all stages.</p>
</div>
<div class="paragraph">
<p>If the declared output is an array, it will be assigned consecutive
locations starting with the location specified.
For example,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">layout(location = 2) out vec4 colors[3];</code></pre>
</div>
</div>
<div class="paragraph">
<p>will establish that <em>colors</em> is assigned to vector location numbers 2, 3,
and 4.</p>
</div>
<div class="paragraph">
<p>If the declared output is an <em>n</em> × <em>m</em>
matrix, it will be assigned multiple locations starting with the location
specified.
The number of locations assigned will be the same as for an <em>n</em>-element
array of <em>m</em>-component vectors.</p>
</div>
<div class="paragraph">
<p>If the declared output is a structure, its members will be assigned
consecutive locations in the order of declaration, with the first member
assigned the location specified for the structure.
The number of locations consumed by a structure member is determined by
applying the rules above recursively as though the structure member were
declared as an output variable of the same type.</p>
</div>
<div class="paragraph">
<p><strong>location</strong> layout qualifiers may be used on output variables declared as
structures.
However, it is a compile-time error to use a <strong>location</strong> qualifier on a
structure member.
Location layout qualifiers may be used on output blocks and output block
members.</p>
</div>
<div class="paragraph">
<p>The number of output locations available to a shader is limited.
For fragment shaders, the limit is the advertised number of draw buffers.</p>
</div>
<div class="paragraph">
<p>For all other shaders, the limit is implementation-dependent and must be no
less than one fourth of the advertised maximum output component count
(compute shaders have no outputs).
A program will fail to link if any attached shader uses a location greater
than or equal to the number of supported locations, unless device-dependent
optimizations are able to make the program fit within available hardware
resources.</p>
</div>
<div class="paragraph">
<p>Compile-time errors may also be given if at compile time it is known the
link will fail.
A negative output location will result in a compile-time error.
It is also a compile-time error if a fragment shader sets a layout index to
less than 0 or greater than 1.</p>
</div>
<div class="paragraph">
<p>It is a compile-time or link-time error if any of the following occur:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>any two fragment shader output variables are assigned to the same
location and index.</p>
</li>
<li>
<p>if any two output variables from the same vertex, tessellation or
geometry shader stage are assigned to the same location.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For fragment shader outputs, locations can be assigned using either a
<strong>layout</strong> qualifier or via the OpenGL API.</p>
</div>
<div class="paragraph">
<p>For all shader types, a program will fail to link if explicit location
assignments leave the linker unable to find space for other variables
without explicit assignments.</p>
</div>
<div class="paragraph">
<p>If an output variable with no location or index assigned in the shader text
has a location specified through the OpenGL API, the API-assigned
location will be used.
Otherwise, such variables will be assigned a location by the linker.
All such assignments will have a color index of zero.
See section 15.2 &#8220;Shader Execution&#8221; of the <a href="references.html#references" class="xref page">OpenGL Specification</a> for
more details.
A link-time error will occur if an output variable is declared in multiple
shaders of the same language with conflicting location or index values.</p>
</div>
<div class="paragraph">
<p>For the purposes of determining if a non-fragment output matches an input
from a subsequent shader stage, the <strong>location</strong> layout qualifier (if any)
must match.</p>
</div>
<div class="sect3">
<h4 id="transform-feedback-layout-qualifiers"><a class="anchor" href="#transform-feedback-layout-qualifiers"></a>Transform Feedback Layout Qualifiers</h4>
<div class="paragraph">
<p>The vertex, tessellation, and geometry stages allow shaders to control
transform feedback.
When doing this, shaders will dictate which transform feedback buffers are
in use, which output variables will be written to which buffers, and how
each buffer is laid out.
To accomplish this, shaders allow the following layout qualifier identifiers
on output declarations:</p>
</div>
<div class="openblock bnf">
<div class="content">
<div class="dlist">
<dl>
<dt class="hdlist1"><em>layout-qualifier-id</em> : </dt>
<dd>
<p><strong>xfb_buffer</strong> <strong>=</strong> <em>layout-qualifier-value</em><br>
<strong>xfb_offset</strong> <strong>=</strong> <em>layout-qualifier-value</em><br>
<strong>xfb_stride</strong> <strong>=</strong> <em>layout-qualifier-value</em></p>
</dd>
</dl>
</div>
</div>
</div>
<div class="paragraph">
<p>Any shader making any static use (after preprocessing) of any of these
<strong>xfb_</strong> qualifiers will cause the shader to be in a transform feedback
capturing mode and hence responsible for describing the transform feedback
setup.
This mode will capture any output selected by <strong>xfb_offset</strong>, directly or
indirectly, to a transform feedback buffer.</p>
</div>
<div class="paragraph">
<p>The <strong>xfb_buffer</strong> qualifier specifies which transform feedback buffer will
capture outputs selected with <strong>xfb_offset</strong>.
The <strong>xfb_buffer</strong> qualifier can be applied to the qualifier <strong>out</strong>, to output
variables, to output blocks, and to output block members.
Shaders in the transform feedback capturing mode have an initial global
default of</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">layout(xfb_buffer = 0) out;</code></pre>
</div>
</div>
<div class="paragraph">
<p>This default can be changed by declaring a different buffer with
<strong>xfb_buffer</strong> on the interface qualifier <strong>out</strong>.
This is the only way the global default can be changed.
When a variable or output block is declared without an <strong>xfb_buffer</strong>
qualifier, it inherits the global default buffer.
When a variable or output block is declared with an <strong>xfb_buffer</strong> qualifier,
it has that declared buffer.
All members of a block inherit the block&#8217;s buffer.
A member is allowed to declare an <strong>xfb_buffer</strong>, but it must match the buffer
inherited from its block, or a compile-time error results.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">layout(xfb_buffer=2, xfb_offset=0) out block { // block's buffer is 2
    layout(xfb_buffer = 2) vec4 v; // okay, matches the inherited 2
    layout(xfb_buffer = 3) vec4 u; // ERROR, mismatched buffer
    vec4 w; // inherited
};
layout(xfb_offset=16) out vec4 t;  // initial default is buffer 0
layout(xfb_buffer=1) out;          // new global default of 1
out block {                        // block has buffer 1
    vec4 x;                        // x has buffer 1 (not captured)
    layout(xfb_buffer = 1) vec4 y; // okay (not captured)
    layout(xfb_buffer = 0) vec4 z; // ERROR, mismatched buffer
};
layout(xfb_offset=0) out vec4 g;   // g has buffer 1
layout(xfb_buffer=2) out vec4 h;   // does not change global default
layout(xfb_offset=16) out vec4 j;  // j has buffer 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note this means all members of a block that go to a transform feedback
buffer will go to the same buffer.</p>
</div>
<div class="paragraph">
<p>When a block is declared as an array, all members of block array-element 0
are captured, as previously described, by the declared or inherited
<strong>xfb_buffer</strong>.
Generally, an array of size <em>N</em> of blocks is captured by <em>N</em> consecutive
buffers, with all members of block array-element <em>E</em> captured by buffer <em>B</em>,
where <em>B</em> equals the declared or inherited <strong>xfb_buffer</strong> plus <em>E</em>.</p>
</div>
<div class="paragraph">
<p>It is a compile-time or link-time error to specify an <strong>xfb_buffer</strong>,
including any additional buffers needed to capture an arrays of blocks, that
is less than zero or greater than or equal to the implementation-dependent
constant <em>gl_MaxTransformFeedbackBuffers</em>.</p>
</div>
<div class="paragraph">
<p>The <strong>xfb_offset</strong> qualifier assigns a byte offset within a transform feedback
buffer.
Only variables, block members, or blocks can be qualified with <strong>xfb_offset</strong>.
If a block is qualified with <strong>xfb_offset</strong>, all its members are assigned
transform feedback buffer offsets.
If a block is not qualified with <strong>xfb_offset</strong>, any members of that block not
qualified with an <strong>xfb_offset</strong> will not be assigned transform feedback
buffer offsets.
Only variables and block members that are assigned offsets will be captured
(thus, a proper subset of a block can be captured).
Each time such a variable or block member is written in a shader, the
written value is captured at the assigned offset.
If such a block member or variable is not written during a shader
invocation, the buffer contents at the assigned offset will be undefined.
Even if there are no static writes to a variable or member that is assigned
a transform feedback offset, the space is still allocated in the buffer and
still affects the stride.</p>
</div>
<div class="paragraph">
<p>Variables and block members qualified with <strong>xfb_offset</strong> can be scalars,
vectors, matrices, structures, and (sized) arrays of these.
The offset must be a multiple of the size of the first component of the
first qualified variable or block member, or a compile-time error results.
Further, if applied to an aggregate containing a <strong>double</strong>, the offset must
also be a multiple of 8, and the space taken in the buffer will be a
multiple of 8.
The given offset applies to the first component of the first member of the
qualified entity.
Then, within the qualified entity, subsequent components are each assigned,
in order, to the next available offset aligned to a multiple of that
component&#8217;s size.
Aggregate types are flattened down to the component level to get this
sequence of components.
It is a compile-time error to apply <strong>xfb_offset</strong> to the declaration of an
unsized array.</p>
</div>
<div class="paragraph">
<p>No aliasing in output buffers is allowed: It is a compile-time or link-time
error to specify variables with overlapping transform feedback offsets.</p>
</div>
<div class="paragraph">
<p>The <strong>xfb_stride</strong> qualifier specifies how many bytes are consumed by each
captured vertex.
It applies to the transform feedback buffer for that declaration, whether it
is inherited or explicitly declared.
It can be applied to variables, blocks, block members, or just the qualifier
<strong>out</strong>.
If the buffer is capturing any outputs with double-precision components, the
stride must be a multiple of 8, otherwise it must be a multiple of 4, or a
compile-time or link-time error results.
It is a compile-time or link-time error to have any <strong>xfb_offset</strong> that
overflows <strong>xfb_stride</strong>, whether stated on declarations before or after the
<strong>xfb_stride</strong>, or in different compilation units.
While <strong>xfb_stride</strong> can be declared multiple times for the same buffer, it is
a compile-time or link-time error to have different values specified for the
stride for the same buffer.</p>
</div>
<div class="paragraph">
<p>For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">// buffer 1 has 32-byte stride
layout(xfb_buffer = 1, xfb_stride = 32) out;

// same as previous example; order within layout does not matter
layout(xfb_stride = 32, xfb_buffer = 1) out;

// everything in this block goes to buffer 0
layout(xfb_buffer = 0, xfb_stride = 32) out block1 {
    layout(xfb_offset = 0) vec4 a;  // a goes to byte offset 0 of buffer 0
    layout(xfb_offset = 16) vec4 b; // b goes to offset 16 of buffer 0
};

layout(xfb_buffer = 3, xfb_offset = 12) out block2 {
    vec4 v;  // v will be written to byte offsets 12 through 27 of buffer
    float u; // u will be written to offset 28
    layout(xfb_offset = 40) vec4 w;
    vec4 x;  // x will be written to offset 56, the next available offset
};

layout(xfb_buffer = 2, xfb_stride = 32) out block3 {
    layout(xfb_offset = 12) vec3 c;
    layout(xfb_offset = 24) vec3 d; // ERROR, requires stride of 36
    layout(xfb_offset = 0) vec3 g;  // okay, increasing order not required
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>When no <strong>xfb_stride</strong> is specified for a buffer, the stride of the buffer
will be the smallest needed to hold the variable placed at the highest
offset, including any required padding.
For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">// if there no other declarations for buffer 3, it has stride 32
layout(xfb_buffer = 3) out block4 {
    layout(xfb_offset = 0) vec4 e;
    layout(xfb_offset = 16) vec4 f;
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>The resulting stride (implicit or explicit), when divided by 4, must be less
than or equal to the implementation-dependent constant
<em>gl_MaxTransformFeedbackInterleavedComponents</em>.</p>
</div>
</div>
<div class="sect3">
<h4 id="tessellation-control-outputs"><a class="anchor" href="#tessellation-control-outputs"></a>Tessellation Control Outputs</h4>
<div class="paragraph">
<p>Other than for the transform feedback layout qualifiers, tessellation
control shaders allow output layout qualifiers only on the interface
qualifier <strong>out</strong>, not on an output block, block member, or variable
declaration.
The output layout qualifier identifiers allowed for tessellation control
shaders are:</p>
</div>
<div class="openblock bnf">
<div class="content">
<div class="dlist">
<dl>
<dt class="hdlist1"><em>layout-qualifier-id</em> : </dt>
<dd>
<p><strong>vertices</strong> <strong>=</strong> <em>layout-qualifier-value</em></p>
</dd>
</dl>
</div>
</div>
</div>
<div class="paragraph">
<p>The identifier <strong>vertices</strong> specifies the number of vertices in the output
patch produced by the tessellation control shader, which also specifies the
number of times the tessellation control shader is invoked.
It is a compile- or link-time error for the output vertex count to be less
than or equal to zero, or greater than the implementation-dependent maximum
patch size.</p>
</div>
<div class="paragraph">
<p>The intrinsically declared tessellation control output array <em>gl_out[]</em> will
also be sized by any output layout declaration.
Hence, the expression</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">gl_out.length()</code></pre>
</div>
</div>
<div class="paragraph">
<p>will return the output patch vertex count specified in a previous output
layout qualifier.
For outputs declared without an array size, including intrinsically declared
outputs (i.e., <em>gl_out</em>), a layout must be declared before any use of the
method <strong>length</strong>() or other array use that requires its size to be known.</p>
</div>
<div class="paragraph">
<p>It is a compile-time error if the output patch vertex count specified in an
output layout qualifier does not match the array size specified in any
output variable declaration in the same shader.</p>
</div>
<div class="paragraph">
<p>All tessellation control shader layout declarations in a program must
specify the same output patch vertex count.
There must be at least one layout qualifier specifying an output patch
vertex count in any program containing tessellation control shaders;
however, such a declaration is not required in all tessellation control
shaders.</p>
</div>
</div>
<div class="sect3">
<h4 id="geometry-outputs"><a class="anchor" href="#geometry-outputs"></a>Geometry Outputs</h4>
<div class="paragraph">
<p>Geometry shaders can have three additional types of output layout
identifiers: an output <em>primitive type</em>, a maximum output <em>vertex count</em>,
and per-output <em>stream</em> numbers.
The primitive type and vertex count identifiers are allowed only on the
interface qualifier <strong>out</strong>, not on an output block, block member, or variable
declaration.
The stream identifier is allowed on the interface qualifier <strong>out</strong>, on output
blocks, and on variable declarations.</p>
</div>
<div class="paragraph">
<p>The layout qualifier identifiers for geometry shader outputs are</p>
</div>
<div class="openblock bnf">
<div class="content">
<div class="dlist">
<dl>
<dt class="hdlist1"><em>layout-qualifier-id</em> : </dt>
<dd>
<p><strong>points</strong><br>
<strong>line_strip</strong><br>
<strong>triangle_strip</strong><br>
<strong>max_vertices</strong> <strong>=</strong> <em>layout-qualifier-value</em><br>
<strong>stream</strong> <strong>=</strong> <em>layout-qualifier-value</em></p>
</dd>
</dl>
</div>
</div>
</div>
<div class="paragraph">
<p>The primitive type identifiers <strong>points</strong>, <strong>line_strip</strong>, and <strong>triangle_strip</strong>
are used to specify the type of output primitive produced by the geometry
shader, and only one of these is accepted.
At least one geometry shader (compilation unit) in a program must declare an
output primitive type, and all geometry shader output primitive type
declarations in a program must declare the same primitive type.
It is not required that all geometry shaders in a program declare an output
primitive type.</p>
</div>
<div class="paragraph">
<p>The vertex count identifier <strong>max_vertices</strong> is used to specify the maximum
number of vertices the shader will ever emit in a single invocation.
At least one geometry shader (compilation unit) in a program must declare a
maximum output vertex count, and all geometry shader output vertex count
declarations in a program must declare the same count.
It is not required that all geometry shaders in a program declare a count.</p>
</div>
<div class="paragraph">
<p>In this example,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">layout(triangle_strip, max_vertices = 60) out; // order does not matter
layout(max_vertices = 60) out;  // redeclaration okay
layout(triangle_strip) out;     // redeclaration okay
layout(points) out;             // error, contradicts triangle_strip
layout(max_vertices = 30) out;  // error, contradicts 60</code></pre>
</div>
</div>
<div class="paragraph">
<p>all outputs from the geometry shader are triangles and at most 60 vertices
will be emitted by the shader.
It is an error for the maximum number of vertices to be greater than
<em>gl_MaxGeometryOutputVertices</em>.</p>
</div>
<div class="paragraph">
<p>The identifier <strong>stream</strong> is used to specify that a geometry shader output
variable or block is associated with a particular vertex stream (numbered
beginning with zero).
A default stream number may be declared at global scope by qualifying
interface qualifier <strong>out</strong> as in this example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">layout(stream = 1) out;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The stream number specified in such a declaration replaces any previous
default and applies to all subsequent block and variable declarations until
a new default is established.
The initial default stream number is zero.</p>
</div>
<div class="paragraph">
<p>Each output block or non-block output variable is associated with a vertex
stream.
If the block or variable is declared with the stream identifier, it is
associated with the specified stream; otherwise, it is associated with the
current default stream.
A block member may be declared with a stream identifier, but the specified
stream must match the stream associated with the containing block.
One example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">layout(stream=1) out;           // default is now stream 1
out vec4 var1;                  // var1 gets default stream (1)
layout(stream=2) out Block1 {   // "Block1" belongs to stream 2
    layout(stream=2) vec4 var2; // redundant block member stream decl
    layout(stream=3) vec2 var3; // ILLEGAL (must match block stream)
    vec3 var4;                  // belongs to stream 2
};
layout(stream=0) out;           // default is now stream 0
out vec4 var5;                  // var5 gets default stream (0)
out Block2 {                    // "Block2" gets default stream (0)
    vec4 var6;
};
layout(stream=3) out vec4 var7; // var7 belongs to stream 3</code></pre>
</div>
</div>
<div class="paragraph">
<p>Each vertex emitted by the geometry shader is assigned to a specific stream,
and the attributes of the emitted vertex are taken from the set of output
blocks and variables assigned to the targeted stream.
After each vertex is emitted, the values of all output variables become
undefined.
Additionally, the output variables associated with each vertex stream may
share storage.
Writing to an output variable associated with one stream may overwrite
output variables associated with any other stream.
When emitting each vertex, a geometry shader should write to all outputs
associated with the stream to which the vertex will be emitted and to no
outputs associated with any other stream.</p>
</div>
<div class="paragraph">
<p>If a geometry shader output block or variable is declared more than once,
all such declarations must associate the variable with the same vertex
stream.
If any stream declaration specifies a non-existent stream number, the shader
will fail to compile.</p>
</div>
<div class="paragraph">
<p>Built-in geometry shader outputs are always associated with vertex stream
zero.</p>
</div>
<div class="paragraph">
<p>All geometry shader output layout declarations in a program must declare the
same layout and same value for <strong>max_vertices</strong>.
If geometry shaders are in a program, there must be at least one geometry
output layout declaration somewhere in that
program, but not all geometry
shaders (compilation units) are required to declare it.</p>
</div>
</div>
<div class="sect3">
<h4 id="fragment-outputs"><a class="anchor" href="#fragment-outputs"></a>Fragment Outputs</h4>
<div class="paragraph">
<p>The built-in fragment shader variable <em>gl_FragDepth</em> may be redeclared using
one of the following layout qualifiers.</p>
</div>
<div class="openblock bnf">
<div class="content">
<div class="dlist">
<dl>
<dt class="hdlist1"><em>layout-qualifier-id</em> : </dt>
<dd>
<p><strong>depth_any</strong><br>
<strong>depth_greater</strong><br>
<strong>depth_less</strong><br>
<strong>depth_unchanged</strong></p>
</dd>
</dl>
</div>
</div>
</div>
<div class="paragraph">
<p>The layout qualifier for <em>gl_FragDepth</em> constrains intentions of the final
value of <em>gl_FragDepth</em> written by any shader invocation.
GL implementations are allowed to perform optimizations assuming that the
depth test fails (or passes) for a given fragment if all values of
<em>gl_FragDepth</em> consistent with the layout qualifier would fail (or pass).
This potentially includes skipping shader execution if the fragment is
discarded because it is occluded and the shader has no side effects.
If the final value of <em>gl_FragDepth</em> is inconsistent with its layout
qualifier, the result of the depth test for the corresponding fragment is
undefined.
However, no error will be generated in this case.
If the depth test passes and depth writes are enabled, the value written to
the depth buffer is always the value of <em>gl_FragDepth</em>, whether or not it is
consistent with the layout qualifier.</p>
</div>
<div class="paragraph">
<p>By default, <em>gl_FragDepth</em> is qualified as <em>depth_any</em>.
When the layout qualifier for <em>gl_FragDepth</em> is <em>depth_any</em>, the shader
compiler will note any assignment to <em>gl_FragDepth</em> modifying it in an
unknown way, and depth testing will always be performed after the shader has
executed.
When the layout qualifier is <em>depth_greater</em>, the GL can assume that the
final value of <em>gl_FragDepth</em> is greater than or equal to the fragment&#8217;s
interpolated depth value, as given by the <em>z</em> component of <em>gl_FragCoord</em>.
When the layout qualifier is <em>depth_less</em>, the GL can assume that any
modification of <em>gl_FragDepth</em> will only decrease its value.
When the layout qualifier is <em>depth_unchanged</em>, the shader compiler will
honor any modification to <em>gl_FragDepth</em>, but the rest of the GL can assume
that <em>gl_FragDepth</em> is not assigned a new value.</p>
</div>
<div class="paragraph">
<p>Redeclarations of <em>gl_FragDepth</em> are performed as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">// redeclaration that changes nothing is allowed
out float gl_FragDepth;

// assume it may be modified in any way
layout(depth_any) out float gl_FragDepth;

// assume it may be modified such that its value will only increase
layout(depth_greater) out float gl_FragDepth;

// assume it may be modified such that its value will only decrease
layout(depth_less) out float gl_FragDepth;

// assume it will not be modified
layout(depth_unchanged) out float gl_FragDepth;</code></pre>
</div>
</div>
<div class="paragraph">
<p>If <em>gl_FragDepth</em> is redeclared in any fragment shader in a program, it must
be redeclared in all fragment shaders in that program that have static
assignments to <em>gl_FragDepth</em>.
All redeclarations of <em>gl_FragDepth</em> in all fragment shaders in a single
program must have the same set of qualifiers.
Within any shader, the first redeclarations of <em>gl_FragDepth</em> must appear
before any use of <em>gl_FragDepth</em>.
The built-in <em>gl_FragDepth</em> is only predeclared in fragment shaders, so
redeclaring it in any other shader language results in a compile-time error.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="uniform-variable-layout-qualifiers"><a class="anchor" href="#uniform-variable-layout-qualifiers"></a>Uniform Variable Layout Qualifiers</h3>
<div class="paragraph">
<p>Layout qualifiers can be used for uniform variables and subroutine uniforms.
The layout qualifier identifiers for uniform variables and subroutine
uniforms are:</p>
</div>
<div class="openblock bnf">
<div class="content">
<div class="dlist">
<dl>
<dt class="hdlist1"><em>layout-qualifier-id</em> : </dt>
<dd>
<p><strong>location</strong> <strong>=</strong> <em>layout-qualifier-value</em></p>
</dd>
</dl>
</div>
</div>
</div>
<div class="paragraph">
<p>The location identifier can be used with default-block uniform variables and
subroutine uniforms.
The location specifies the location by which the API can reference
the uniform and update its value.
Individual elements of a uniform array are assigned consecutive locations
with the first element taking location <strong>location</strong>.
Default-block uniform variable declarations sharing the same location
linked in the program have to match by name, type, qualifiers and arrayness.
For arrays their array dimensionality and array sizes must match.
For structs this rule applies recursively to all members.
No two subroutine uniform variables can have the same location in the same
shader stage, otherwise a compile-time or link-time error will be generated.
Valid locations for default-block uniform variable locations are in the
range of 0 to the implementation-defined maximum number of uniform locations
minus one.
Valid locations for subroutine uniforms are in the range of 0 to the
implementation-defined per-stage maximum number of subroutine uniform
locations minus one.</p>
</div>
<div class="paragraph">
<p>Locations can be assigned to default-block uniform arrays and structures.
The first inner-most scalar, vector or matrix member or element takes the
specified <strong>location</strong> and the compiler assigns the next inner-most member or
element the next incremental location value.
Each subsequent inner-most member or element gets incremental locations for
the entire structure or array.
This rule applies to nested structures and arrays and gives each inner-most
scalar, vector, or matrix member a unique location.
For arrays without an explicit size, the size is calculated based on its
static usage.
When the linker generates locations for uniforms without an explicit
location, it assumes for all uniforms with an explicit location all their
array elements and structure members are used and the linker will not
generate a conflicting location, even if that element or member is deemed
unused.</p>
</div>
<div class="paragraph">
<p>When generating SPIR-V for API&#8217;s that accept individual (default block)
non-opaque uniform variables, it is a compile-time error to not
include a location when declaring them.</p>
</div>
<div class="paragraph">
<p>When targeting Vulkan, the <strong>push_constant</strong> qualifier is used to
declare an entire block, and represents a set of <em>push constants</em>, as defined
by the Vulkan API.
It is a compile-time error to apply this to anything other than a uniform block
declaration, or when not targeting Vulkan.
The values in the block will be initialized as per the Vulkan API specification.
A block declared with <code>layout(push_constant)</code> may optionally include an
<em>instance-name</em>.
There can be only one <strong>push_constant</strong> block per stage, or a compile-time or
link-time error will result.
A push-constant array can only be indexed with dynamically uniform indices.
Uniform blocks declared with <strong>push_constant</strong> use different resources
than those without; and are accounted for separately.</p>
</div>
</div>
<div class="sect2">
<h3 id="subroutine-function-layout-qualifiers"><a class="anchor" href="#subroutine-function-layout-qualifiers"></a>Subroutine Function Layout Qualifiers</h3>
<div class="paragraph">
<p>Layout qualifiers can be used for subroutine functions.
The layout qualifier identifiers for subroutine functions are:</p>
</div>
<div class="openblock bnf">
<div class="content">
<div class="dlist">
<dl>
<dt class="hdlist1"><em>layout-qualifier-id</em> : </dt>
<dd>
<p><strong>index</strong> <strong>=</strong> <em>layout-qualifier-value</em></p>
</dd>
</dl>
</div>
</div>
</div>
<div class="paragraph">
<p>Each subroutine with an index qualifier in the shader must be given a unique
index, otherwise a compile- or link-time error will be generated.
The indices must be in the range of 0 to the implementation defined maximum
number of subroutines minus one.
It is recommended, but not required, that the shader assigns a range of
tightly packed <em>index</em> values starting from zero so that the OpenGL
subroutine function enumeration API returns a non-empty name for all active
indices.</p>
</div>
</div>
<div class="sect2">
<h3 id="uniform-and-shader-storage-block-layout-qualifiers"><a class="anchor" href="#uniform-and-shader-storage-block-layout-qualifiers"></a>Uniform and Shader Storage Block Layout Qualifiers</h3>
<div class="paragraph">
<p>Layout qualifiers can be used for uniform and shader storage blocks, but not
for non-block uniform declarations.
The layout qualifier identifiers (and <strong>shared</strong> keyword) for uniform and
shader storage blocks are:</p>
</div>
<div class="openblock bnf">
<div class="content">
<div class="dlist">
<dl>
<dt class="hdlist1"><em>layout-qualifier-id</em> : </dt>
<dd>
<p><strong>shared</strong><br>
<strong>packed</strong><br>
<strong>std140</strong><br>
<strong>std430</strong><br>
<strong>row_major</strong><br>
<strong>column_major</strong><br>
<strong>binding</strong> <strong>=</strong> <em>layout-qualifier-value</em><br>
<strong>offset</strong> <strong>=</strong> <em>layout-qualifier-value</em><br>
<strong>align</strong> <strong>=</strong> <em>layout-qualifier-value</em></p>
</dd>
</dl>
</div>
</div>
</div>
<div class="paragraph">
<p>None of these have any semantic effect at all on the usage of the variables
being declared; they only describe how data is laid out in memory.
For example, matrix semantics are always column-based, as described in the
rest of this specification, no matter what layout qualifiers are being used.</p>
</div>
<div class="paragraph">
<p>Uniform and shader storage block layout qualifiers can be declared for
global scope, on a single uniform or shader storage block, or on a single
block member declaration.</p>
</div>
<div class="paragraph">
<p>Default layouts are established at global scope for uniform blocks as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">layout(layout-qualifier-id-list) uniform;</code></pre>
</div>
</div>
<div class="paragraph">
<p>and for shader storage blocks as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">layout(layout-qualifier-id-list) buffer;</code></pre>
</div>
</div>
<div class="paragraph">
<p>When this is done, the previous default qualification is first inherited and
then overridden as per the override rules listed below for each qualifier
listed in the declaration.
The result becomes the new default qualification scoped to subsequent
uniform or shader storage block definitions.</p>
</div>
<div class="paragraph">
<p>The initial state of compilation when generating SPIR-V is as if the
following were declared:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">layout(std140, column_major) uniform;
layout(std430, column_major) buffer;</code></pre>
</div>
</div>
<div class="paragraph">
<p>However, when <strong>push_constant</strong> is declared, the default layout of the
buffer will be <strong>std430</strong>. There is no method to globally set this default.</p>
</div>
<div class="paragraph">
<p>The initial state of compilation when not generating SPIR-V is as if the
following were declared:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">layout(shared, column_major) uniform;
layout(shared, column_major) buffer;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Uniform and shader storage blocks can be declared with optional layout
qualifiers, and so can their individual member declarations.
Such block layout qualification is scoped only to the content of the block.
As with global layout declarations, block layout qualification first
inherits from the current default qualification and then overrides it.
Similarly, individual member layout qualification is scoped just to the
member declaration, and inherits from and overrides the block&#8217;s
qualification.</p>
</div>
<div class="paragraph">
<p>The <strong>shared</strong> qualifier overrides only the <strong>std140</strong>, <strong>std430</strong>, and <strong>packed</strong>
qualifiers; other qualifiers are inherited.
The compiler/linker will ensure that multiple programs and programmable
stages containing this definition will share the same memory layout for this
block, as long as all arrays are declared with explicit sizes and all
matrices have matching <strong>row_major</strong> and/or <strong>column_major</strong> qualifications
(which may come from a declaration outside the block definition).
This allows use of the same buffer to back the same block definition across
different programs.
It is a compile-time error to use the <strong>shared</strong> qualifier when generating
SPIR-V.</p>
</div>
<div class="paragraph">
<p>The <strong>packed</strong> qualifier overrides only <strong>std140</strong>, <strong>std430</strong>, and <strong>shared</strong>;
other qualifiers are inherited.
When <strong>packed</strong> is used, no shareable layout is guaranteed.
The compiler and linker can optimize memory use based on what variables
actively get used and on other criteria.
Offsets must be queried, as there is no other way of guaranteeing where (and
which) variables reside within the block.</p>
</div>
<div class="paragraph">
<p>It is a link-time error to access the same packed uniform or shader storage
block in multiple stages within a program.
Attempts to access the same packed uniform or shader storage block across
programs can result in conflicting member offsets and in undefined values
being read.
However, implementations may aid application management of packed blocks by
using canonical layouts for packed blocks.
It is a compile-time error to use the <strong>packed</strong> qualifier when generating
SPIR-V.</p>
</div>
<div class="paragraph">
<p>The <strong>std140</strong> and <strong>std430</strong> qualifiers override only the <strong>packed</strong>, <strong>shared</strong>,
<strong>std140</strong>, and <strong>std430</strong> qualifiers; other qualifiers are inherited.
The <strong>std430</strong> qualifier is supported only for shader storage blocks; a shader
using the <strong>std430</strong> qualifier on a uniform block will result in
a compile-time error, unless it is also declared with <strong>push_constant</strong>.</p>
</div>
<div class="paragraph">
<p>The layout is explicitly determined by this, as described in section 7.6.2.2
&#8220;Standard Uniform Block Layout&#8221; of the <a href="references.html#references" class="xref page">OpenGL Specification</a>.
Hence, as in <strong>shared</strong> above, the resulting layout is shareable across
programs.</p>
</div>
<div class="paragraph">
<p>Layout qualifiers on member declarations cannot use the <strong>shared</strong>, <strong>packed</strong>,
<strong>std140</strong>, or <strong>std430</strong> qualifiers.
These can only be used at global scope (without an object) or on a block
declaration, or a compile-time error results.</p>
</div>
<div class="paragraph">
<p>The <strong>row_major</strong> and <strong>column_major</strong> qualifiers only affect the layout of
matrices, including all matrices contained in structures and arrays they are
applied to, to all depths of nesting.
These qualifiers can be applied to other types, but will have no effect.</p>
</div>
<div class="paragraph">
<p>The <strong>row_major</strong> qualifier overrides only the <strong>column_major</strong> qualifier; other
qualifiers are inherited.
Elements within a matrix row will be contiguous in memory.</p>
</div>
<div class="paragraph">
<p>The <strong>column_major</strong> qualifier overrides only the <strong>row_major</strong> qualifier; other
qualifiers are inherited.
Elements within a matrix column will be contiguous in memory.</p>
</div>
<div class="paragraph">
<p>The <strong>binding</strong> qualifier specifies the uniform buffer binding point
corresponding to the uniform or shader storage block, which will be used to
obtain the values of the member variables of the block.
It is a compile-time error to specify the <strong>binding</strong> qualifier for the global
scope or for block member declarations.
Any uniform or shader storage block declared without a <strong>binding</strong> qualifier
is initially assigned to block binding point zero.
After a program is linked, the binding points used for uniform
and shader storage blocks
declared with or without a <strong>binding</strong> qualifier can be updated
by the API.</p>
</div>
<div class="paragraph">
<p>When used with OpenGL,
if the <strong>binding</strong> qualifier is used with a uniform block or shader storage
block instanced as an array, the first element of the array takes the
specified block binding and each subsequent element takes the next
consecutive binding point.
For an array of arrays, each element (e.g. 6 elements for a[2][3]) gets a
binding point, and they are ordered per the array of array ordering
described in &#8220;<a href="#arrays">Arrays.</a>&#8221;</p>
</div>
<div class="paragraph">
<p>When targeting Vulkan,
if the <strong>binding</strong> qualifier is used with a uniform block or buffer block
instanced as an array, the entire array takes only the provided binding
number.
The next consecutive binding number is available for a different
object.
For an array of arrays, descriptor set array element numbers used
in descriptor set accesses are ordered per the array-of-array ordering
described in &#8220;<a href="#arrays">Arrays.</a>&#8221;</p>
</div>
<div class="paragraph">
<p>If the binding point for any uniform or shader storage block instance is
less than zero, or greater than or equal to the corresponding
implementation-dependent maximum number of buffer bindings, a compile-time
error will occur.
When the <strong>binding</strong> qualifier is used with a uniform or shader storage block
instanced as an array of size <em>N</em>, all elements of the array from <strong>binding</strong>
through <em>binding + N - 1</em> must be within this range.
It is a compile-time or link-time error to use the same binding number for
more than one uniform block or for more than one buffer block.</p>
</div>
<div class="paragraph">
<p>The <strong>set</strong> qualifier is only available when targeting Vulkan.
It specifies the descriptor set this object belongs to.
It is a compile-time error to apply <strong>set</strong> to a standalone qualifier, to
a member of a block, or when not targeting an API that supports descriptor sets.
It is a compile-time error to apply <strong>set</strong> to a block qualified as <strong>push_constant</strong>.
By default, any non-push-constant uniform or shader storage block declared
without a <strong>set</strong> identifier is assigned to descriptor set 0.
Similarly, any sampler, texture, or subpass-input type declared as a uniform
without a <strong>set</strong> identifier is also assigned to descriptor set 0.</p>
</div>
<div class="paragraph">
<p>If applied to an object declared as an array, all elements of the array
belong to the specified <strong>set</strong>.</p>
</div>
<div class="paragraph">
<p>When generating SPIR-V, it is a compile-time error for either the <strong>set</strong> or
<strong>binding</strong> value to exceed a front-end-configuration supplied maximum value.</p>
</div>
<div class="paragraph">
<p>When multiple arguments are listed in a <strong>layout</strong> declaration, the effect
will be the same as if they were declared one at a time, in order from left
to right, each in turn inheriting from and overriding the result from the
previous qualification.</p>
</div>
<div class="paragraph">
<p>For example</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">layout(row_major, column_major)</code></pre>
</div>
</div>
<div class="paragraph">
<p>results in the qualification being <strong>column_major</strong>.
Other examples:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">layout(shared, row_major) uniform; // default is now shared and row_major

layout(std140) uniform Transform { // layout of this block is std140
    mat4 M1;                       // row major
    layout(column_major) mat4 M2;  // column major
    mat3 N1;                       // row major
};

uniform T2 {                       // layout of this block is shared
    ...
};

layout(column_major) uniform T3 {  // shared and column major
    mat4 M3;                       // column major
    layout(row_major) mat4 m4;     // row major
    mat3 N2;                       // column major
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>When targeting Vulkan, the <strong>offset</strong> and <strong>align</strong> qualifiers for blocks and
block members can only be used with <strong>uniform</strong> and <strong>buffer</strong> blocks.
When not targeting Vulkan, they can only be used with blocks declared with
<strong>std140</strong> or <strong>std430</strong> layouts.</p>
</div>
<div class="paragraph">
<p>The <strong>offset</strong> qualifier can only be used on block members.
The <strong>offset</strong> qualifier forces the qualified member to start at or after the
specified <em>layout-qualifier-value</em>, which will be its byte offset from
the beginning of the buffer.
It is a compile-time error to have any offset, explicit or assigned, that
lies within another member of the block.
When not generating SPIR-V, it is a compile-time error to specify an offset
that is smaller than the offset of the previous member in the block.
Two blocks linked together in the same program with the same block name must
have the exact same set of members qualified with <strong>offset</strong> and their
<em>layout-qualifier-value</em> values must be the same, or a link-time error
results.
The specified offset must be a multiple of the base alignment of the type of
the block member it qualifies, or a compile-time error results.</p>
</div>
<div class="paragraph">
<p>The <strong>align</strong> qualifier makes the start of each block member have a minimum
byte alignment.
It does not affect the internal layout within each member, which will still
follow the <strong>std140</strong> or <strong>std430</strong> rules.
The specified alignment must be greater than 0 and a power of 2, or a
compile-time error results.</p>
</div>
<div class="paragraph">
<p>The <em>actual alignment</em> of a member will be the greater of the specified
<strong>align</strong> alignment and the standard (e.g. <strong>std140</strong>) base alignment for the
member&#8217;s type.
The <em>actual offset</em> of a member is computed as follows: If <strong>offset</strong> was
declared, start with that offset, otherwise start with the offset immediately
following the preceding member (in declaration order).
If the resulting offset is not a multiple of the <em>actual alignment</em>,
increase it to the first offset that is a multiple of the <em>actual
alignment</em>.
This results in the <em>actual offset</em> the member will have.</p>
</div>
<div class="paragraph">
<p>When <strong>align</strong> is applied to an array, it affects only the start of the array,
not the array&#8217;s internal stride.
Both an <strong>offset</strong> and an <strong>align</strong> qualifier can be specified on a declaration.</p>
</div>
<div class="paragraph">
<p>The <strong>align</strong> qualifier, when used on a block, has the same effect as
qualifying each member with the same <strong>align</strong> value as declared on the block,
and gets the same compile-time results and errors as if this had been done.
As described in general earlier, an individual member can specify its own
<strong>align</strong>, which overrides the block-level <strong>align</strong>, but just for that member.</p>
</div>
<div class="paragraph">
<p>Examples:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">layout(std140) uniform block {
 vec4 a;                         // a takes offsets 0-15
 layout(offset = 32) vec3 b;     // b takes offsets 32-43
 layout(offset = 40) vec2 c;     // ERROR, lies within previous member
 layout(offset = 48) vec2 d;     // d takes offsets 48-55
 layout(align = 16) float e;     // e takes offsets 64-67
 layout(align = 2) double f;     // f takes offsets 72-79
 layout(align = 6) double g;     // ERROR, 6 is not a power of 2
 layout(offset = 80) float h;    // h takes offsets 80-83
 layout(align = 64) dvec3 i;     // i takes offsets 128-151
 layout(offset = 164, align = 8)
 float j;                        // j takes offsets 168-171
};</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="opaque-uniform-layout-qualifiers"><a class="anchor" href="#opaque-uniform-layout-qualifiers"></a>Opaque Uniform Layout Qualifiers</h3>
<div class="paragraph">
<p>Opaque uniform variables can take the uniform layout qualifier for binding:</p>
</div>
<div class="openblock bnf">
<div class="content">
<div class="dlist">
<dl>
<dt class="hdlist1"><em>layout-qualifier-id</em> : </dt>
<dd>
<p><strong>binding</strong> <strong>=</strong> <em>layout-qualifier-value</em></p>
</dd>
</dl>
</div>
</div>
</div>
<div class="paragraph">
<p>The <strong>binding</strong> qualifier specifies the point where the variable will be bound.
Any opaque variable declared without a binding qualifier has a default binding
of zero.</p>
</div>
<div class="paragraph">
<p>When used with OpenGL,
if the <strong>binding</strong> qualifier is used with an array, the first element of the
array takes the specified binding point and each subsequent element takes the
next consecutive binding point.
For an array of arrays, each element (e.g. 6 elements for a[2][3]) gets a
binding point, and they are ordered per the array of array ordering
described in &#8220;<a href="#arrays">Arrays.</a>&#8221;</p>
</div>
<div class="paragraph">
<p>When targeting Vulkan,
if the <strong>binding</strong> qualifier is used with an array, the entire array
takes only the provided binding number. The next consecutive binding
number is available for a different object.</p>
</div>
<div class="paragraph">
<p>If the <strong>binding</strong> is less than zero, or greater than or equal to the
implementation-dependent maximum supported number of binding points,
a compile-time error will occur.
When the <strong>binding</strong> qualifier is used with an array of size <em>N</em>, all elements
of the array from <strong>binding</strong> through <em>binding + N - 1</em> must be within this
range.
It is a compile-time or link-time error to use the same <strong>binding</strong> number for
more than one atomic counter, unless the <em>offset</em> for the atomic counters
sharing the same binding are all different.</p>
</div>
<div class="paragraph">
<p>A link-time error will result if two shaders in a program specify different
<em>layout-qualifier-value</em> bindings for the same opaque-uniform name.
However, it is not an error to specify a binding on some but not all
declarations for the same name, as shown in the examples below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">// in one shader...
layout(binding=3) uniform sampler2D s; // s bound to point 3

// in another shader...
uniform sampler2D s;                   // okay, s still bound at 3

// in another shader...
layout(binding=4) uniform sampler2D s; // ERROR: contradictory bindings</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="atomic-counter-layout-qualifiers"><a class="anchor" href="#atomic-counter-layout-qualifiers"></a>Atomic Counter Layout Qualifiers</h3>
<div class="paragraph">
<p>Atomic counters are not available when targeting Vulkan.</p>
</div>
<div class="paragraph">
<p>Atomic counter layout qualifiers can be used on atomic counter declarations or
at global scope to establish defaults.
The atomic counter qualifiers are:</p>
</div>
<div class="openblock bnf">
<div class="content">
<div class="dlist">
<dl>
<dt class="hdlist1"><em>layout-qualifier-id</em> : </dt>
<dd>
<p><strong>binding</strong> <strong>=</strong> <em>layout-qualifier-value</em><br>
<strong>offset</strong> <strong>=</strong> <em>layout-qualifier-value</em></p>
</dd>
</dl>
</div>
</div>
</div>
<div class="paragraph">
<p>Each binding has a default offset that is initially 0 and is updated following
each declaration containing the type <strong>atomic_uint</strong>. If such a declaration does
not declare a variable then it establishes a default for the named binding. It
is a compile-time error if any such declaration does not include a <em>binding</em>
layout qualifier.</p>
</div>
<div class="paragraph">
<p>If a declaration contains an <em>offset</em> qualifier then that offset is used in the
declaration, otherwise the default offset for the named binding is used. Each
atomic counter that is declared is assigned to the named buffer binding point,
at the current offset, and then the offset is increased by 4. Arrays of atomic
counters assign one such offset to each member, and if multiple variables are
declared in the same statement then they will have offsets assigned in order
from left to right. Having assigned offsets to variables, if any, the
binding&#8217;s default offset will be set to the current offset value.</p>
</div>
<div class="paragraph">
<p>For example,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">layout(binding = 2, offset = 4) uniform atomic_uint a;</code></pre>
</div>
</div>
<div class="paragraph">
<p>will establish that the opaque handle to the atomic counter <em>a</em> will be
bound to atomic counter buffer binding point 2 at an offset of 4 basic
machine units into that buffer.
The default <em>offset</em> for binding point 2 will be post incremented by 4 (the
size of an atomic counter).</p>
</div>
<div class="paragraph">
<p>It is a compile-time error to bind an atomic counter with a binding value
greater than or equal to <em>gl_MaxAtomicCounterBindings</em>.
It is a compile-time error to declare an atomic counter whose offset is such
that the buffer containing it would be larger than <em>gl_MaxAtomicCounterBufferSize</em>.
It is a compile-time error to declare an atomic counter whose offset is not
aligned to a multiple of 4.
It is a compile-time error to declare an unsized array of <strong>atomic_uint</strong>.
It is a compile- or link-time error to declare two atomic counters with the same
binding and the same offset.</p>
</div>
<div class="paragraph">
<p>Examples of atomic declarations:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">layout(binding = 2, offset = 4)  uniform atomic_uint;      // Sets binding's default
                                                           // offset = 4
layout(binding = 2)              uniform atomic_uint a;    // offset 4
layout(binding = 2)              uniform atomic_uint b;    // offset 8
layout(binding = 3)              uniform atomic_uint c[2]; // offsets 0, 4
layout(binding = 2)              uniform atomic_uint d;    // offset 12
layout(binding = 4, offset = 16) uniform atomic_uint e;    // offset 16
layout(binding = 4)              uniform atomic_uint f;    // offset 20

layout(offset = 8)              uniform atomic_uint ea;  // error, no binding
                                                         // specified
layout(binding = 2, offset = 6) uniform atomic_uint eb;  // error, offset not aligned
layout(binding = 3, offset = 4) uniform atomic_uint ec;  // error, overlaps c[1]
layout(binding = 3, offset = 4) uniform atomic_uint;     // OK, no counter declared
layout(binding = 3)             uniform atomic_uint ed;  // error, overlaps c[1]</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="format-layout-qualifiers"><a class="anchor" href="#format-layout-qualifiers"></a>Format Layout Qualifiers</h3>
<div class="paragraph">
<p>Format layout qualifiers can be used on image variable declarations (those
declared with a basic type having &#8220;<strong>image</strong>&#8221; in its keyword).
The format layout qualifier identifiers for image variable declarations are:</p>
</div>
<div class="openblock bnf">
<div class="content">
<div class="dlist">
<dl>
<dt class="hdlist1"><em>layout-qualifier-id</em> : </dt>
<dd>
<p><em>float-image-format-qualifier</em><br>
<em>int-image-format-qualifier</em><br>
<em>uint-image-format-qualifier</em><br>
<strong>binding</strong> <strong>=</strong> <em>layout-qualifier-value</em></p>
</dd>
</dl>
</div>
</div>
</div>
<div class="openblock bnf">
<div class="content">
<div class="dlist">
<dl>
<dt class="hdlist1"><em>float-image-format-qualifier</em> : </dt>
<dd>
<p><strong>rgba32f</strong><br>
<strong>rgba16f</strong><br>
<strong>rg32f</strong><br>
<strong>rg16f</strong><br>
<strong>r11f_g11f_b10f</strong><br>
<strong>r32f</strong><br>
<strong>r16f</strong><br>
<strong>rgba16</strong><br>
<strong>rgb10_a2</strong><br>
<strong>rgba8</strong><br>
<strong>rg16</strong><br>
<strong>rg8</strong><br>
<strong>r16</strong><br>
<strong>r8</strong><br>
<strong>rgba16_snorm</strong><br>
<strong>rgba8_snorm</strong><br>
<strong>rg16_snorm</strong><br>
<strong>rg8_snorm</strong><br>
<strong>r16_snorm</strong><br>
<strong>r8_snorm</strong></p>
</dd>
<dt class="hdlist1"><em>int-image-format-qualifier</em> : </dt>
<dd>
<p><strong>rgba32i</strong><br>
<strong>rgba16i</strong><br>
<strong>rgba8i</strong><br>
<strong>rg32i</strong><br>
<strong>rg16i</strong><br>
<strong>rg8i</strong><br>
<strong>r32i</strong><br>
<strong>r16i</strong><br>
<strong>r8i</strong></p>
</dd>
<dt class="hdlist1"><em>uint-image-format-qualifier</em> : </dt>
<dd>
<p><strong>rgba32ui</strong><br>
<strong>rgba16ui</strong><br>
<strong>rgb10_a2ui</strong><br>
<strong>rgba8ui</strong><br>
<strong>rg32ui</strong><br>
<strong>rg16ui</strong><br>
<strong>rg8ui</strong><br>
<strong>r32ui</strong><br>
<strong>r16ui</strong><br>
<strong>r8ui</strong></p>
</dd>
</dl>
</div>
</div>
</div>
<div class="paragraph">
<p>A format layout qualifier specifies the image format associated with a
declared image variable.
Only one format qualifier may be specified for any image variable
declaration.
For image variables with floating-point component types (keywords starting
with &#8220;<strong>image</strong>&#8221;), signed integer component types (keywords starting with
&#8220;<strong>iimage</strong>&#8221;), or unsigned integer component types (keywords starting with
&#8220;<strong>uimage</strong>&#8221;), the format qualifier used must match the
<em>float-image-format-qualifier</em>, <em>int-image-format-qualifier</em>, or
<em>uint-image-format-qualifier</em> grammar rules, respectively.
It is a compile-time error to declare an image variable where the format
qualifier does not match the image variable type.</p>
</div>
<div class="paragraph">
<p>Any image variable used for image loads or atomic operations must specify a
format layout qualifier; it is a compile-time error to pass an image uniform
variable or function parameter declared without a format layout qualifier to
an image load or atomic function.</p>
</div>
<div class="paragraph">
<p>Uniforms not qualified with <strong>writeonly</strong> must have a format layout qualifier.
Note that an image variable passed to a function for read access cannot be
declared as <strong>writeonly</strong> and hence must have been declared with a format
layout qualifier.</p>
</div>
<div class="paragraph">
<p>The <strong>binding</strong> qualifier was described in
&#8220;<a href="#opaque-uniform-layout-qualifiers">Opaque Uniform Layout Qualifiers</a>&#8221;.</p>
</div>
</div>
<div class="sect2">
<h3 id="_subpass_input_qualifier"><a class="anchor" href="#_subpass_input_qualifier"></a>Subpass Input Qualifier</h3>
<div class="paragraph">
<p>Subpass inputs are only available when targeting Vulkan.</p>
</div>
<div class="paragraph">
<p>Subpass inputs are declared with the basic <strong>subpassInput</strong> types.
They must be declared with the layout qualifier
<strong>input_attachment_index</strong>, or a compile-time error results.
For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">layout(input_attachment_index = 2) uniform subpassInput t;</code></pre>
</div>
</div>
<div class="paragraph">
<p>This selects which subpass input is being read from. The value assigned
to <strong>input_attachment_index</strong>, say <em>i</em> (<code>input_attachment_index = i</code>), selects
that entry (<em>i</em> th entry) in the input list for the pass.  See the API
documentation for more detail about passes and the input list.</p>
</div>
<div class="paragraph">
<p>If an array of size <em>N</em> is declared, it consumes <em>N</em> consecutive
<strong>input_attachment_index</strong> values, starting with the one provided.</p>
</div>
<div class="paragraph">
<p>It is a compile-time or link-time error to have different variables
declared with the same <strong>input_attachment_index</strong>.
This includes any overlap in the implicit <strong>input_attachment_index</strong> consumed by
array declarations.</p>
</div>
<div class="paragraph">
<p>It is a compile-time error if the value assigned to an <strong>input_attachment_index</strong>
is greater than or equal to <em>gl_MaxInputAttachments</em>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="interpolation-qualifiers"><a class="anchor" href="#interpolation-qualifiers"></a>Interpolation Qualifiers</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Inputs and outputs that could be interpolated can be further qualified by at
most one of the following interpolation qualifiers:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Qualifier</th>
<th class="tableblock halign-left valign-top">Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>smooth</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">perspective correct interpolation</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>flat</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">no interpolation</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>noperspective</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">linear interpolation</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The presence of and type of interpolation is controlled by the above
interpolation qualifiers as well as the auxiliary storage qualifiers
<strong>centroid</strong> and <strong>sample</strong>.
When no interpolation qualifier is present, smooth interpolation is used.
It is a compile-time error to use more than one interpolation qualifier.
The auxiliary storage qualifier <strong>patch</strong> is not used for interpolation; it is
a compile-time error to use interpolation qualifiers with <strong>patch</strong>.</p>
</div>
<div class="paragraph">
<p>A variable qualified as <strong>flat</strong> will not be interpolated.
Instead, it will have the same value for every fragment within a primitive.
This value will come from a single provoking vertex, as described by the
<a href="references.html#references" class="xref page">API</a>.
A variable qualified as <strong>flat</strong> may also be qualified as <strong>centroid</strong> or
<strong>sample</strong>, which will mean the same thing as qualifying it only as <strong>flat</strong>.</p>
</div>
<div class="paragraph">
<p>A variable qualified as <strong>smooth</strong> will be interpolated in a
perspective-correct manner over the primitive being rendered.
Interpolation in a perspective correct manner is specified in equation 14.7
of the <a href="references.html#references" class="xref page">OpenGL Specification</a>, section 14.5 &#8220;Line Segments&#8221;.</p>
</div>
<div class="paragraph">
<p>A variable qualified as <strong>noperspective</strong> must be interpolated linearly in
screen space, as described in equation 3.7 of the <a href="references.html#references" class="xref page">OpenGL Specification</a>,
section 3.5 &#8220;Line Segments&#8221;.</p>
</div>
<div class="paragraph">
<p>When multisample rasterization is disabled, or for fragment shader input
variables qualified with neither <strong>centroid</strong> nor <strong>sample</strong>, the value of the
assigned variable may be interpolated anywhere within the pixel and a single
value may be assigned to each sample within the pixel, to the extent
permitted by the <a href="references.html#references" class="xref page">OpenGL Specification</a>.</p>
</div>
<div class="paragraph">
<p>When multisample rasterization is enabled, <strong>centroid</strong> and <strong>sample</strong> may be
used to control the location and frequency of the sampling of the qualified
fragment shader input.
If a fragment shader input is qualified with <strong>centroid</strong>, a single value may
be assigned to that variable for all samples in the pixel, but that value
must be interpolated at a location that lies in both the pixel and in the
primitive being rendered, including any of the pixel&#8217;s samples covered by
the primitive.
Because the location at which the variable is interpolated may be different
in neighboring pixels, and derivatives may be computed by computing
differences between neighboring pixels, derivatives of centroid-sampled
inputs may be less accurate than those for non-centroid interpolated
variables.
If a fragment shader input is qualified with <strong>sample</strong>, a separate value must
be assigned to that variable for each covered sample in the pixel, and that
value must be sampled at the location of the individual sample.</p>
</div>
<div class="paragraph">
<p>It is a link-time error if, within the same stage, the interpolation
qualifiers of variables of the same name do not match.</p>
</div>
<div class="sect2">
<h3 id="redeclaring-built-in-interpolation-variables-in-the-compatibility-profile"><a class="anchor" href="#redeclaring-built-in-interpolation-variables-in-the-compatibility-profile"></a>Redeclaring Built-In Interpolation Variables in the Compatibility Profile</h3>
<div class="paragraph">
<p>The following predeclared variables can be redeclared with an interpolation
qualifier when using the compatibility profile:</p>
</div>
<div class="paragraph">
<p>Vertex, tessellation control, tessellation evaluation, and geometry
languages:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">gl_FrontColor
gl_BackColor
gl_FrontSecondaryColor
gl_BackSecondaryColor</code></pre>
</div>
</div>
<div class="paragraph">
<p>Fragment language:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">gl_Color
gl_SecondaryColor</code></pre>
</div>
</div>
<div class="paragraph">
<p>For example,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">in vec4 gl_Color;            // predeclared by the fragment language
flat in vec4 gl_Color;       // redeclared by user to be flat
flat in vec4 gl_FrontColor;  // input to geometry shader, no "gl_in[]"
flat out vec4 gl_FrontColor; // output from geometry shader</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ideally, these are redeclared as part of the redeclaration of an interface
block, as described in
&#8220;<a href="builtins.html#compatibility-profile-built-in-language-variables" class="xref page">Compatibility Profile Built-In Language Variables</a>&#8221;.
However, for the above purpose, they can be redeclared as individual
variables at global scope, outside an interface block.
Such redeclarations also allow adding the transform-feedback qualifiers
<strong>xfb_buffer</strong>, <strong>xfb_stride</strong>, and <strong>xfb_offset</strong> to output variables.
(Using <strong>xfb_buffer</strong> on a variable does not change the global default
buffer.) A compile-time error will result if a shader has both an interface
block redeclaration and a separate redeclaration of a member of that
interface block outside the interface block redeclaration.</p>
</div>
<div class="paragraph">
<p>If <em>gl_Color</em> is redeclared with an interpolation qualifier, then
<em>gl_FrontColor</em> and <em>gl_BackColor</em> (if they are written to) must also be
redeclared with the same interpolation qualifier, and vice versa.
If <em>gl_SecondaryColor</em> is redeclared with an interpolation qualifier, then
<em>gl_FrontSecondaryColor</em> and _gl_BackSecondaryColor _(if they are written
to) must also be redeclared with the same interpolation qualifier, and vice
versa.
This qualifier matching on predeclared variables is only required for
variables that are statically used within the shaders in a program.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="parameter-qualifiers"><a class="anchor" href="#parameter-qualifiers"></a>Parameter Qualifiers</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In addition to precision qualifiers and memory qualifiers, parameters can
have these parameter qualifiers.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Qualifier</th>
<th class="tableblock halign-left valign-top">Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;none: default&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">same as <strong>in</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>const</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">for function parameters that cannot be written to</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>in</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">for function parameters passed into a function</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>out</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">for function parameters passed back out of a function,
                   but not initialized for use when passed in</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>inout</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">for function parameters passed both into and out of a
                   function</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Parameter qualifiers are discussed in more detail in
&#8220;<a href="statements.html#function-calling-conventions" class="xref page">Function Calling Conventions</a>&#8221;.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="precision-and-precision-qualifiers"><a class="anchor" href="#precision-and-precision-qualifiers"></a>Precision and Precision Qualifiers</h2>
<div class="sectionbody">
<div class="paragraph">
<p>When not targeting Vulkan:
Precision qualifiers are added for code portability with OpenGL ES, not for
functionality.
They have the same syntax as in OpenGL ES, as described below, but they have
no semantic meaning, which includes no effect on the precision used to store
or operate on variables.
If an extension adds in the same semantics and functionality in the OpenGL
ES 2.0 specification for precision qualifiers, then the extension is allowed
to reuse the keywords below for that purpose.</p>
</div>
<div class="paragraph">
<p>When targeting Vulkan:
For interface matching, uniform variables and uniform and buffer block
members must have the same precision qualification.
Global variables declared in different compilation units linked into the
same shader stage must be declared with the same precision qualification.</p>
</div>
<div class="paragraph">
<p>For the purposes of determining if an output from one shader stage matches
an input of the next stage, the precision qualifier need not match.</p>
</div>
<div class="paragraph">
<p>This specification only governs the minimum required precision for storage and
operations on values.
Implementations are free to calculate and/or store any results at higher
precisions.
If necessary, this variance can be controlled using the invariance qualifier.</p>
</div>
<div class="sect2">
<h3 id="range-and-precision"><a class="anchor" href="#range-and-precision"></a>Range and Precision</h3>
<div class="paragraph">
<p>The precision of <strong>highp</strong>
single- and double-precision
floating-point variables is defined by the IEEE 754 standard for
32-bit
and 64-bit
floating-point numbers.</p>
</div>
<div class="paragraph">
<p>This includes support for NaNs (Not a Number) and Infs (positive or negative
infinities) and positive and negative zeros.</p>
</div>
<div class="paragraph">
<p>The following rules apply to <strong>highp</strong>
for both single and double-precision
operations:
Signed infinities and zeros are generated as dictated by IEEE, but subject
to the precisions allowed in the following table.
Any subnormal (denormalized) value input into a shader or potentially
generated by any operation in a shader can be flushed to 0.
The rounding mode cannot be set and is undefined but must not affect the
result by more than 1 ULP.
NaNs are not required to be generated.
Support for signaling NaNs is not required and exceptions are never raised.
Operations including built-in functions that operate on a NaN are not
required to return a NaN as the result.
However if NaNs are generated, <strong>isnan</strong>() must return the correct value.</p>
</div>
<div class="paragraph">
<p>Precisions are expressed in terms of maximum relative error in units of ULP
(units in the last place), unless otherwise noted.</p>
</div>
<div class="paragraph">
<p>For single precision operations, precisions are required as follows:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Operation</th>
<th class="tableblock halign-left valign-top">Precision</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>a</em> + <em>b</em>, <em>a</em> - <em>b</em>, <em>a</em> * <em>b</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Correctly rounded.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;, &lt;=, ==, &gt;, &gt;=</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Correct result.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>a</em> / <em>b</em>, 1.0 / <em>b</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2.5 ULP for <span class="eq">|b|</span> in the range <span class="eq">[2<sup>-126</sup>, 2<sup>126</sup>]</span>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>a</em> * <em>b</em> + <em>c</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Correctly rounded single operation or
                                    sequence of two correctly rounded operations.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>fma</strong>()</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Inherited from <em>a</em> * <em>b</em> + <em>c</em>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>pow</strong>(<em>x</em>, <em>y</em>)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Inherited from <strong>exp2</strong>(<em>y</em> * <strong>log2</strong>(<em>x</em>)).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>exp</strong>(<em>x</em>), <strong>exp2</strong>(<em>x</em>)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="eq">(3 + 2 ⋅ |x|)</span> ULP.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>log</strong>(), <strong>log2</strong>()</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">3 ULP outside the range <span class="eq">[0.5,2.0]</span>.<br>
                                    Absolute error &lt; 2<sup>-21</sup> inside the range
                                    <span class="eq">[0.5,2.0]</span>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>sqrt</strong>()</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Inherited from 1.0 / <strong>inversesqrt</strong>().</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>inversesqrt</strong>()</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2 ULP.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">implicit and explicit
  conversions between types</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Correctly rounded.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Built-in functions defined in the specification with an equation built from
the above operations inherit the above errors.
These include, for example, the geometric functions, the common functions,
and many of the matrix functions.
Built-in functions not listed above and not defined as equations of the
above have undefined precision.
These include, for example, the trigonometric functions and determinant.</p>
</div>
<div class="paragraph">
<p>The precision of double-precision operations is at least that of single
precision.</p>
</div>
</div>
<div class="sect2">
<h3 id="conversion-between-precisions"><a class="anchor" href="#conversion-between-precisions"></a>Conversion between precisions</h3>
<div class="paragraph">
<p>Within the same type, conversion from a lower to a higher precision must be
exact.
When converting from a higher precision to a lower precision, if the value
is representable by the implementation of the target precision, the
conversion must also be exact.
If the value is not representable, the behavior is dependent on the type:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>For signed and unsigned integers, the value is truncated; bits in
positions not present in the target precision are set to zero.
(Positions start at zero and the least significant bit is considered to
be position zero for this purpose.)</p>
</li>
<li>
<p>For floating-point values, the value should either clamp to +Inf or
-Inf, or to the maximum or minimum value that the implementation
supports.
While this behavior is implementation-dependent, it should be consistent
for a given implementation.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="precision-qualifiers"><a class="anchor" href="#precision-qualifiers"></a>Precision Qualifiers</h3>
<div class="paragraph">
<p>Any
single-precision
floating-point, integer, or opaque-type declaration can have the type
preceded by one of these precision qualifiers:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Qualifier</th>
<th class="tableblock halign-left valign-top">Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>highp</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">32-bit two&#8217;s complement for integers,
              32-bit IEEE 754 floating-point for <strong>float</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>mediump</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SPIR-V <strong>RelaxedPrecision</strong> when targeting Vulkan, otherwise none.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>lowp</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SPIR-V <strong>RelaxedPrecision</strong> when targeting Vulkan, otherwise none.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">lowp float color;
out mediump vec2 P;
lowp ivec2 foo(lowp mat3);
highp mat4 m;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Literal constants do not have precision qualifiers.
Neither do Boolean variables.</p>
</div>
<div class="paragraph">
<p>For this paragraph, &#8220;operation&#8221; includes operators, built-in functions,
and constructors, and &#8220;operand&#8221; includes function arguments and
constructor arguments.
The precision qualification associated with any operation is the highest
precision qualification of the operands consumed by the operation, if any
operand has an associated precision.
In cases where no operand has a precision qualifier, the precision
qualifications of the operands of the next consuming operation in the
expression will be used.
This rule can be applied recursively until a precision qualified operand is
found.
If necessary, it will also include the precision qualification of l-values
for assignments, of the declared variable for initializers, of formal
parameters for function call arguments, or of function return types for
function return values.
If the precision cannot be determined by this method e.g. if an entire
expression is composed only of operands with no precision qualifier, and the
result is not assigned or passed as an argument, then it is evaluated at the
default precision of the type or greater.
When this occurs in the fragment shader, the default precision must be
defined.</p>
</div>
<div class="paragraph">
<p>For example, consider the statements:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">uniform highp float h1;
highp float h2 = 2.3 * 4.7; // operation and result are highp
precision
mediump float m;
m = 3.7 * h1 * h2; // all operations are highp precision
h2 = m * h1; // operation is highp precision
m = h2 - h1; // operation is highp precision
h2 = m + m; // addition and result at mediump precision
void f(highp float p);
f(3.3); // 3.3 will be passed in at highp precision</code></pre>
</div>
</div>
<div class="paragraph">
<p>Precision qualifiers, as with other qualifiers, do not affect the basic type
of the variable.
In particular, there are no constructors for precision conversions;
constructors only convert types.
Similarly, precision qualifiers, as with other qualifiers, do not contribute
to function overloading based on parameter types.
As discussed in &#8220;<a href="statements.html#function-calling-conventions" class="xref page">Function Calling Conventions</a>&#8221;, function input and output is done through copies, and
therefore qualifiers do not have to match.</p>
</div>
<div class="paragraph">
<p>The precision of a variable is determined when the variable is declared and
cannot be subsequently changed.</p>
</div>
<div class="paragraph">
<p>Where the precision of a constant integral or constant floating-point
expression is not specified, evaluation is performed at <strong>highp</strong>.
This rule does not affect the precision qualification of the expression.</p>
</div>
<div class="paragraph">
<p>The evaluation of constant expressions must be invariant and will usually be
performed at compile time.</p>
</div>
</div>
<div class="sect2">
<h3 id="default-precision-qualifiers"><a class="anchor" href="#default-precision-qualifiers"></a>Default Precision Qualifiers</h3>
<div class="paragraph">
<p>The precision statement</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">precision precision-qualifier type;</code></pre>
</div>
</div>
<div class="paragraph">
<p>can be used to establish a default precision qualifier.
The <em>type</em> field can be either <strong>int</strong>, <strong>float</strong>, or any of the opaque types,
and the <em>precision-qualifier</em> can be <strong>lowp</strong>, <strong>mediump</strong>, or <strong>highp</strong>.</p>
</div>
<div class="paragraph">
<p>Any other types or qualifiers will result in a compile-time error.
If <em>type</em> is <strong>float</strong>, the directive applies to non-precision-qualified
single-precision
floating-point type (scalar, vector, and matrix) declarations.
If <em>type</em> is <strong>int</strong>, the directive applies to all non-precision-qualified
integer type (scalar, vector, signed, and unsigned) declarations.
This includes global variable declarations, function return declarations,
function parameter declarations, and local variable declarations.</p>
</div>
<div class="paragraph">
<p>Non-precision qualified declarations will use the precision qualifier
specified in the most recent <strong>precision</strong> statement that is still in scope.
The <strong>precision</strong> statement has the same scoping rules as variable
declarations.
If it is declared inside a compound statement, its effect stops at the end
of the inner-most statement it was declared in.
Precision statements in nested scopes override precision statements in outer
scopes.
Multiple precision statements for the same basic type can appear inside the
same scope, with later statements overriding earlier statements within that
scope.</p>
</div>
<div class="paragraph">
<p>For any type that accepts a precision qualifier,
the default precision qualification will be <strong>highp</strong>.
Because all types requiring a precision qualifier have a default precision,
there are no errors for omission of a precision qualifier.</p>
</div>
</div>
<div class="sect2">
<h3 id="available-precision-qualifiers"><a class="anchor" href="#available-precision-qualifiers"></a>Available Precision Qualifiers</h3>
<div class="paragraph">
<p>The built-in macro GL_FRAGMENT_PRECISION_HIGH is defined to one:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">#define GL_FRAGMENT_PRECISION_HIGH 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>This macro is available in all languages except compute.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="variance-and-the-invariant-qualifier"><a class="anchor" href="#variance-and-the-invariant-qualifier"></a>Variance and the Invariant Qualifier</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In this section, <em>variance</em> refers to the possibility of getting different
values from the same expression in different programs.
For example, consider the situation where two vertex shaders, in different
programs, each set <em>gl_Position</em> with the same expression, and the input
values into that expression are the same when both shaders run.
It is possible, due to independent compilation of the two shaders, that the
values assigned to <em>gl_Position</em> are not exactly the same when the two
shaders run.
In this example, this can cause problems with alignment of geometry in a
multi-pass algorithm.</p>
</div>
<div class="paragraph">
<p>In general, such variance between shaders is allowed.
When such variance does not exist for a particular output variable, that
variable is said to be <em>invariant</em>.</p>
</div>
<div class="sect2">
<h3 id="the-invariant-qualifier"><a class="anchor" href="#the-invariant-qualifier"></a>The Invariant Qualifier</h3>
<div class="paragraph">
<p>To ensure that a particular output variable is invariant, it is necessary to
use the <strong>invariant</strong> qualifier.
It can either be used to qualify a previously declared variable as being
invariant:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">invariant gl_Position; // make existing gl_Position be invariant
out vec3 Color;
invariant Color;       // make existing Color be invariant</code></pre>
</div>
</div>
<div class="paragraph">
<p>or as part of a declaration when a variable is declared:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">invariant centroid out vec3 Color;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Only variables output from a shader can be candidates for invariance.
This includes user-defined output variables and the built-in output
variables.
As only outputs can be declared as invariant, an output from one shader
stage will still match an input of a subsequent stage without the input
being declared as invariant.</p>
</div>
<div class="paragraph">
<p>Input or output instance names on blocks are not used when redeclaring
built-in variables.</p>
</div>
<div class="paragraph">
<p>The <strong>invariant</strong> keyword can be followed by a comma separated list of
previously declared identifiers.
All uses of <strong>invariant</strong> must be at global scope or on block
members, and before any use of the variables being declared as invariant.</p>
</div>
<div class="paragraph">
<p>To guarantee invariance of a particular output variable across two programs,
the following must also be true:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The output variable is declared as invariant in both programs.</p>
</li>
<li>
<p>The same values must be input to all shader input variables consumed by
expressions and control flow contributing to the value assigned to the
output variable.</p>
</li>
<li>
<p>The texture formats, texel values, and texture filtering are set the
same way for any texture function calls contributing to the value of the
output variable.</p>
</li>
<li>
<p>All input values are all operated on in the same way.
    All operations in the consuming expressions and any intermediate
    expressions must be the same, with the same order of operands and same
    associativity, to give the same order of evaluation.
    Intermediate variables and functions must be declared as the same type
    with the same explicit or implicit precision
qualifiers.
    Any control flow affecting the output value must be the same, and any
    expressions consumed to determine this control flow must also follow
    these invariance rules.</p>
</li>
<li>
<p>All the data flow and control flow leading to setting the invariant
output variable reside in a single compilation unit.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Essentially, all the data flow and control flow leading to an invariant
output must match.</p>
</div>
<div class="paragraph">
<p>Initially, by default, all output variables are allowed to be variant.
To force all output variables to be invariant, use the pragma</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">#pragma STDGL invariant(all)</code></pre>
</div>
</div>
<div class="paragraph">
<p>before all declarations in a shader.
If this pragma is used after the declaration of any variables or functions,
then the set of outputs that behave as invariant is undefined.</p>
</div>
<div class="paragraph">
<p>Generally, invariance is ensured at the cost of flexibility in optimization,
so performance can be degraded by use of invariance.
Hence, use of this pragma is intended as a debug aid, to avoid individually
declaring all output variables as invariant.</p>
</div>
</div>
<div class="sect2">
<h3 id="invariance-of-constant-expressions"><a class="anchor" href="#invariance-of-constant-expressions"></a>Invariance of Constant Expressions</h3>
<div class="paragraph">
<p>Invariance must be guaranteed for constant expressions.
A particular constant expression must evaluate to the same result if it
appears again in the same shader or a different shader.
This includes the same expression appearing in two shaders of the same
language or shaders of two different languages.</p>
</div>
<div class="paragraph">
<p>Constant expressions must evaluate to the same result when operated on as
already described above for invariant variables.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="the-precise-qualifier"><a class="anchor" href="#the-precise-qualifier"></a>The Precise Qualifier</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Some algorithms require floating-point computations to exactly follow the
order of operations specified in the source code and to treat all operations
consistently, even if the implementation supports optimizations that could
produce nearly equivalent results with higher performance.
For example, many GL implementations support a &#8220;multiply-add&#8221; instruction
that can compute a floating-point expression such as</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">result = (a * b) + (c * d);</code></pre>
</div>
</div>
<div class="paragraph">
<p>in two operations instead of three operations; one multiply and one
multiply-add instead of two multiplies and one add.
The result of a floating-point multiply-add might not always be identical to
first doing a multiply yielding a floating-point result and then doing a
floating-point add.
Hence, in this example, the two multiply operations would not be treated
consistently; the two multiplies could effectively appear to have differing
precisions.</p>
</div>
<div class="paragraph">
<p>The key computation that needs to be made consistent appears when
tessellating, where intermediate points for subdivision are synthesized in
different directions, yet need to yield the same result, as shown in the
diagram below.</p>
</div>
<div id="img-precise" class="imageblock unresolved">
<div class="content">
<img src="images/precise.svg" alt="precise">
</div>
</div>
<div class="paragraph">
<p>Without any qualifiers, implementations are permitted to perform
optimizations that effectively modify the order or number of operations used
to evaluate an expression, even if those optimizations may produce slightly
different results relative to unoptimized code.</p>
</div>
<div class="paragraph">
<p>The <strong>precise</strong> qualifier ensures that operations contributing to a
variable&#8217;s value are done in their stated order and with operator consistency.
The order is determined by operator precedence and parentheses, as described in
&#8220;<a href="operators.html#operators" class="xref page">Operators</a>&#8221;.
Operator consistency means that for each operator, its result is always
computed with the same precision.
Specifically, values computed by compiler-generated code must adhere to the
following identities:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>a + b = b + a</p>
</li>
<li>
<p>a * b = b * a</p>
</li>
<li>
<p>a * b + c * d = b * a + c* d = d * c + b * a = &lt;any other mathematically
valid combination&gt;</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>While the following are prevented:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>a + (b + c) is not allowed to become (a + b) + c</p>
</li>
<li>
<p>a * (b * c) is not allowed to become (a * b) * c</p>
</li>
<li>
<p>a * b + c is not allowed to become a single operation <strong>fma</strong>(a, b, c)</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Where <em>a</em>, <em>b</em>, <em>c</em>, and <em>d</em>, are scalars or vectors, not matrices.
(Matrix multiplication generally does not commute.) It is the shader
writer&#8217;s responsibility to express the computation in terms of these rules
and the compiler&#8217;s responsibility to follow these rules.
See the description of <em>gl_TessCoord</em> for the rules the tessellation stages
are responsible for following, which in conjunction with the above allow
avoiding cracking when subdividing.</p>
</div>
<div class="paragraph">
<p>For example,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">precise out vec4 position;</code></pre>
</div>
</div>
<div class="paragraph">
<p>declares that operations used to produce the value of <em>position</em> must be
performed in exactly the order specified in the source code and with all
operators being treated consistently.
As with the <strong>invariant</strong> qualifier (see &#8220;<a href="#the-invariant-qualifier">The Invariant Qualifier</a>&#8221;), the <strong>precise</strong> qualifier may be used to qualify a
built-in or previously declared user-defined variable as being precise:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">out vec3 Color;
precise Color; // make existing Color be precise</code></pre>
</div>
</div>
<div class="paragraph">
<p>When applied to a block or a variable of structure type,
<strong>precise</strong> applies to each contained member, recursively.</p>
</div>
<div class="paragraph">
<p>This qualifier will affect the evaluation of an r-value in a particular
function if and only if the result is eventually consumed in the same
function by an l-value qualified as <strong>precise</strong>.
Any other expressions within a function are not affected, including return
values and output parameters not declared as <strong>precise</strong> but that are
eventually consumed outside the function by a variable qualified as
<strong>precise</strong>. Unaffected expressions also include the controlling expressions
in selection and iteration statements and the condition in ternary
operators (<strong>?:</strong>).</p>
</div>
<div class="paragraph">
<p>Some examples of the use of <strong>precise</strong>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">in vec4 a, b, c, d;
precise out vec4 v;

float func(float e, float f, float g, float h)
{
    return (e*f) + (g*h); // no constraint on order or operator consistency
}

float func2(float e, float f, float g, float h)
{
    precise float result = (e*f) + (g*h); // ensures same precision for the two multiplies
    return result;
}

float func3(float i, float j, precise out float k)
{
    k = i * i + j;        // precise, due to &lt;k&gt; declaration
}

void main()
{
    vec3 r = vec3(a * b);             // precise, used to compute v.xyz
    vec3 s = vec3(c * d);             // precise, used to compute v.xyz
    v.xyz = r + s;                    // precise
    v.w = (a.w * b.w) + (c.w * d.w);  // precise
    v.x = func(a.x, b.x, c.x, d.x);   // values computed in func() are NOT precise
    v.x = func2(a.x, b.x, c.x, d.x);  // precise!
    func3(a.x * b.x, c.x * d.x, v.x); // precise!
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>For the purposes of determining if an output from one shader stage matches
an input of the next stage, the <strong>precise</strong> qualifier need not match between
the input and the output.</p>
</div>
<div class="paragraph">
<p>All constant expressions are evaluated as if <strong>precise</strong> was present, whether
or not it is present.
However, as described in &#8220;<a href="#constant-expressions">Constant Expressions</a>&#8221;,
there is no requirement that a compile-time constant expression evaluates to
the same value as a corresponding non-constant expression.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="memory-qualifiers"><a class="anchor" href="#memory-qualifiers"></a>Memory Qualifiers</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Shader storage blocks, variables declared within shader storage blocks and
variables declared as image types (the basic opaque types with &#8220;<strong>image</strong>&#8221;
in their keyword), can be further qualified with one or more of the
following memory qualifiers:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Qualifier</th>
<th class="tableblock halign-left valign-top">Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>coherent</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">memory variable where reads and writes are coherent with
                reads and writes from other shader invocations</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>volatile</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">memory variable whose underlying value may be changed at any
                point during shader execution by some source other than the
                current shader invocation</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>restrict</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">memory variable where use of that variable is the only way
                to read and write the underlying memory in the relevant
                shader stage</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>readonly</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">memory variable that can be used to read the underlying
                memory, but cannot be used to write the underlying memory</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>writeonly</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">memory variable that can be used to write the underlying
                memory, but cannot be used to read the underlying memory</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Memory accesses to image variables declared using the <strong>coherent</strong> qualifier
are performed coherently with accesses to the same location from other
shader invocations.
In particular, when reading a variable declared as <strong>coherent</strong>, the values
returned will reflect the results of previously completed writes performed
by other shader invocations.
When writing a variable declared as <strong>coherent</strong>, the values written will be
reflected in subsequent coherent reads performed by other shader
invocations.</p>
</div>
<div class="paragraph">
<p>As described in section
7.12
&#8220;Shader Memory Access&#8221; of the
<a href="references.html#references" class="xref page">OpenGL Specification</a>, shader memory reads and writes complete in a
largely undefined order.
The built-in function <strong>memoryBarrier</strong>() can be used if needed to guarantee
the completion and relative ordering of memory accesses performed by a
single shader invocation.</p>
</div>
<div class="paragraph">
<p>When accessing memory using variables not declared as <strong>coherent</strong>, the memory
accessed by a shader may be cached by the implementation to service future
accesses to the same address.
Memory stores may be cached in such a way that the values written may not be
visible to other shader invocations accessing the same memory.
The implementation may cache the values fetched by memory reads and return
the same values to any shader invocation accessing the same memory, even if
the underlying memory has been modified since the first memory read.
While variables not declared as <strong>coherent</strong> may not be useful for
communicating between shader invocations, using non-coherent accesses may
result in higher performance.</p>
</div>
<div class="paragraph">
<p>Memory accesses to image variables declared using the <strong>volatile</strong> qualifier
must treat the underlying memory as though it could be read or written at
any point during shader execution by some source other than the executing
shader invocation.
When a volatile variable is read, its value must be re-fetched from the
underlying memory, even if the shader invocation performing the read had
previously fetched its value from the same memory.
When a volatile variable is written, its value must be written to the
underlying memory, even if the compiler can conclusively determine that its
value will be overwritten by a subsequent write.
Since the external source reading or writing a <strong>volatile</strong> variable may be
another shader invocation, variables declared as <strong>volatile</strong> are
automatically treated as coherent.</p>
</div>
<div class="paragraph">
<p>Memory accesses to image variables declared using the <strong>restrict</strong> qualifier
may be compiled assuming that the variable used to perform the memory access
is the only way to access the underlying memory using the shader stage in
question.
This allows the compiler to coalesce or reorder loads and stores using
<strong>restrict</strong>-qualified image variables in ways that wouldn&#8217;t be permitted
for image variables not so qualified, because the compiler can assume that
the underlying image won&#8217;t be read or written by other code.
Applications are responsible for ensuring that image memory referenced by
variables qualified with <strong>restrict</strong> will not be referenced using other
variables in the same scope; otherwise, accesses to <strong>restrict</strong>-qualified
variables will have undefined results.</p>
</div>
<div class="paragraph">
<p>Memory accesses to image variables declared using the <strong>readonly</strong> qualifier
may only read the underlying memory, which is treated as read-only memory
and cannot be written to.
It is a compile-time error to pass an image variable qualified with
<strong>readonly</strong> to <strong>imageStore</strong>() or other built-in functions that modify image
memory.</p>
</div>
<div class="paragraph">
<p>Memory accesses to image variables declared using the <strong>writeonly</strong> qualifier
may only write the underlying memory; the underlying memory cannot be read.
It is a compile-time error to pass an image variable qualified with
<strong>writeonly</strong> to <strong>imageLoad</strong>() or other built-in functions that read image
memory.</p>
</div>
<div class="paragraph">
<p>A variable could be qualified as both <strong>readonly</strong> and <strong>writeonly</strong>, disallowing
both read and write. Such variables can still be used with some queries, for
example <strong>imageSize</strong>() and <strong>.length</strong>().</p>
</div>
<div class="paragraph">
<p>The memory qualifiers <strong>coherent</strong>, <strong>volatile</strong>, <strong>restrict</strong>, <strong>readonly</strong>, and
<strong>writeonly</strong> may be used in the declaration of buffer variables (i.e.,
members of shader storage blocks).
When a buffer variable is declared with a memory qualifier, the behavior
specified for memory accesses involving image variables described above
applies identically to memory accesses involving that buffer variable.
It is a compile-time error to assign to a buffer variable qualified with
<strong>readonly</strong> or to read from a buffer variable qualified with <strong>writeonly</strong>.
The combination <strong>readonly</strong> <strong>writeonly</strong> is allowed.</p>
</div>
<div class="paragraph">
<p>Additionally, memory qualifiers may be used at the block-level declaration
of a shader storage block, including the combination <strong>readonly</strong> <strong>writeonly</strong>.
When a block declaration is qualified with a memory qualifier, it is as if
all of its members were declared with the same memory qualifier.
For example, the block declaration</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">coherent buffer Block {
    readonly vec4 member1;
    vec4 member2;
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>is equivalent to</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">buffer Block {
    coherent readonly vec4 member1;
    coherent vec4 member2;
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>Memory qualifiers are only supported in the declarations of image variables,
buffer variables, and shader storage blocks; it is an error to use such
qualifiers in any other declarations.</p>
</div>
<div class="paragraph">
<p>When calling user-defined functions, opaque-type variables qualified with
<strong>coherent</strong>, <strong>volatile</strong>, <strong>readonly</strong>, or <strong>writeonly</strong> may not be passed to
functions whose formal parameters lack such qualifiers.
(See &#8220;<a href="statements.html#function-definitions" class="xref page">Function Definitions</a>&#8221; for more detail on
function calling.) It is legal to have any additional memory qualifiers on a
formal parameter, but only <strong>restrict</strong> can be taken away from an opaque-type
calling argument, by a formal parameter that lacks the <strong>restrict</strong> qualifier.
For non-opaque argument types, where the values operated on by the called
function are copied-in/copied-out, memory qualifiers are not required match.</p>
</div>
<div class="paragraph">
<p>When a built-in function is called, the code generated is to be based on the
actual qualification of the calling argument, not on the list of memory
qualifiers specified on the formal parameter in the prototype.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">vec4 funcA(restrict image2D a) { ... }
vec4 funcB(image2D a) { ... }
layout(rgba32f) uniform image2D img1;
layout(rgba32f) coherent uniform image2D img2;

funcA(img1);        // OK, adding "restrict" is allowed
funcB(img2);        // illegal, stripping "coherent" is not</code></pre>
</div>
</div>
<div class="paragraph">
<p>Layout qualifiers cannot be used on formal function parameters, and layout
qualification is not included in parameter matching.</p>
</div>
<div class="paragraph">
<p>Note that the use of <strong>const</strong> in an image variable declaration is qualifying
the const-ness of the variable being declared, not the image it refers to.
The qualifier <strong>readonly</strong> qualifies the image memory (as accessed through
that variable) while <strong>const</strong> qualifies the variable itself.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="specialization-constant-qualifier"><a class="anchor" href="#specialization-constant-qualifier"></a>Specialization-Constant Qualifier</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Specialization constants are used only for SPIR-V and declared using the
<strong>constant_id</strong> layout qualifier.
For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">layout(constant_id = 17) const int arraySize = 12;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The above makes a specialization constant with a default value of 12.
The number 17 is an example author-chosen id by which the API or other tools
can later refer to this specific specialization constant.
If it is never changed before final lowering, it will retain the value of
12.
It is a compile-time error to use the <strong>constant_id</strong> qualifier on anything
but SPIR-V generation of a scalar <strong>bool</strong>, <strong>int</strong>, <strong>uint</strong>, <strong>float</strong>, or
<strong>double</strong>.</p>
</div>
<div class="paragraph">
<p>Built-in constants can be declared to be specialization constants.
For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">layout(constant_id = 31) gl_MaxClipDistances; // add specialization_id</code></pre>
</div>
</div>
<div class="paragraph">
<p>The declaration uses just the name of the previously declared built-in
variable, with a <strong>constant_id</strong> layout-qualifier declaration.
It is a compile-time error to do this after the constant has been used:
Constants are strictly either non-specialization constants or specialization
constants, not both.</p>
</div>
<div class="paragraph">
<p>The built-in constant vector <em>gl_WorkGroupSize</em> can be specialized using the
<strong>local_size_{xyz}_id</strong> qualifiers, to individually give the components an id.
For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">layout(local_size_x_id = 18, local_size_z_id = 19) in;</code></pre>
</div>
</div>
<div class="paragraph">
<p>This leaves <em>gl_WorkGroupSize.y</em> as a non-specialization constant, with
<em>gl_WorkGroupSize</em> being a partially specialized vector.
Its <em>x</em> and <em>z</em> components can be later specialized, after generating
SPIR-V, using the ids 18 and 19.
These ids are declared independently from declaring the workgroup size:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">layout(local_size_x = 32, local_size_y = 32) in;   // size is (32,32,1)
layout(local_size_x_id = 18) in;                   // constant_id for x
layout(local_size_z_id = 19) in;                   // constant_id for z</code></pre>
</div>
</div>
<div class="paragraph">
<p>Existing rules for declaring <strong>local_size_x</strong>, <strong>local_size_y</strong>, and
<strong>local_size_z</strong> are not changed.
For the local-size ids, it is a compile-time error to provide different id
values for the same local-size id, or to provide them after any use.
Otherwise, order, placement, number of statements, and replication do not
cause errors.</p>
</div>
<div class="paragraph">
<p>Two arrays sized with specialization constants are the same type only if
sized with the same symbol, and involving no operations.
For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">layout(constant_id = 51) const int aSize = 20;
const int pad = 2;
const int total = aSize + pad; // specialization constant
int a[total], b[total];        // a and b have the same type
int c[22];                     // different type than a or b
int d[aSize + pad];            // different type than a, b, or c
int e[aSize + 2];              // different type than a, b, c, or d</code></pre>
</div>
</div>
<div class="paragraph">
<p>Types containing arrays sized with a specialization constant cannot be
compared, assigned as aggregates, declared with an initializer, or used as
an initializer.
They can, however, be passed as arguments to functions having formal
parameters of the same type.
Only the outer-most dimension of a variable declared as an array of arrays
can be a specialization constant, otherwise a compile-time error results.</p>
</div>
<div class="paragraph">
<p>Arrays inside a block may be sized with a specialization constant, but the
block will have a static layout.
Changing the specialized size will not re-layout the block.
In the absence of explicit offsets, the layout will be based on the default
size of the array.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="order-of-qualification"><a class="anchor" href="#order-of-qualification"></a>Order and Repetition of Qualification</h2>
<div class="sectionbody">
<div class="paragraph">
<p>When multiple qualifiers are present in a declaration, they may appear in
any order, but they must all appear before the type.
The <strong>layout</strong> qualifier is the only qualifier that can appear more than once.
Further, a declaration can have at most one storage qualifier, at most one
auxiliary storage qualifier, and at most one interpolation qualifier.
If <strong>inout</strong> is used, neither <strong>in</strong> nor <strong>out</strong> may be used.
Multiple memory qualifiers can be used.
Any violation of these rules will cause a compile-time error.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="empty-declarations"><a class="anchor" href="#empty-declarations"></a>Empty Declarations</h2>
<div class="sectionbody">
<div class="paragraph">
<p><em>Empty declarations</em> are declarations without a variable name, meaning no
object is instantiated by the declaration.
Generally, empty declarations are allowed.
Some are useful when declaring structures, while many others have no effect.
For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">int;               // No effect
struct S {int x;}; // Defines a struct S</code></pre>
</div>
</div>
<div class="paragraph">
<p>The combinations of qualifiers that cause compile-time or link-time errors
are the same whether or not the declaration is empty, for example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">invariant in float x; // Error. An input cannot be invariant.
invariant in float;   // Error even though no variable is declared.</code></pre>
</div>
</div>
</div>
</div>
</article>
  </div>
</main>
</div>
<script id="site-script" src="../../../_/js/site.js" data-ui-root-path="../../../_"></script>
<script async src="../../../_/js/vendor/highlight.js"></script>
<script src="../../../_/js/vendor/lunr.js"></script>
<script src="https://cdn.jsdelivr.net/pako/1.0.3/pako.min.js"></script>
<script src="../../../_/js/search-ui.js" id="search-ui-script" data-site-root-path="../../.." data-snippet-length="100" data-stylesheet="../../../_/css/search.css"></script>
<script async src="../../../search-index.js"></script>
  </body>
</html>

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>VK_KHR_video_encode_av1 :: Vulkan Documentation Project</title>
    <meta name="generator" content="Antora 3.1.4">
    <link rel="stylesheet" href="../../../../_/css/site.css">
    <link rel="apple-touch-icon" sizes="180x180" href="../../../../_/img/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="../../../../_/img/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="../../../../_/img/favicon-16x16.png">
    <link rel="manifest" href="../../../../_/static/site.webmanifest">
    <link rel="mask-icon" href="../../../../_/img/safari-pinned-tab.svg" color="#a41e22">
    <meta name="msapplication-TileColor" content="#ffc40d">
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="../../../.."><img class="navbar-item" alt="Vulkan White Label" src="../../../../_/Vulkan_Docs.svg" /></a>
      <div class="navbar-item search hide-for-print">
        <div id="search-field" class="field has-filter">
          <label for="search-input"></label>
          <input id="search-input" type="text" placeholder="Search the docs">
          <label class="filter checkbox">
            <input type="checkbox" data-facet-filter="component:features" checked> In this component
          </label>
        </div>
      </div>
      <button class="navbar-burger" aria-controls="topbar-nav" aria-expanded="false" aria-label="Toggle main menu">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <!-- <a class="navbar-item" href="#">Home</a> -->
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Specs</a>
          <div class="navbar-dropdown is-right">
            <a class="navbar-item" href="../../../../spec/latest/chapters/introduction.html">Vulkan API</a>
            <a class="navbar-item" href="../../../../glsl/latest/index.html">GLSL</a>
            <a class="navbar-item" href="../../../../guide/latest/hlsl.html">HLSL</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Education</a>
          <div class="navbar-dropdown is-right">
            <a class="navbar-item" href="../../../../features/latest/features/index.html">Vulkan Feature Descriptions</a>
            <a class="navbar-item" href="../../../../guide/latest/index.html">Vulkan Guide</a>
            <a class="navbar-item" href="../../../../samples/latest/README.html">Vulkan Samples</a>
            <a class="navbar-item" href="../../../../tutorial/latest/index.html">Vulkan Tutorial</a>
            <a class="navbar-item" href="https://www.youtube.com/c/vulkan">YouTube</a>
            <a class="navbar-item" href="https://vulkan.org">More Info at Vulkan.org</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Feedback</a>
          <div class="navbar-dropdown is-right">
            <a class="navbar-item" href="https://github.com/KhronosGroup/Vulkan-Site/issues/new/choose" target="_blank">Report a Problem</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Community</a>
          <div class="navbar-dropdown is-right">
            <a class="navbar-item" href="https://discord.gg/vulkan">Vulkan Discord</a>
            <a class="navbar-item" href="https://reddit.com/r/vulkan">Reddit</a>
            <a class="navbar-item" href="https://stackoverflow.com/questions/tagged/vulkan">Stack Overflow</a>
            <a class="navbar-item" href="https://fosstodon.org/@vulkan">Mastodon</a>
          </div>
        </div>
      </div>
    </div>
    <label class="theme-toggler">
      <input type="checkbox" id="switch-theme-checkbox" name="switch-theme-checkbox"/>
      <span class="icon"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="moon" class="svg-inline--fa fa-moon moon" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><path fill="currentColor" d="M223.5 32C100 32 0 132.3 0 256S100 480 223.5 480c60.6 0 115.5-24.2 155.8-63.4c5-4.9 6.3-12.5 3.1-18.7s-10.1-9.7-17-8.5c-9.8 1.7-19.8 2.6-30.1 2.6c-96.9 0-175.5-78.8-175.5-176c0-65.8 36-123.1 89.3-153.3c6.1-3.5 9.2-10.5 7.7-17.3s-7.3-11.9-14.3-12.5c-6.3-.5-12.6-.8-19-.8z"></path>
        </svg>
        <svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="sun" class="svg-inline--fa fa-sun sun" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M361.5 1.2c5 2.1 8.6 6.6 9.6 11.9L391 121l107.9 19.8c5.3 1 9.8 4.6 11.9 9.6s1.5 10.7-1.6 15.2L446.9 256l62.3 90.3c3.1 4.5 3.7 10.2 1.6 15.2s-6.6 8.6-11.9 9.6L391 391 371.1 498.9c-1 5.3-4.6 9.8-9.6 11.9s-10.7 1.5-15.2-1.6L256 446.9l-90.3 62.3c-4.5 3.1-10.2 3.7-15.2 1.6s-8.6-6.6-9.6-11.9L121 391 13.1 371.1c-5.3-1-9.8-4.6-11.9-9.6s-1.5-10.7 1.6-15.2L65.1 256 2.8 165.7c-3.1-4.5-3.7-10.2-1.6-15.2s6.6-8.6 11.9-9.6L121 121 140.9 13.1c1-5.3 4.6-9.8 9.6-11.9s10.7-1.5 15.2 1.6L256 65.1 346.3 2.8c4.5-3.1 10.2-3.7 15.2-1.6zM160 256a96 96 0 1 1 192 0 96 96 0 1 1 -192 0zm224 0a128 128 0 1 0 -256 0 128 128 0 1 0 256 0z"></path>
        </svg></span>
      <span class="text">light</span>
    </label>
  </nav>
</header>
<script>
  !function() {
    let e = document.getElementById("switch-theme-checkbox")
    e.checked = document.documentElement.classList.contains("dark-theme")
    e.addEventListener("change", function() {
      if (document.documentElement.classList.contains("light")) {
        document.documentElement.classList.remove("light")
        document.documentElement.classList.add("dark")
      } else if (document.documentElement.classList.contains("dark")) {
        document.documentElement.classList.remove("dark")
        document.documentElement.classList.add("light")
      } else {
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
          document.documentElement.classList.add("dark")
        } else {
          document.documentElement.classList.add("light")
        }
      }
      document.documentElement.classList.toggle("dark-theme", this.checked), document.documentElement.setAttribute("data-theme", this.checked ? "dark" : "light"),
        function(e) {
          window.localStorage && window.localStorage.setItem("theme", e)
        }(this.checked ? "dark" : "light"), this.checked ? this.parentElement.classList.add("active") : this.parentElement.classList.remove("active")
    }.bind(e))
  }();
</script>
<div class="body">
<div class="nav-container" data-component="features" data-version="latest">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <button class="nav-menu-toggle" aria-label="Toggle expand/collapse all" style="display: none"></button>
    <h3 class="title"><a href="../index.html">Vulkan Feature Descriptions</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../index.html">Vulkan Roadmap and Feature Descriptions</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="Roadmap.html">Vulkan Roadmap</a>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Feature Descriptions</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_AMDX_shader_enqueue.html">VK_AMDX_shader_enqueue</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_AMD_anti_lag.html">VK_AMD_anti_lag</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_AMD_shader_early_and_late_fragment_tests.html">VK_AMD_shader_early_and_late_fragment_tests</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_ANDROID_external_format_resolve.html">VK_ANDROID_external_format_resolve</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_ARM_render_pass_striped.html">VK_ARM_render_pass_striped</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_attachment_feedback_loop_dynamic_state.html">VK_EXT_attachment_feedback_loop_dynamic_state</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_attachment_feedback_loop_layout.html">VK_EXT_attachment_feedback_loop_layout</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_calibrated_timestamps.html">VK_EXT_calibrated_timestamps</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_depth_bias_control.html">VK_EXT_depth_bias_control</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_depth_clamp_control.html">VK_EXT_depth_clamp_control</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_descriptor_buffer.html">VK_EXT_descriptor_buffer</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_device_fault.html">VK_EXT_device_fault</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_device_generated_commands.html">VK_EXT_device_generated_commands</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_dynamic_rendering_unused_attachments.html">VK_EXT_dynamic_rendering_unused_attachments</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_extended_dynamic_state3.html">VK_EXT_extended_dynamic_state3</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_external_memory_acquire_unmodified.html">VK_EXT_external_memory_acquire_unmodified</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_frame_boundary.html">Proposal: <code>VK_EXT_frame_boundary</code></a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_graphics_pipeline_library.html">VK_EXT_graphics_pipeline_library</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_host_image_copy.html">VK_EXT_host_image_copy</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_image_2d_array_of_3d.html">VK_EXT_image_2d_array_of_3d</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_image_compression_control.html">VK_EXT_image_compression_control</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_image_sliced_view_of_3d.html">VK_EXT_image_sliced_view_of_3d</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_layer_settings.html">VK_EXT_layer_settings</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_legacy_dithering.html">VK_EXT_legacy_dithering</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_legacy_vertex_attributes.html">VK_EXT_legacy_vertex_attributes</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_map_memory_placed.html">VK_EXT_map_memory_placed</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_mesh_shader.html">VK_EXT_mesh_shader</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_metal_objects.html">VK_EXT_metal_objects</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_multisampled_render_to_single_sampled.html">VK_EXT_multisampled_render_to_single_sampled</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_mutable_descriptor_type.html">VK_EXT_mutable_descriptor_type</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_non_seamless_cube_map.html">VK_EXT_non_seamless_cube_map</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_opacity_micromap.html">VK_EXT_opacity_micromap</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_pipeline_library_group_handles.html">VK_EXT_pipeline_library_group_handles</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_pipeline_protected_access.html">VK_EXT_pipeline_protected_access</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_present_mode_fifo_latest_ready.html">VK_EXT_present_mode_fifo_latest_ready</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_primitives_generated_query.html">VK_EXT_primitives_generated_query</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_rasterization_order_attachment_access.html">VK_EXT_rasterization_order_attachment_access</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_shader_module_identifier.html">VK_EXT_shader_module_identifier</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_shader_object.html">VK_EXT_shader_object</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_shader_replicated_composites.html">VK_EXT_shader_replicated_composites</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_shader_tile_image.html">VK_EXT_shader_tile_image</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_subpass_merge_feedback.html">VK_EXT_subpass_merge_feedback</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_surface_maintenance1.html">VK_EXT_surface_maintenance1</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_swapchain_maintenance1.html">VK_EXT_swapchain_maintenance1</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_GOOGLE_surfaceless_query.html">VK_GOOGLE_surfaceless_query</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_HUAWEI_cluster_culling_shader.html">VK_HUAWEI_cluster_culling_shader</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_HUAWEI_invocation_mask.html">VK_HUAWEI_invocation_mask</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_compute_shader_derivatives.html">VK_KHR_compute_shader_derivatives</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_cooperative_matrix.html">VK_KHR_cooperative_matrix</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_dynamic_rendering.html">VK_KHR_dynamic_rendering</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_dynamic_rendering_local_read.html">VK_KHR_dynamic_rendering_local_read</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_fragment_shader_barycentric.html">VK_KHR_fragment_shader_barycentric</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_fragment_shading_rate.html">VK_KHR_fragment_shading_rate</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_load_store_op_none.html">VK_KHR_load_store_op_none</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_maintenance5.html">VK_KHR_maintenance5</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_maintenance6.html">VK_KHR_maintenance6</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_maintenance7.html">VK_KHR_maintenance7</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_map_memory2.html">VK_KHR_map_memory2</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_pipeline_binary.html">VK_KHR_pipeline_binary</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_ray_tracing_position_fetch.html">VK_KHR_ray_tracing_position_fetch</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_shader_expect_assume.html">VK_KHR_shader_expect_assume</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_shader_float_controls2.html">VK_KHR_shader_float_controls2</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_shader_integer_dot_product.html">VK_KHR_shader_integer_dot_product</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_shader_maximal_reconvergence.html">VK_KHR_shader_maximal_reconvergence</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_shader_quad_control.html">VK_KHR_shader_quad_control</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_shader_relaxed_extended_instruction.html">VK_KHR_shader_relaxed_extended_instruction</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_shader_subgroup_rotate.html">Subgroup rotation instruction</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_vertex_attribute_divisor.html">VK_KHR_vertex_attribute_divisor</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_video_decode_av1.html">VK_KHR_video_decode_av1</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_video_decode_h264.html">VK_KHR_video_decode_h264</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_video_decode_h265.html">VK_KHR_video_decode_h265</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_video_decode_queue.html">VK_KHR_video_decode_queue</a>
  </li>
  <li class="nav-item is-current-page" data-depth="2">
    <a class="nav-link" href="VK_KHR_video_encode_av1.html">VK_KHR_video_encode_av1</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_video_encode_h264.html">VK_KHR_video_encode_h264</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_video_encode_h265.html">VK_KHR_video_encode_h265</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_video_encode_quantization_map.html">VK_KHR_video_encode_quantization_map</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_video_encode_queue.html">VK_KHR_video_encode_queue</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_video_maintenance1.html">VK_KHR_video_maintenance1</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_video_queue.html">VK_KHR_video_queue</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_LUNARG_direct_driver_loading.html">VK_LUNARG_direct_driver_loading</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_MSFT_layered_driver.html">VK_MSFT_layered_driver</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_NV_cooperative_matrix2.html">VK_NV_cooperative_matrix2</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_NV_display_stereo.html">VK_NV_display_stereo</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_NV_ray_tracing_validation.html">VK_NV_ray_tracing_validation</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_QCOM_image_processing.html">VK_QCOM_image_processing</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_QCOM_tile_properties.html">VK_QCOM_tile_properties</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_VERSION_1_4.html">Vulkan 1.4</a>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Vulkan Feature Descriptions</span>
    <span class="version">latest</span>
  </div>
  <ul class="components">
    <li class="component">
      <div class="title"><a href="../../../../tutorial/latest/00_Introduction.html">Khronos Vulkan Tutorial</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../../tutorial/latest/00_Introduction.html">latest</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../../../glsl/latest/index.html">OpenGL Shading Language Specification</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../../glsl/latest/index.html">latest</a>
        </li>
      </ul>
    </li>
    <li class="component is-current">
      <div class="title"><a href="../index.html">Vulkan Feature Descriptions</a></div>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="../index.html">latest</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../../../guide/latest/index.html">Vulkan Guide</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../../guide/latest/index.html">latest</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../../../samples/latest/README.html">Vulkan Samples</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../../samples/latest/README.html">latest</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../../../spec/latest/index.html">Vulkan Specification</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../../spec/latest/index.html">latest</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../../../../spec/latest/index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../index.html">Vulkan Feature Descriptions</a></li>
    <li>Feature Descriptions</li>
    <li><a href="VK_KHR_video_encode_av1.html">VK_KHR_video_encode_av1</a></li>
  </ul>
</nav>
</div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">VK_KHR_video_encode_av1</h1>
<div id="toc" class="toc">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_problem_statement">1. Problem Statement</a></li>
<li><a href="#_solution_space">2. Solution Space</a></li>
<li><a href="#_proposal">3. Proposal</a>
<ul class="sectlevel2">
<li><a href="#_av1_specific_nomenclature">3.1. AV1 Specific Nomenclature</a></li>
<li><a href="#_video_std_headers">3.2. Video Std Headers</a></li>
<li><a href="#_av1_encode_profiles">3.3. AV1 Encode Profiles</a></li>
<li><a href="#_av1_encode_capabilities">3.4. AV1 Encode Capabilities</a></li>
<li><a href="#_av1_encode_parameter_sets">3.5. AV1 Encode Parameter Sets</a></li>
<li><a href="#_av1_encoding_parameters">3.6. AV1 Encoding Parameters</a></li>
<li><a href="#_av1_reference_management">3.7. AV1 Reference Management</a></li>
<li><a href="#_av1_rate_control">3.8. AV1 Rate Control</a></li>
</ul>
</li>
<li><a href="#_examples">4. Examples</a>
<ul class="sectlevel2">
<li><a href="#_select_queue_family_with_av1_encode_support">4.1. Select queue family with AV1 encode support</a></li>
<li><a href="#_check_support_and_query_the_capabilities_for_an_av1_encode_profile">4.2. Check support and query the capabilities for an AV1 encode profile</a></li>
<li><a href="#_create_av1_video_session_parameters_objects">4.3. Create AV1 video session parameters objects</a></li>
<li><a href="#_record_av1_encode_operation_producing_a_key_frame_that_is_also_set_up_as_a_reference">4.4. Record AV1 encode operation producing a key frame that is also set up as a reference</a></li>
<li><a href="#_record_av1_encode_operation_producing_an_inter_frame_with_a_single_forward_reference">4.5. Record AV1 encode operation producing an inter frame with a single forward reference</a></li>
<li><a href="#_record_av1_encode_operation_producing_an_inter_frame_with_a_forward_and_a_backward_reference">4.6. Record AV1 encode operation producing an inter frame with a forward and a backward reference</a></li>
<li><a href="#_change_the_rate_control_configuration_of_an_av1_encode_session_with_optional_av1_controls">4.7. Change the rate control configuration of an AV1 encode session with optional AV1 controls</a></li>
</ul>
</li>
<li><a href="#_issues">5. Issues</a>
<ul class="sectlevel2">
<li><a href="#_resolved_in_what_form_should_codec_specific_parameters_be_provided">5.1. RESOLVED: In what form should codec-specific parameters be provided?</a></li>
<li><a href="#_resolved_what_are_the_requirements_for_the_codec_specific_input_parameters">5.2. RESOLVED: What are the requirements for the codec-specific input parameters?</a></li>
<li><a href="#_resolved_are_obu_extension_headers_generated_by_the_implementation_when_multiple_temporal_or_spatial_layers_are_used">5.3. RESOLVED: Are OBU extension headers generated by the implementation when multiple temporal or spatial layers are used?</a></li>
<li><a href="#_resolved_what_codec_specific_parameters_are_guaranteed_to_not_be_overridden_by_implementations">5.4. RESOLVED: What codec-specific parameters are guaranteed to not be overridden by implementations?</a></li>
<li><a href="#_resolved_how_is_reference_picture_setup_requested_for_av1_encode_operations">5.5. RESOLVED: How is reference picture setup requested for AV1 encode operations?</a></li>
<li><a href="#_resolved_should_we_have_separate_rate_control_configuration_parameters_quantizer_indices_frame_sizes_for_each_av1_prediction_mode">5.6. RESOLVED: Should we have separate rate control configuration parameters (quantizer indices, frame sizes) for each AV1 prediction mode?</a></li>
<li><a href="#_resolved_how_can_the_application_indicate_the_use_of_a_primary_ref_frame_that_is_used_for_cdf_data_but_not_for_picture_prediction">5.7. RESOLVED: How can the application indicate the use of a <code>primary_ref_frame</code> that is used for CDF data but not for picture prediction?</a></li>
<li><a href="#_resolved_why_there_is_no_maxunidirectionalcompoundgroup2referencecount_capability">5.8. RESOLVED: Why there is no <code>maxUnidirectionalCompoundGroup2ReferenceCount</code> capability?</a></li>
<li><a href="#_resolved_why_are_implementations_allowed_to_override_the_coded_resolution">5.9. RESOLVED: Why are implementations allowed to override the coded resolution?</a></li>
</ul>
</li>
</ul>
</div>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>This document outlines a proposal to enable performing AV1 video encode operations in Vulkan.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_problem_statement"><a class="anchor" href="#_problem_statement"></a>1. Problem Statement</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The <code>VK_KHR_video_queue</code> extension introduces support for video coding operations and the <code>VK_KHR_video_encode_queue</code> extension further extends this with APIs specific to video encoding.</p>
</div>
<div class="paragraph">
<p>The goal of this proposal is to build upon this infrastructure to introduce support for encoding elementary video stream sequences compliant with the AV1 video compression standard.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_solution_space"><a class="anchor" href="#_solution_space"></a>2. Solution Space</h2>
<div class="sectionbody">
<div class="paragraph">
<p>As the <code>VK_KHR_video_queue</code> and <code>VK_KHR_video_encode_queue</code> extensions already laid down the architecture for how codec-specific video encode extensions need to be designed, this extension only needs to define the APIs to provide the necessary codec-specific parameters at various points during the use of the codec-independent APIs. In particular:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>APIs allowing to specify AV1 sequence headers to be stored in video session parameters objects</p>
</li>
<li>
<p>APIs allowing to specify AV1 information specific to the encoded picture</p>
</li>
<li>
<p>APIs allowing to specify AV1 reference picture information specific to the active reference pictures and optional reconstructed picture used in video encode operations</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Codec-specific encoding parameters are specified by the application through custom definitions provided by a video std header dedicated to AV1 video encoding.</p>
</div>
<div class="paragraph">
<p>This proposal uses the common AV1 definitions first utilized by the <code>VK_KHR_video_decode_av1</code> extension and augments it with another video std header specific to AV1 encoding. Thus this extension uses the following video std headers:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>vulkan_video_codec_av1std</code> - containing common definitions for all AV1 video coding operations</p>
</li>
<li>
<p><code>vulkan_video_codec_av1std_encode</code> - containing definitions specific to AV1 video encoding operations</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>These headers can be included as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">#include &lt;vk_video/vulkan_video_codec_av1std.h&gt;
#include &lt;vk_video/vulkan_video_codec_av1std_encode.h&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_proposal"><a class="anchor" href="#_proposal"></a>3. Proposal</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_av1_specific_nomenclature"><a class="anchor" href="#_av1_specific_nomenclature"></a>3.1. AV1 Specific Nomenclature</h3>
<div class="paragraph">
<p>AV1 supports four types of prediction modes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Intra-only prediction - when the used frame type is <code>KEY_FRAME</code> or <code>INTRA_ONLY_FRAME</code></p>
</li>
<li>
<p>Single reference prediction - when the frame type is <code>INTER_FRAME</code> or <code>SWITCH_FRAME</code> and <code>reference_select</code> is zero</p>
</li>
<li>
<p>Unidirectional compound prediction - when the frame type is <code>INTER_FRAME</code> or <code>SWITCH_FRAME</code> and <code>reference_select</code> is one, and the active references are from the same reference frame group</p>
</li>
<li>
<p>Bidirectional compound prediction - when the frame type is <code>INTER_FRAME</code> or <code>SWITCH_FRAME</code> and <code>reference_select</code> is one, and the active references are from different reference frame groups</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>AV1 reference prediction modes do not restrict the direction of prediction, however, rate control normally treats individual frames differently based on it. In order to facilitate the grouping of frames based on the used prediction direction from the perspective of rate control, this proposal introduces a separate rate control group enum to indicate the direction of prediction for individual frames in order to apply rate control appropriately:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>VK_VIDEO_ENCODE_AV1_RATE_CONTROL_GROUP_INTRA_KHR</code> is expected to be specified by the application for frames using intra-only prediction, typically when encoding frames of type <code>KEY_FRAME</code> or <code>INTRA_ONLY_FRAME</code></p>
</li>
<li>
<p><code>VK_VIDEO_ENCODE_AV1_RATE_CONTROL_GROUP_PREDICTIVE_KHR</code> is expected to be specified by the application for frames that only have forward references in display order</p>
</li>
<li>
<p><code>VK_VIDEO_ENCODE_AV1_RATE_CONTROL_GROUP_BIPREDICTIVE_KHR</code> is expected to be specified by the application for frames that have backward references in display order</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>These rate control groups categorize frames analogously to the frame types I, P, and B used in other video compression standards, respectively.</p>
</div>
</div>
<div class="sect2">
<h3 id="_video_std_headers"><a class="anchor" href="#_video_std_headers"></a>3.2. Video Std Headers</h3>
<div class="paragraph">
<p>This extension uses the new <code>vulkan_video_codec_av1std_encode</code> video std header. Implementations must always support at least version 1.0.0 of this video std header.</p>
</div>
</div>
<div class="sect2">
<h3 id="_av1_encode_profiles"><a class="anchor" href="#_av1_encode_profiles"></a>3.3. AV1 Encode Profiles</h3>
<div class="paragraph">
<p>This extension introduces the new video codec operation <code>VK_VIDEO_CODEC_OPERATION_ENCODE_AV1_BIT_KHR</code>. This flag can be used to check whether a particular queue family supports encoding AV1 content, as returned in <code>VkQueueFamilyVideoPropertiesKHR</code>.</p>
</div>
<div class="paragraph">
<p>An AV1 encode profile can be defined through a <code>VkVideoProfileInfoKHR</code> structure using this new video codec operation and by including the following new codec-specific profile information structure in the <code>pNext</code> chain:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">typedef struct VkVideoEncodeAV1ProfileInfoKHR {
    VkStructureType                              sType;
    const void*                                  pNext;
    StdVideoAV1Profile                           stdProfile;
} VkVideoEncodeAV1ProfileInfoKHR;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>stdProfile</code> specifies the AV1 profile.</p>
</div>
</div>
<div class="sect2">
<h3 id="_av1_encode_capabilities"><a class="anchor" href="#_av1_encode_capabilities"></a>3.4. AV1 Encode Capabilities</h3>
<div class="paragraph">
<p>Applications need to include the following new structure in the <code>pNext</code> chain of <code>VkVideoCapabilitiesKHR</code> when calling the <code>vkGetPhysicalDeviceVideoCapabilitiesKHR</code> command to retrieve the capabilities specific to AV1 video encoding:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">typedef struct VkVideoEncodeAV1CapabilitiesKHR {
    VkStructureType                        sType;
    void*                                  pNext;
    VkVideoEncodeAV1CapabilityFlagsKHR     flags;
    StdVideoAV1Level                       maxLevel;
    VkExtent2D                             codedPictureAlignment;
    VkExtent2D                             maxTiles;
    VkExtent2D                             minTileSize;
    VkExtent2D                             maxTileSize;
    VkVideoEncodeAV1SuperblockSizeFlagsKHR superblockSizes;
    uint32_t                               maxSingleReferenceCount;
    uint32_t                               singleReferenceNameMask;
    uint32_t                               maxUnidirectionalCompoundReferenceCount;
    uint32_t                               maxUnidirectionalCompoundGroup1ReferenceCount;
    uint32_t                               unidirectionalCompoundReferenceNameMask;
    uint32_t                               maxBidirectionalCompoundReferenceCount;
    uint32_t                               maxBidirectionalCompoundGroup1ReferenceCount;
    uint32_t                               maxBidirectionalCompoundGroup2ReferenceCount;
    uint32_t                               bidirectionalCompoundReferenceNameMask;
    uint32_t                               maxTemporalLayers;
    uint32_t                               maxSpatialLayers;
    uint32_t                               maxOperatingPoints;
    uint32_t                               minQIndex;
    uint32_t                               maxQIndex;
    VkBool32                               prefersGopRemainingFrames;
    VkBool32                               requiresGopRemainingFrames;
    VkVideoEncodeAV1StdFlagsKHR            stdSyntaxFlags;
} VkVideoEncodeAV1CapabilitiesKHR;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>flags</code> indicates support for various AV1 encoding capabilities:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>VK_VIDEO_ENCODE_AV1_CAPABILITY_PER_RATE_CONTROL_GROUP_MIN_MAX_Q_INDEX_BIT_KHR</code> - support for using different min/max quantizer index values based on the rate control group specified for the frame when rate control is enabled</p>
</li>
<li>
<p><code>VK_VIDEO_ENCODE_AV1_CAPABILITY_GENERATE_OBU_EXTENSION_HEADER_BIT_KHR</code> - support for generating OBU extension header</p>
</li>
<li>
<p><code>VK_VIDEO_ENCODE_AV1_CAPABILITY_PRIMARY_REFERENCE_CDF_ONLY_BIT_KHR</code> - support for using the reference frame indicated by <code>primary_ref_frame</code> only for CDF data reference</p>
</li>
<li>
<p><code>VK_VIDEO_ENCODE_AV1_CAPABILITY_FRAME_SIZE_OVERRIDE_BIT_KHR</code> - support for setting the <code>frame_size_override_flag</code> and encoding frames with a size that is different than the frame size indicated by the <code>max_frame_width_minus_1</code> and <code>max_frame_height_minus_1</code> parameters of the active sequence header</p>
</li>
<li>
<p><code>VK_VIDEO_ENCODE_AV1_CAPABILITY_MOTION_VECTOR_SCALING_BIT_KHR</code> - support for motion vector scaling and thus allow using frames with different resolutions as reference</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>maxLevel</code> indicates the maximum supported AV1 level.</p>
</div>
<div class="paragraph">
<p><code>codedPictureAlignment</code> indicates implementation limitations for coding resolutions. If the implementation is not able to code the input picture with the requested resolution due to this limitation, the implementation will enlargen the coded picture&#8217;s resolution to be aligned to <code>codedPictureAlignment</code>.</p>
</div>
<div class="paragraph">
<p>The fields of <code>maxTiles</code> indicate the maximum number of supported AV1 tile columns and rows, respectively.</p>
</div>
<div class="paragraph">
<p><code>minTileSize</code> and <code>maxTileSize</code> indicate the minimum and maximum supported AV1 tile extents, respectively.</p>
</div>
<div class="paragraph">
<p><code>superblockSizes</code> is a bitmask that indicates the set of superblock sizes supported by the implementation.</p>
</div>
<div class="paragraph">
<p><code>maxSingleReferenceCount</code>, <code>maxUnidirectionalCompoundReferenceCount</code>, and <code>maxBidirectionalCompoundReferenceCount</code> indicate the maximum number of reference frames that the encoded frames can refer to depending on the used prediction mode, respectively.</p>
</div>
<div class="paragraph">
<p><code>maxUnidirectionalCompoundGroup1ReferenceCount</code> indicates the maximum number of reference frames from AV1 reference group 1 for unidirectional compound prediction mode.</p>
</div>
<div class="paragraph">
<p><code>maxBidirectionalCompoundGroup1ReferenceCount</code> and <code>maxBidirectionalCompoundGroup2ReferenceCount</code> indicate the maximum number of reference frames from each AV1 reference frame group for bidirectional compound prediction mode.</p>
</div>
<div class="paragraph">
<p>These reference count capabilities do not restrict the number of references the application can include in the active reference list as, in practice, implementations may restrict the effective number of used references based on the encoded content and/or the capabilities of the encoder implementation. However, they do indirectly indicate whether encoding pictures with particular prediction modes are supported. In particular, if one of these capabilities is zero, then the corresponding prediction mode is not supported.</p>
</div>
<div class="paragraph">
<p><code>singleReferenceNameMask</code>, <code>unidirectionalCompoundReferenceNameMask</code>, and <code>bidirectionalCompoundReferenceNameMask</code> indicate the set of AV1 reference names that can be used with the corresponding prediction modes for picture prediction, respectively.</p>
</div>
<div class="paragraph">
<p>These reference mask capabilities indicate the set of supported AV1 reference names. In practice, they indicate which elements of <code>VkVideoEncodeAV1PictureInfoKHR::referenceNameSlotIndices</code> can be used by the implementation, as discussed later. It is important to note that each bit in these masks corresponds to the indices of <code>referenceNameSlotIndices[]</code> whose elements start with specifying the DPB slot index for the <code>LAST_FRAME</code> reference, so each bit <code>i</code> in these masks indicate whether <code>referenceNameSlotIndices[i]</code> can be used by the implementation, and correspond to the AV1 reference name <code>LAST_FRAME + i</code>. Furthermore, if an AV1 reference name is only used as CDF data reference for the primary reference frame, then the corresponding bit does not have to be supported in the reference name mask capability of the used prediction mode, as such CDF-only references are not used for picture prediction.</p>
</div>
<div class="paragraph">
<p>Similar to the reference count capabilities, these reference mask capabilities do not restrict the reference names the application can specify reference pictures for. However, it is required for the application to specify at least the minimum set of appropriate references per the used prediction mode. In particular:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>When single reference prediction mode is used, <code>referenceNameSlotIndices[]</code> must have at least one element set to a valid DPB slot index and that AV1 reference name has to be supported, as indicated by <code>singleReferenceNameMask</code></p>
</li>
<li>
<p>When unidirectional compound prediction mode is used, <code>referenceNameSlotIndices[]</code> must have at least two elements set to a valid DPB slot index (according to the AV1 reference name combination related limitations described by the AV1 specification for unidirectional compound prediction) and those AV1 reference names have to be supported, as indicated by <code>unidirectionalCompoundReferenceNameMask</code></p>
</li>
<li>
<p>When bidirectional compound prediction mode is used, <code>referenceNameSlotIndices[]</code> must have at least one element set to a valid DPB slot index for each AV1 reference group and those AV1 reference names have to be supported, as indicated by <code>bidirectionalCompoundReferenceNameMask</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>maxTemporalLayers</code> and <code>maxSpatialLayers</code> indicate the number of supported AV1 temporal and spatial layers, respectively.</p>
</div>
<div class="paragraph">
<p><code>maxOperatingPoints</code> indicate the number of supported AV1 operating points that can be specified in a sequence header.</p>
</div>
<div class="paragraph">
<p><code>minQIndex</code> and <code>maxQIndex</code> indicate the supported range of quantizer index values that can be used in the rate control configurations or as the constant quantizer index to be used when rate control is disabled.</p>
</div>
<div class="paragraph">
<p><code>prefersGopRemainingFrames</code> and <code>requiresGopRemainingFrames</code> indicate whether the implementation prefers or requires, respectively, that the application tracks the remaining number of frames (for each rate control group) in the current GOP (group of pictures), as some implementations may need this information for the accurate operation of their rate control algorithm.</p>
</div>
<div class="paragraph">
<p><code>stdSyntaxFlags</code> contains a set of flags that provide information to the application about which video std parameters or parameter values are supported to be used directly as specified by the application. These flags do not restrict what video std parameter values the application can specify, rather, they provide guarantees about respecting those.</p>
</div>
</div>
<div class="sect2">
<h3 id="_av1_encode_parameter_sets"><a class="anchor" href="#_av1_encode_parameter_sets"></a>3.5. AV1 Encode Parameter Sets</h3>
<div class="paragraph">
<p>The use of video session parameters objects is mandatory when encoding AV1 video streams. Applications need to include the following new structure in the <code>pNext</code> chain of <code>VkVideoSessionParametersCreateInfoKHR</code> when creating video session parameters objects for AV1 encode use, to specify the sequence header data of the created object:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">typedef struct VkVideoEncodeAV1SessionParametersCreateInfoKHR {
    VkStructureType                             sType;
    const void*                                 pNext;
    const StdVideoAV1SequenceHeader*            pStdSequenceHeader;
    const StdVideoEncodeAV1DecoderModelInfo*    pStdDecoderModelInfo;
    uint32_t                                    stdOperatingPointCount;
    const StdVideoEncodeAV1OperatingPointInfo*  pStdOperatingPoints;
} VkVideoEncodeAVSessionParametersCreateInfoKHR;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>pStdSequenceHeader</code> specifies the AV1 sequence header to store in the created video session parameters object. As AV1 encoding requires additional sequence parameters compared to AV1 decoding, <code>pStdDecoderModelInfo</code> can be used to specify optional decoder model information, and the <code>pStdOperatingPoints</code> array can be used to specify per operating point parameters.</p>
</div>
<div class="paragraph">
<p>As AV1 encode video session parameters objects can only store a single AV1 sequence header, they do not support updates using the <code>vkUpdateVideoSessionParametersKHR</code> command. Applications have to create a new video session parameters object for each new sequence header they intend to encode with.</p>
</div>
<div class="paragraph">
<p>As implementations can override parameters in the sequence header stored in video session parameters objects, as described in the proposal for <code>VK_KHR_video_encode_queue</code>, the application has to use the <code>vkGetEncodedVideoSessionParametersKHR</code> command to retrieve information about or the data of the encoded sequence header. As AV1 encode video session parameters objects can only store a single AV1 sequence header, no new input or output structures needed to be specified for the <code>vkGetEncodedVideoSessionParametersKHR</code> command in this proposal.</p>
</div>
<div class="paragraph">
<p>When requesting encoded bitstream data using the <code>vkGetEncodedVideoSessionParametersKHR</code> command, the output host data buffer will be filled with the encoded bitstream of the requested AV1 sequence header as an OBU with <code>obu_type</code> <code>OBU_SEQUENCE_HEADER</code>.</p>
</div>
<div class="paragraph">
<p>As described in great detail in the proposal for the <code>VK_KHR_video_encode_queue</code> extension, the application may have the option to encode the parameters otherwise stored in video session parameters object on its own. However, this may not result in a compliant bitstream if the implementation applied overrides to the sequence header, thus it is generally recommended for applications to use the encoded parameter set data retrieved using the <code>vkGetEncodedVideoSessionParametersKHR</code> command.</p>
</div>
</div>
<div class="sect2">
<h3 id="_av1_encoding_parameters"><a class="anchor" href="#_av1_encoding_parameters"></a>3.6. AV1 Encoding Parameters</h3>
<div class="paragraph">
<p>Encode parameters specific to AV1 need to be provided by the application through the <code>pNext</code> chain of <code>VkVideoEncodeInfoKHR</code>, using the following new structure:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">typedef struct VkVideoEncodeAV1PictureInfoKHR {
    VkStructureType                             sType;
    const void*                                 pNext;
    VkVideoEncodeAV1PredictionModeKHR           predictionMode;
    VkVideoEncodeAV1RateControlGroupKHR         rateControlGroup;
    const StdVideoEncodeAV1PictureInfo*         pStdPictureInfo;
    int32_t                                     referenceNameSlotIndices[VK_MAX_VIDEO_AV1_REFERENCES_PER_FRAME_KHR];
    VkBool32                                    primaryReferenceCdfOnly;
    VkBool32                                    generateObuExtensionHeader;
} VkVideoEncodeAV1PictureInfoKHR;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>predictionMode</code> specifies the used AV1 prediction mode for the frame and can have one of the following values:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>VK_VIDEO_ENCODE_AV1_PREDICTION_MODE_INTRA_ONLY_KHR</code> - the frame is encoded with intra-only prediction, used when encoding key frames and intra-only frames (all AV1 mode info blocks will be encoded with intra-only prediction)</p>
</li>
<li>
<p><code>VK_VIDEO_ENCODE_AV1_PREDICTION_MODE_SINGLE_REFERENCE_KHR</code> - the frame is encoded with single reference prediction (individual AV1 mode info blocks may use intra-only or single reference prediction)</p>
</li>
<li>
<p><code>VK_VIDEO_ENCODE_AV1_PREDICTION_MODE_UNIDIRECTIONAL_COMPOUND_KHR</code> - the frame is encoded with unidirectional compound prediction (individual AV1 mode info blocks may use intra-only, single reference, or unidirectional compound prediction)</p>
</li>
<li>
<p><code>VK_VIDEO_ENCODE_AV1_PREDICTION_MODE_BIDIRECTIONAL_COMPOUND_KHR</code> - the frame is encoded with bidirectional compound prediction (individual AV1 mode info blocks may use intra-only, single reference, unidirectional compound, or bidirectional compound prediction)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>rateControlGroup</code> specifies which rate control group does the encoded frame fall into. Many rate control parameters can have different values for each rate control group (e.g. min/max quantizer index). This parameter indicates which set of rate control parameters should the implementation&#8217;s rate control algorithm apply to the encoded frame.</p>
</div>
<div class="paragraph">
<p><code>pStdPictureInfo</code> points to the codec-specific encode parameters defined in the <code>vulkan_video_codec_av1std_encode</code> video std header (including the AV1 frame header parameters).</p>
</div>
<div class="paragraph">
<p>The <code>referenceNameSlotIndices</code> array provides a mapping from AV1 reference names to the DPB slot indices currently associated with the used reference picture resources. Multiple AV1 reference names may refer to the same DPB slot, while unused AV1 reference names are indicated by specifying a negative DPB slot index in the corresponding element of the array. As this array only provides a mapping for reference pictures used for inter-frame coding, for a given AV1 reference name <code>frame</code> (as defined in the enumeration type <code>StdVideoAV1ReferenceName</code>) the corresponding DPB slot index is specified in <code>referenceNameSlotIndices[frame - STD_VIDEO_AV1_REFERENCE_NAME_LAST_FRAME]</code>. Further details are provided about the AV1 reference management model later, in a dedicated section of this proposal.</p>
</div>
<div class="paragraph">
<p>If <code>primaryReferenceCdfOnly</code> is set to <code>VK_TRUE</code>, the primary reference indicated by the <code>primary_ref_frame</code> codec parameter will be used only for CDF data reference but not for picture prediction.</p>
</div>
<div class="paragraph">
<p>If <code>generateObuExtensionHeader</code> is set to <code>VK_TRUE</code>, the generated bitstream will include OBU extension headers.</p>
</div>
<div class="paragraph">
<p>The active sequence header is the one stored in the bound video session parameters object.</p>
</div>
<div class="paragraph">
<p>Picture information specific to AV1 for the active reference pictures and the optional reconstructed picture need to be provided by the application through the <code>pNext</code> chain of corresponding elements of <code>VkVideoEncodeInfoKHR::pReferenceSlots</code> and the <code>pNext</code> chain of <code>VkVideoEncodeInfoKHR::pSetupReferenceSlot</code>, respectively, using the following new structure:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">typedef struct VkVideoEncodeAV1DpbSlotInfoKHR {
    VkStructureType                           sType;
    const void*                               pNext;
    const StdVideoEncodeAV1ReferenceInfo*     pStdReferenceInfo;
} VkVideoEncodeAV1DpbSlotInfoKHR;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>pStdReferenceInfo</code> points to the codec-specific reference picture parameters defined in the <code>vulkan_video_codec_av1std_encode</code> video std header.</p>
</div>
<div class="paragraph">
<p>It is the application&#8217;s responsibility to specify codec-specific parameters that are compliant to the rules defined by the AV1 video compression standard. While it is not illegal, from the API usage&#8217;s point of view, to specify non-compliant inputs, they may cause the video encode operation to complete unsuccessfully and will cause the output bitstream and the reconstructed picture, if one is specified, to have undefined contents after the execution of the operation.</p>
</div>
<div class="paragraph">
<p>Implementations may override some of these parameters in order to conform to any restrictions of the encoder implementation, but that will not affect the overall operation of the encoding. The application has the option to also opt-in for additional optimizing overrides that can result in better performance or efficiency tailored to the usage scenario by creating the video session with the new <code>VK_VIDEO_SESSION_CREATE_ALLOW_ENCODE_PARAMETER_OPTIMIZATIONS_BIT_KHR</code> flag.</p>
</div>
<div class="paragraph">
<p>For more information about individual AV1 bitstream syntax elements, derived values, and, in general, how to interpret these parameters, please refer to the corresponding sections of the <a href="https://aomediacodec.github.io/av1-spec/av1-spec.pdf">AV1 Specification</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_av1_reference_management"><a class="anchor" href="#_av1_reference_management"></a>3.7. AV1 Reference Management</h3>
<div class="paragraph">
<p>The AV1 video compression standard supports each frame to reference up to 7 + 1 reference pictures for sample prediction. The seven "real" reference pictures are identified with so called AV1 reference names (<code>LAST_FRAME</code>, <code>LAST2_FRAME</code>, <code>LAST3_FRAME</code>, <code>GOLDEN_FRAME</code>, <code>BWDREF_FRAME</code>, <code>ALTREF2_FRAME</code>, and <code>ALTREF_FRAME</code>) identifying different types of forward and backward references. Each AV1 reference name has associated semantics that affect how the reference picture data is used for inter-frame sample prediction. In addition, there is a special AV1 reference name called <code>INTRA_FRAME</code> that corresponds to the currently decoded frame used for intra-frame sample prediction.</p>
</div>
<div class="paragraph">
<p>The AV1 decoder model also incorporates the concept of a VBI which has 8 slots and maintains the set of reference pictures and associated metadata that can be included in the list of active reference pictures when decoding subsequent frames. The reference frame update process detailed in section 7.20 of the AV1 specification allows associating multiple VBI slots with the same reference picture and logically replicating the metadata associated with the activated reference picture across these VBI slots.</p>
</div>
<div class="paragraph">
<p>The reference names used during encoding is primarily dicated by the non-negative elements of <code>VkVideoEncodeAV1PictureInfoKHR::referenceNameSlotIndices</code> which refer to the DPB slot index of an active reference picture. However, additional AV1 syntax elements need to be specified in line with that, like the <code>ref_frame_idx[]</code> array that specifies the AV1 VBI slot indices corresponding to the AV1 reference names. VBI management and the correctness of all other reference related video std parameters are entirely the responsibility of the application, so the input video std parameters must be in line with the requirements of the AV1 specification in order for the resulting bitstream to be compliant with it.</p>
</div>
<div class="paragraph">
<p>The implementation may choose to reduce the set of used AV1 reference names, as needed based on the reference count and reference mask capabilities discussed earlier, or as decided by the implementation (e.g. for performance or quality reasons).</p>
</div>
</div>
<div class="sect2">
<h3 id="_av1_rate_control"><a class="anchor" href="#_av1_rate_control"></a>3.8. AV1 Rate Control</h3>
<div class="paragraph">
<p>This proposal adds a set of optional rate control parameters specific to AV1 encoding that provide additional guidance to the implementation&#8217;s rate control algorithm.</p>
</div>
<div class="paragraph">
<p>When rate control is not disabled and not set to implementation-default behavior, the application can include the following new structure in the <code>pNext</code> chain of <code>VkVideoEncodeRateControlInfoKHR</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">typedef struct VkVideoEncodeAV1RateControlInfoKHR {
    VkStructureType                         sType;
    const void*                             pNext;
    VkVideoEncodeAV1RateControlFlagsKHR     flags;
    uint32_t                                gopFrameCount;
    uint32_t                                keyFramePeriod;
    uint32_t                                consecutiveBipredictiveFrameCount;
    uint32_t                                temporalLayerCount;
} VkVideoEncodeAV1RateControlInfoKHR;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>flags</code> can include one or more of the following flags:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>VK_VIDEO_ENCODE_AV1_RATE_CONTROL_REGULAR_GOP_BIT_KHR</code> can be used to indicate that the application intends to use a regular GOP structure according to the parameters specified in <code>gopFrameCount</code> and <code>keyFramePeriod</code></p>
</li>
<li>
<p><code>VK_VIDEO_ENCODE_AV1_RATE_CONTROL_TEMPORAL_LAYER_PATTERN_DYADIC_BIT_KHR</code> can be used to indicate that the application intends to follow a dyadic temporal layer pattern when using multiple temporal layers</p>
</li>
<li>
<p><code>VK_VIDEO_ENCODE_AV1_RATE_CONTROL_REFERENCE_PATTERN_FLAT_BIT_KHR</code> can be used to indicate that the application intends to follow a flat reference pattern in the GOP where each predictive frame uses the last non-bipredictive frame as reference, and each bipredictive frame uses the last and next non-bipredictive frame as forward and backward references, respectively</p>
</li>
<li>
<p><code>VK_VIDEO_ENCODE_AV1_RATE_CONTROL_REFERENCE_PATTERN_DYADIC_BIT_KHR</code> can be used to indicate that the application intends to follow a dyadic reference pattern</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>gopFrameCount</code>, <code>keyFramePeriod</code>, and <code>consecutiveBipredictiveFrameCount</code> specify the GOP size, key frame period, and the number of consecutive frames encoded with <code>VK_VIDEO_ENCODE_AV1_RATE_CONTROL_GROUP_BIPREDICTIVE_KHR</code> between frames using other rate control groups, respectively, that define the typical structure of the GOP the implementation&#8217;s rate control algorithm should expect. If <code>VK_VIDEO_ENCODE_AV1_RATE_CONTROL_REGULAR_GOP_BIT_KHR</code> is also specified in <code>flags</code>, the implementation will expect all GOPs to follow this structure, while otherwise it may assume that the application will diverge from these values from time to time. If any of these values are zero, then the implementation&#8217;s rate control algorithm will not make any assumptions about the corresponding parameter of the GOP structure.</p>
</div>
<div class="paragraph">
<p><code>temporalLayerCount</code> indicates the number of AV1 temporal layers that the application intends to use and it is expected to match the number of rate control layers when multi-layer rate control is used.</p>
</div>
<div class="paragraph">
<p>The following new structure can be included in the <code>pNext</code> chain of <code>VkVideoEncodeRateControlLayerInfoKHR</code> to specify additional per-rate-control-layer guidance parameters specific to AV1 encode:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">typedef struct VkVideoEncodeAV1RateControlLayerInfoKHR {
    VkStructureType                  sType;
    const void*                      pNext;
    VkBool32                         useMinQIndex;
    VkVideoEncodeAV1QIndexKHR        minQIndex;
    VkBool32                         useMaxQIndex;
    VkVideoEncodeAV1QIndexKHR        maxQIndex;
    VkBool32                         useMaxFrameSize;
    VkVideoEncodeAV1FrameSizeKHR     maxFrameSize;
} VkVideoEncodeAV1RateControlLayerInfoKHR;</code></pre>
</div>
</div>
<div class="paragraph">
<p>When <code>useMinQIndex</code> is set to <code>VK_TRUE</code>, <code>minQIndex</code> specifies the lower bound on the quantizer index values, for each rate control group, that the implementation&#8217;s rate control algorithm should use. Similarly, when <code>useMaxQIndex</code> is set to <code>VK_TRUE</code>, <code>maxQIndex</code> specifies the upper bound on the quantizer index values.</p>
</div>
<div class="paragraph">
<p>When <code>useMaxFrameSize</code> is set to <code>VK_TRUE</code>, <code>maxFrameSize</code> specifies the maximum frame size in bytes, for each rate control group, that the implementation&#8217;s rate control algorithm should target.</p>
</div>
<div class="paragraph">
<p>Some implementations may benefit from or require additional guidance on the remaining number of frames in the currently encoded GOP, as indicated by the <code>prefersGopRemainingFrames</code> and <code>requiresGopRemainingFrames</code> capabilities, respectively. This may be the case either due to the implementation not being able to track the current position of the encoded stream within the GOP, or because the implementation may be able to use this information to better react to dynamic changes to the GOP structure. This proposal solves this by introducing the following new structure that can be included in the <code>pNext</code> chain of <code>VkVideoBeginCodingInfoKHR</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">typedef struct VkVideoEncodeAV1GopRemainingFrameInfoKHR {
    VkStructureType    sType;
    const void*        pNext;
    VkBool32           useGopRemainingFrames;
    uint32_t           gopRemainingIntra;
    uint32_t           gopRemainingPredictive;
    uint32_t           gopRemainingBipredictive;
} VkVideoEncodeAV1GopRemainingFrameInfoKHR;</code></pre>
</div>
</div>
<div class="paragraph">
<p>When <code>useGopRemainingFrames</code> is set to <code>VK_TRUE</code>, the implementation&#8217;s rate control algorithm may use the values specified in <code>gopRemainingIntra</code>, <code>gopRemainingPredictive</code>, and <code>gopRemainingBipredictive</code> as a guidance on the number of remaining frames encoded with the corresponding rate control group in the currently encoded GOP.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_examples"><a class="anchor" href="#_examples"></a>4. Examples</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_select_queue_family_with_av1_encode_support"><a class="anchor" href="#_select_queue_family_with_av1_encode_support"></a>4.1. Select queue family with AV1 encode support</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">uint32_t queueFamilyIndex;
uint32_t queueFamilyCount;

vkGetPhysicalDeviceQueueFamilyProperties2(physicalDevice, &amp;queueFamilyCount, NULL);

VkQueueFamilyProperties2* props = calloc(queueFamilyCount,
    sizeof(VkQueueFamilyProperties2));
VkQueueFamilyVideoPropertiesKHR* videoProps = calloc(queueFamilyCount,
    sizeof(VkQueueFamilyVideoPropertiesKHR));

for (queueFamilyIndex = 0; queueFamilyIndex &lt; queueFamilyCount; ++queueFamilyIndex) {
    props[queueFamilyIndex].sType = VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2;
    props[queueFamilyIndex].pNext = &amp;videoProps[queueFamilyIndex];

    videoProps[queueFamilyIndex].sType = VK_STRUCTURE_TYPE_QUEUE_FAMILY_VIDEO_PROPERTIES_KHR;
}

vkGetPhysicalDeviceQueueFamilyProperties2(physicalDevice, &amp;queueFamilyCount, props);

for (queueFamilyIndex = 0; queueFamilyIndex &lt; queueFamilyCount; ++queueFamilyIndex) {
    if ((props[queueFamilyIndex].queueFamilyProperties.queueFlags &amp; VK_QUEUE_VIDEO_ENCODE_BIT_KHR) != 0 &amp;&amp;
        (videoProps[queueFamilyIndex].videoCodecOperations &amp; VK_VIDEO_CODEC_OPERATION_ENCODE_AV1_BIT_KHR) != 0) {
        break;
    }
}

if (queueFamilyIndex &lt; queueFamilyCount) {
    // Found appropriate queue family
    ...
} else {
    // Did not find a queue family with the needed capabilities
    ...
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_check_support_and_query_the_capabilities_for_an_av1_encode_profile"><a class="anchor" href="#_check_support_and_query_the_capabilities_for_an_av1_encode_profile"></a>4.2. Check support and query the capabilities for an AV1 encode profile</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">VkResult result;

VkVideoEncodeAV1ProfileInfoKHR encodeAV1ProfileInfo = {
    .sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_PROFILE_INFO_KHR,
    .pNext = NULL,
    .stdProfile = STD_VIDEO_AV1_PROFILE_MAIN
};

VkVideoProfileInfoKHR profileInfo = {
    .sType = VK_STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR,
    .pNext = &amp;encodeAV1ProfileInfo,
    .videoCodecOperation = VK_VIDEO_CODEC_OPERATION_ENCODE_AV1_BIT_KHR,
    .chromaSubsampling = VK_VIDEO_CHROMA_SUBSAMPLING_420_BIT_KHR,
    .lumaBitDepth = VK_VIDEO_COMPONENT_BIT_DEPTH_8_BIT_KHR,
    .chromaBitDepth = VK_VIDEO_COMPONENT_BIT_DEPTH_8_BIT_KHR
};

VkVideoEncodeAV1CapabilitiesKHR encodeAV1Capabilities = {
    .sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_CAPABILITIES_KHR,
    .pNext = NULL,
};

VkVideoEncodeCapabilitiesKHR encodeCapabilities = {
    .sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_CAPABILITIES_KHR,
    .pNext = &amp;encodeAV1Capabilities
}

VkVideoCapabilitiesKHR capabilities = {
    .sType = VK_STRUCTURE_TYPE_VIDEO_CAPABILITIES_KHR,
    .pNext = &amp;encodeCapabilities
};

result = vkGetPhysicalDeviceVideoCapabilitiesKHR(physicalDevice, &amp;profileInfo, &amp;capabilities);

if (result == VK_SUCCESS) {
    // Profile is supported, check additional capabilities
    ...
} else {
    // Profile is not supported, result provides additional information about why
    ...
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_create_av1_video_session_parameters_objects"><a class="anchor" href="#_create_av1_video_session_parameters_objects"></a>4.3. Create AV1 video session parameters objects</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">VkVideoSessionParametersKHR videoSessionParams = VK_NULL_HANDLE;

StdVideoAV1SequenceHeader sequenceHeader = {};
StdVideoEncodeAV1DecoderModelInfo decoderModelInfo = {};
// parse and populate sequence header parameters
...
StdVideoEncodeAV1OperatingPointInfo operatingPoints[] = {
    // including operating point info
    ...
};
uint32_t operatingPointCount = sizeof(operatingPoints) / sizeof(operatingPoints[0]);

VkVideoEncodeAV1SessionParametersCreateInfoKHR encodeAV1CreateInfo = {
    .sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_SESSION_PARAMETERS_CREATE_INFO_KHR,
    .pNext = NULL,
    .pStdSequenceHeader = &amp;sequenceHeader,
    .stdOperatingPointCount = operatingPointCount,
    .pStdOperatingPoints = &amp;operatingPoints
};

VkVideoSessionParametersCreateInfoKHR createInfo = {
    .sType = VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_CREATE_INFO_KHR,
    .pNext = &amp;encodeAV1CreateInfo,
    .flags = 0,
    .videoSessionParametersTemplate = VK_NULL_HANDLE,
    .videoSession = videoSession
};

vkCreateVideoSessionParametersKHR(device, &amp;createInfo, NULL, &amp;videoSessionParams);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_record_av1_encode_operation_producing_a_key_frame_that_is_also_set_up_as_a_reference"><a class="anchor" href="#_record_av1_encode_operation_producing_a_key_frame_that_is_also_set_up_as_a_reference"></a>4.4. Record AV1 encode operation producing a key frame that is also set up as a reference</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">// Bound reference resource list provided has to include reconstructed picture resource
vkCmdBeginVideoCodingKHR(commandBuffer, ...);

StdVideoEncodeAV1ReferenceInfo stdReferenceInfo = {};
// Populate AV1 reference picture info for the reconstructed picture
...

VkVideoEncodeAV1DpbSlotInfoKHR encodeAV1DpbSlotInfo = {
    .sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_DPB_SLOT_INFO_KHR,
    .pNext = NULL,
    .pStdReferenceInfo = &amp;stdReferenceInfo
};

VkVideoReferenceSlotInfoKHR setupSlotInfo = {
    .sType = VK_STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_INFO_KHR,
    .pNext = &amp;encodeAV1DpbSlotInfo
    ...
};

StdVideoEncodeAV1PictureInfo stdPictureInfo = {};
// Populate AV1 picture info for the encode input picture
...
stdPictureInfo.frame_type = STD_VIDEO_AV1_FRAME_TYPE_KEY;
...
// Make sure that the reconstructed picture is requested to be set up as reference
stdPictureInfo.refresh_frame_flags = ... // must specify non-zero value indicating the mask of refreshed VBI slots
...

VkVideoEncodeAV1PictureInfoKHR encodeAV1PictureInfo = {
    .sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_PICTURE_INFO_KHR,
    .pNext = NULL,
    .predictionMode = VK_VIDEO_ENCODE_AV1_PREDICTION_MODE_INTRA_ONLY_KHR,
    .rateControlGroup = VK_VIDEO_ENCODE_AV1_RATE_CONTROL_GROUP_INTRA_KHR,
    .pStdPictureInfo = &amp;stdPictureInfo,
    ...
};

// Initialize all elements of referenceNameSlotIndices with negative values
// to indicate that no references are used
for (uint32_t i = 0; i &lt; VK_MAX_VIDEO_AV1_REFERENCES_PER_FRAME_KHR; ++i) {
    encodeAV1PictureInfo.referenceNameSlotIndices[i] = -1;
}

VkVideoEncodeInfoKHR encodeInfo = {
    .sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_INFO_KHR,
    .pNext = &amp;encodeAV1PictureInfo,
    ...
    .pSetupReferenceSlot = &amp;setupSlotInfo,
    ...
};

vkCmdEncodeVideoKHR(commandBuffer, &amp;encodeInfo);

vkCmdEndVideoCodingKHR(commandBuffer, ...);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_record_av1_encode_operation_producing_an_inter_frame_with_a_single_forward_reference"><a class="anchor" href="#_record_av1_encode_operation_producing_an_inter_frame_with_a_single_forward_reference"></a>4.5. Record AV1 encode operation producing an inter frame with a single forward reference</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">// Bound reference resource list provided has to include the used reference picture resource
vkCmdBeginVideoCodingKHR(commandBuffer, ...);

StdVideoEncodeAV1ReferenceInfo stdForwardReferenceInfo = {};
// Populate AV1 reference picture info for the forward referenced picture
...

VkVideoEncodeAV1DpbSlotInfoKHR encodeAV1DpbSlotInfo = {
    .sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_DPB_SLOT_INFO_KHR,
    .pNext = NULL,
    .pStdReferenceInfo = &amp;stdForwardReferenceInfo
};

VkVideoReferenceSlotInfoKHR referenceSlotInfo = {
    .sType = VK_STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_INFO_KHR,
    .pNext = &amp;encodeAV1DpbSlotInfo,
    .slotIndex = ... // DPB slot index of the forward reference picture
    ...
};

StdVideoEncodeAV1PictureInfo stdPictureInfo = {};
// Populate AV1 picture info for the encode input picture
...
stdPictureInfo.frame_type = STD_VIDEO_AV1_FRAME_TYPE_INTER;
...

VkVideoEncodeAV1PictureInfoKHR encodeAV1PictureInfo = {
    .sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_PICTURE_INFO_KHR,
    .pNext = NULL,
    .predictionMode = ... // could be single reference, uni- or bidirectional compound
    .rateControlGroup = VK_VIDEO_ENCODE_AV1_RATE_CONTROL_GROUP_PREDICTIVE_KHR,
    .pStdPictureInfo = &amp;stdPictureInfo,
    ...
};

// Initialize all elements of referenceNameSlotIndices with negative values except the
// reference name that is used as the forward reference (GOLDEN_FRAME in this case)
for (uint32_t i = 0; i &lt; VK_MAX_VIDEO_AV1_REFERENCES_PER_FRAME_KHR; ++i) {
    encodeAV1PictureInfo.referenceNameSlotIndices[i] = -1;
}
encodeAV1PictureInfo.referenceNameSlotIndices[STD_VIDEO_AV1_REFERENCE_NAME_GOLDEN_FRAME - STD_VIDEO_AV1_REFERENCE_NAME_LAST_FRAME] = ...
// NOTE: Alternatively, the application can choose (e.g. for portability reasons) to
// point all elements of the referenceNameSlotIndices array to the DPB slot of the used
// reference picture and let the implementation choose under what AV1 reference name's
// semantics will it use the reference picture during encoding

VkVideoEncodeInfoKHR encodeInfo = {
    .sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_INFO_KHR,
    .pNext = &amp;encodeAV1PictureInfo,
    ...
    .referenceSlotCount = 1,
    .pReferenceSlots = &amp;referenceSlotInfo
};

vkCmdEncodeVideoKHR(commandBuffer, &amp;encodeInfo);

vkCmdEndVideoCodingKHR(commandBuffer, ...);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_record_av1_encode_operation_producing_an_inter_frame_with_a_forward_and_a_backward_reference"><a class="anchor" href="#_record_av1_encode_operation_producing_an_inter_frame_with_a_forward_and_a_backward_reference"></a>4.6. Record AV1 encode operation producing an inter frame with a forward and a backward reference</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">// Bound reference resource list provided has to include the used reference picture resources
vkCmdBeginVideoCodingKHR(commandBuffer, ...);

StdVideoEncodeAV1ReferenceInfo stdFordwardReferenceInfo = {};
// Populate AV1 reference picture info for the forward referenced picture
...

StdVideoEncodeAV1ReferenceInfo stdBackwardReferenceInfo = {};
// Populate AV1 reference picture info for the backward referenced picture
...

VkVideoEncodeAV1DpbSlotInfoKHR encodeAV1DpbSlotInfo[] = {
    {
        .sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_DPB_SLOT_INFO_KHR,
        .pNext = NULL,
        .pStdReferenceInfo = &amp;stdForwardReferenceInfo
    },
    {
        .sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_DPB_SLOT_INFO_KHR,
        .pNext = NULL,
        .pStdReferenceInfo = &amp;stdBackwardReferenceInfo
    }
};

VkVideoReferenceSlotInfoKHR referenceSlotInfo[] = {
    {
        .sType = VK_STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_INFO_KHR,
        .pNext = &amp;encodeAV1DpbSlotInfo[0],
        .slotIndex = ... // DPB slot index of the forward reference picture
        ...
    },
    {
        .sType = VK_STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_INFO_KHR,
        .pNext = &amp;encodeAV1DpbSlotInfo[1],
        .slotIndex = ... // DPB slot index of the backward reference picture
        ...
    }
};

StdVideoEncodeAV1PictureInfo stdPictureInfo = {};
// Populate AV1 picture info for the encode input picture
...
stdPictureInfo.frame_type = STD_VIDEO_AV1_FRAME_TYPE_INTER;
...

VkVideoEncodeAV1PictureInfoKHR encodeAV1PictureInfo = {
    .sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_PICTURE_INFO_KHR,
    .pNext = NULL,
    .predictionMode = ... // could be single reference, uni- or bidirectional compound
    .rateControlGroup = VK_VIDEO_ENCODE_AV1_RATE_CONTROL_GROUP_BIPREDICTIVE_KHR,
    .pStdPictureInfo = &amp;stdPictureInfo,
    ...
};

// Initialize all elements of referenceNameSlotIndices with negative values except the
// reference name that are used as the forward and backward reference (LAST_FRAME and
// ALTREF_FRAME in this case)
for (uint32_t i = 0; i &lt; VK_MAX_VIDEO_AV1_REFERENCES_PER_FRAME_KHR; ++i) {
    encodeAV1PictureInfo.referenceNameSlotIndices[i] = -1;
}
encodeAV1PictureInfo.referenceNameSlotIndices[STD_VIDEO_AV1_REFERENCE_NAME_LAST_FRAME - STD_VIDEO_AV1_REFERENCE_NAME_LAST_FRAME] = ...
encodeAV1PictureInfo.referenceNameSlotIndices[STD_VIDEO_AV1_REFERENCE_NAME_ALTREF_FRAME - STD_VIDEO_AV1_REFERENCE_NAME_LAST_FRAME] = ...
// NOTE: Alternatively, the application can choose (e.g. for portability reasons) to
// point all elements of the referenceNameSlotIndices array to the DPB slots of the used
// reference pictures and let the implementation choose under what AV1 reference name's
// semantics will it use the reference pictures during encoding

VkVideoEncodeInfoKHR encodeInfo = {
    .sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_INFO_KHR,
    .pNext = &amp;encodeAV1PictureInfo,
    ...
    .referenceSlotCount = sizeof(referenceSlotInfo) / sizeof(referenceSlotInfo[0]),
    .pReferenceSlots = &amp;referenceSlotInfo[0]
};

vkCmdEncodeVideoKHR(commandBuffer, &amp;encodeInfo);

vkCmdEndVideoCodingKHR(commandBuffer, ...);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_change_the_rate_control_configuration_of_an_av1_encode_session_with_optional_av1_controls"><a class="anchor" href="#_change_the_rate_control_configuration_of_an_av1_encode_session_with_optional_av1_controls"></a>4.7. Change the rate control configuration of an AV1 encode session with optional AV1 controls</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">vkCmdBeginVideoCodingKHR(commandBuffer, ...);

// Include the optional AV1 rate control layer information
// In this example we restrict the quantizer index range to be used by the implementation
VkVideoEncodeAV1RateControlLayerInfoKHR rateControlLayersAV1[] = {
    {
        .sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_RATE_CONTROL_LAYER_INFO_KHR,
        .pNext = NULL,
        .useMinQIndex = VK_TRUE,
        .minQIndex = { /* min quantizer indices for each rate control group */ },
        .useMaxQIndex = VK_TRUE,
        .minQIndex = { /* max quantizer indices for each rate control group */ },
        .useMaxFrameSize = VK_FALSE,
        .maxFrameSize = { 0, 0, 0 }
    },
    ...
};

VkVideoEncodeRateControlLayerInfoKHR rateControlLayers[] = {
    {
        .sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_LAYER_INFO_KHR,
        .pNext = &amp;rateControlLayersAV1[0],
        ...
    },
    ...
};

// Include the optional AV1 global rate control information
VkVideoEncodeAV1RateControlInfoKHR rateControlInfoAV1 = {
    .sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_RATE_CONTROL_INFO_KHR,
    .pNext = NULL,
    .flags = VK_VIDEO_ENCODE_AV1_RATE_CONTROL_REGULAR_GOP_BIT_KHR // Indicate the use of a regular GOP structure...
           | VK_VIDEO_ENCODE_AV1_RATE_CONTROL_TEMPORAL_LAYER_PATTERN_DYADIC_BIT_KHR, // ... and a dyadic temporal layer pattern
    // Indicate a GOP structure of the form IBBBPBBBPBBBI with a key frame at the beginning of every 10th GOP
    .gopFrameCount = 12,
    .keyFramePeriod = 120,
    .consecutiveBipredictiveFrameCount = 3,
    // This example uses multiple temporal layers with per layer rate control
    .temporalLayerCount = sizeof(rateControlLayers) / sizeof(rateControlLayers[0])
};

VkVideoEncodeRateControlInfoKHR rateControlInfo = {
    .sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_INFO_KHR,
    .pNext = &amp;rateControlInfoAV1,
    ...
    .layerCount = sizeof(rateControlLayers) / sizeof(rateControlLayers[0]),
    .pLayers = rateControlLayers,
    ...
};

// Change the rate control configuration for the video session
VkVideoCodingControlInfoKHR controlInfo = {
    .sType = VK_STRUCTURE_TYPE_VIDEO_CODING_CONTROL_INFO_KHR,
    .pNext = &amp;rateControlInfo,
    .flags = VK_VIDEO_CODING_CONTROL_ENCODE_RATE_CONTROL_BIT_KHR
};

vkCmdControlVideoCodingKHR(commandBuffer, &amp;controlInfo);

...

vkCmdEndVideoCodingKHR(commandBuffer, ...);</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_issues"><a class="anchor" href="#_issues"></a>5. Issues</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_resolved_in_what_form_should_codec_specific_parameters_be_provided"><a class="anchor" href="#_resolved_in_what_form_should_codec_specific_parameters_be_provided"></a>5.1. RESOLVED: In what form should codec-specific parameters be provided?</h3>
<div class="paragraph">
<p>In the form of structures defined by the <code>vulkan_video_codec_av1std_encode</code> and <code>vulkan_video_codec_av1std</code> video std headers. Applications are responsible to populate the structures defined by the video std headers. It is also the application&#8217;s responsibility to maintain and manage these data structures, as needed, to be able to provide them as inputs to video encode operations where needed.</p>
</div>
</div>
<div class="sect2">
<h3 id="_resolved_what_are_the_requirements_for_the_codec_specific_input_parameters"><a class="anchor" href="#_resolved_what_are_the_requirements_for_the_codec_specific_input_parameters"></a>5.2. RESOLVED: What are the requirements for the codec-specific input parameters?</h3>
<div class="paragraph">
<p>It is legal from an API usage perspective for the application to provide any values for the codec-specific input parameters (sequence header, picture information, etc.). However, if the input data does not conform to the requirements of the AV1 video compression standard, then video encode operations may complete unsuccessfully and, in general, the outputs produced by the video encode operation will have undefined contents.</p>
</div>
<div class="paragraph">
<p>In addition, certain commands may return the <code>VK_ERROR_INVALID_VIDEO_STD_PARAMETERS_KHR</code> error if any of the specified codec-specific parameters do not adhere to the syntactic or semantic requirements of the AV1 video compression standard or if values derived from parameters according to the rules defined by the AV1 video compression standard do not adhere to the capabilities of the AV1 video compression standard or the implementation. In particular, in this extension the following commands may return this error code:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>vkCreateVideoSessionParametersKHR</code> or <code>vkUpdateVideoSessionParametersKHR</code> - if the specified parameter sets are invalid according to these rules</p>
</li>
<li>
<p><code>vkEndCommandBuffer</code> - if the codec-specific picture information provided to video encode operations are invalid according to these rules</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Generating errors in the cases above, however, is not required so applications should not rely on receiving an error code for the purposes of verifying the correctness of the used codec-specific parameters.</p>
</div>
</div>
<div class="sect2">
<h3 id="_resolved_are_obu_extension_headers_generated_by_the_implementation_when_multiple_temporal_or_spatial_layers_are_used"><a class="anchor" href="#_resolved_are_obu_extension_headers_generated_by_the_implementation_when_multiple_temporal_or_spatial_layers_are_used"></a>5.3. RESOLVED: Are OBU extension headers generated by the implementation when multiple temporal or spatial layers are used?</h3>
<div class="paragraph">
<p>Implementation support for OBU extension header generation is indicated by the <code>VK_VIDEO_ENCODE_AV1_CAPABILITY_GENERATE_OBU_EXTENSION_HEADER_BIT_KHR</code> capability flag. If supported by the video profile, the application can explicitly opt in to generate OBU extension headers using <code>VkVideoEncodeAV1PictureInfoKHR::generateObuExtensionHeader</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_resolved_what_codec_specific_parameters_are_guaranteed_to_not_be_overridden_by_implementations"><a class="anchor" href="#_resolved_what_codec_specific_parameters_are_guaranteed_to_not_be_overridden_by_implementations"></a>5.4. RESOLVED: What codec-specific parameters are guaranteed to not be overridden by implementations?</h3>
<div class="paragraph">
<p>This proposal requires that implementations do not override a certain set of codec-specific parameters. It also provides guarantees for certain codec-specific parameters in specific conditions. In addition, bits set in the <code>stdSyntaxFlags</code> capability provide additional guarantees about other Video Std parameters that the implementation will use without overriding them. Future extensions may include capability flags providing additional guarantees based on the needs of the users of the API.</p>
</div>
</div>
<div class="sect2">
<h3 id="_resolved_how_is_reference_picture_setup_requested_for_av1_encode_operations"><a class="anchor" href="#_resolved_how_is_reference_picture_setup_requested_for_av1_encode_operations"></a>5.5. RESOLVED: How is reference picture setup requested for AV1 encode operations?</h3>
<div class="paragraph">
<p>As specifying a reconstructed picture DPB slot and resource is always required per the latest revision of the video extensions, additional codec syntax controls whether reference picture setup is requested and, in response, the DPB slot is activated with the reconstructed picture.</p>
</div>
<div class="paragraph">
<p>In the case of AV1 encode, reference picture setup depends on the value of <code>StdVideoEncodeAV1PictureInfo::refresh_frame_flags</code>. A non-zero <code>refresh_frame_flags</code> indicates that the VBI needs to be updated such as for each set bit the corresponding VBI slot is associated with the decoded picture&#8217;s information, such as CDF data among others. While VBI slot management is outside of the scope of this proposal, and the responsibility of the application, a non-zero <code>refresh_frame_flags</code> value inherently also implies the need for reference picture setup and thus the activation of a DPB slot with the reconstructed picture.</p>
</div>
<div class="paragraph">
<p>Accordingly, for AV1 encode, reference picture setup is requested and the DPB slot specified for the reconstructed picture is activated with the picture if and only if <code>StdVideoEncodeAV1PictureInfo::refresh_frame_flags</code> is not zero.</p>
</div>
</div>
<div class="sect2">
<h3 id="_resolved_should_we_have_separate_rate_control_configuration_parameters_quantizer_indices_frame_sizes_for_each_av1_prediction_mode"><a class="anchor" href="#_resolved_should_we_have_separate_rate_control_configuration_parameters_quantizer_indices_frame_sizes_for_each_av1_prediction_mode"></a>5.6. RESOLVED: Should we have separate rate control configuration parameters (quantizer indices, frame sizes) for each AV1 prediction mode?</h3>
<div class="paragraph">
<p>No. Implementations typically only support configuration for three different categories, in line with other codecs. Also, the AV1 prediction mode does not provide information about the direction of the prediction. This proposal thus instead defines a separate rate control group parameter that is used as input by rate control to decide which category the current frame falls into.</p>
</div>
</div>
<div class="sect2">
<h3 id="_resolved_how_can_the_application_indicate_the_use_of_a_primary_ref_frame_that_is_used_for_cdf_data_but_not_for_picture_prediction"><a class="anchor" href="#_resolved_how_can_the_application_indicate_the_use_of_a_primary_ref_frame_that_is_used_for_cdf_data_but_not_for_picture_prediction"></a>5.7. RESOLVED: How can the application indicate the use of a <code>primary_ref_frame</code> that is used for CDF data but not for picture prediction?</h3>
<div class="paragraph">
<p>Through the <code>primaryReferenceCdfOnly</code> encode parameter. When enabled, the primary reference frame will only be used as CDF data reference and will not be used for picture prediction. This mode is only supported when the <code>VK_VIDEO_ENCODE_AV1_CAPABILITY_PRIMARY_REFERENCE_CDF_ONLY_BIT_KHR</code> capability flag is supported for the AV1 encode profile.</p>
</div>
</div>
<div class="sect2">
<h3 id="_resolved_why_there_is_no_maxunidirectionalcompoundgroup2referencecount_capability"><a class="anchor" href="#_resolved_why_there_is_no_maxunidirectionalcompoundgroup2referencecount_capability"></a>5.8. RESOLVED: Why there is no <code>maxUnidirectionalCompoundGroup2ReferenceCount</code> capability?</h3>
<div class="paragraph">
<p>In case of unidirectional compound prediction, the only combination of AV1 reference names that are allowed from the reference frame group 2 is <code>BWDREF</code> and <code>ALTREF</code> so a <code>maxUnidirectionalCompoundGroup2ReferenceCount</code> capability would not provide any further information about the supported reference frame count in this case that could not already be determined by checking the corresponding bits of <code>unidirectionalCompoundReferenceNameMask</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_resolved_why_are_implementations_allowed_to_override_the_coded_resolution"><a class="anchor" href="#_resolved_why_are_implementations_allowed_to_override_the_coded_resolution"></a>5.9. RESOLVED: Why are implementations allowed to override the coded resolution?</h3>
<div class="paragraph">
<p>AV1 content is coded at an 8x8 granularity and, correspondingly, the AV1 specification only allows cropping of up to 7 pixel rows and/or columns to be able to represent streams of any resolution. Some implementations have larger alignment requirements than 8x8, and although similar limitations existed in H.264 and H.265, the range of the explicit cropping syntax for those video codecs allows implementations to override picture width and height syntax without affecting the output resolution. Without the existence of such cropping syntax in AV1 that allow for cropping more than 7 pixel rows and/or columns, implementations that cannot output at an 8x8 pixel granularity, as required by the AV1 specification, are not able to code all resolutions natively.</p>
</div>
<div class="paragraph">
<p>In the presence of such limitations, given an unaligned input, implementations are able to align the resolution and source the extra pixels without any input from the application (there is precedent for this with <code>VkVideoEncodeCapabilitiesKHR::encodeInputPictureGranularity</code>). This makes an enforced capability undesirable, as applications would need to ensure picture resources are created and allocated accordingly. Instead, this proposal allows implementations to override the resolution of the bitstream.</p>
</div>
<div class="paragraph">
<p><code>VkVideoEncodeAV1CapabilitiesKHR::codedPictureAlignment</code> is added to inform applications of implementation requirements. If the requested <code>codedExtent</code> rounded up to be aligned to the 8x8 granularity is not aligned to <code>codedPictureAlignment</code>, implementations will enlargen the resolution to be aligned to <code>codedPictureAlignment</code>. This approach requires no change in application behavior on the encoder side, the actual override is well-defined, and encoding is performed according to this extent, allowing applications to compute the exact resolution of the bitstream. Applications can choose to align their input content to the implementation limitation, or let the implementation handle it. Either way, however, applications need to signal relevant cropping parameters in a side channel (i.e. a container) and handle that information on the decoder side if they intend to display or otherwise reproduce the content at its original resolution.</p>
</div>
<div class="paragraph">
<p>For example:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Implementations that report <code>codedPictureAlignment = {8,8}</code> are able to encode any resolution, the encoded resolution will always match the requested resolution.</p>
</li>
<li>
<p>Implementation reports <code>codedPictureAlignment = {16,16}</code>, and an application requests to code 1920x1080. Since 1920x1080 is not aligned to <code>{16,16}</code>, the implementation will encode a 1920x1088 video.</p>
</li>
<li>
<p>Implementation reports <code>codedPictureAlignment = {16,16}</code>, and an application requests to code 1920x1082. The nearest 8x8 alignment of this resolution is 1920x1088, which is already aligned to <code>codedPictureAlignment</code>. No override will occur, and the implementation will encode a 1920x1082 video.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</article>
  </div>
</main>
</div>
<script id="site-script" src="../../../../_/js/site.js" data-ui-root-path="../../../../_"></script>
<script async src="../../../../_/js/vendor/highlight.js"></script>
<script src="../../../../_/js/vendor/lunr.js"></script>
<script src="../../../../_/js/search-ui.js" id="search-ui-script" data-site-root-path="../../../.." data-snippet-length="100" data-stylesheet="../../../../_/css/search.css"></script>
<script async src="../../../../search-index.js"></script>
  </body>
</html>

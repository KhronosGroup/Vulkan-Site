<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>VK_KHR_video_encode_h264 :: Vulkan Documentation Project</title>
    <meta name="generator" content="Antora 3.1.4">
    <link rel="stylesheet" href="../../../../_/css/site.css">
    <link rel="apple-touch-icon" sizes="180x180" href="../../../../_/img/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="../../../../_/img/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="../../../../_/img/favicon-16x16.png">
    <link rel="manifest" href="../../../../_/static/site.webmanifest">
    <link rel="mask-icon" href="../../../../_/img/safari-pinned-tab.svg" color="#a41e22">
    <meta name="msapplication-TileColor" content="#ffc40d">
    <meta name="theme-color" content="#ffffff">
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="../../../.."><img class="navbar-item" alt="Vulkan White Label" src="../../../../_/Vulkan_Docs.svg" /></a>
      <div class="navbar-item search hide-for-print">
        <div id="search-field" class="field has-filter">
          <label for="search-input"></label>
          <input id="search-input" type="text" placeholder="Search the docs">
          <label class="filter checkbox">
            <input type="checkbox" data-facet-filter="component:features" checked> In this component
          </label>
        </div>
      </div>
      <button class="navbar-burger" aria-controls="topbar-nav" aria-expanded="false" aria-label="Toggle main menu">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <!-- <a class="navbar-item" href="#">Home</a> -->
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Specs</a>
          <div class="navbar-dropdown is-right">
            <a class="navbar-item" href="../../../../spec/latest/chapters/introduction.html">Vulkan 1.3</a>
            <a class="navbar-item" href="https://registry.khronos.org/OpenGL/specs/gl/GLSLangSpec.4.60.html">GLSL</a>
            <a class="navbar-item" href="../../../../guide/latest/hlsl.html">HLSL</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Education</a>
          <div class="navbar-dropdown is-right">
            <a class="navbar-item" href="../../../../features/latest/features/index.html">Vulkan Feature Descriptions</a>
            <a class="navbar-item" href="../../../../guide/latest/index.html">Vulkan Guide</a>
            <a class="navbar-item" href="../../../../samples/latest/README.html">Vulkan Samples</a>
            <a class="navbar-item" href="../../../../tutorial/latest/index.html">Vulkan Tutorial</a>
            <a class="navbar-item" href="https://www.youtube.com/c/vulkan">YouTube</a>
            <a class="navbar-item" href="https://vulkan.org">More Info at Vulkan.org</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Feedback</a>
          <div class="navbar-dropdown is-right">
            <a class="navbar-item" href="https://github.com/KhronosGroup/Vulkan-Site/issues/new/choose" target="_blank">Report a Problem</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Community</a>
          <div class="navbar-dropdown is-right">
            <a class="navbar-item" href="https://discord.gg/vulkan">Vulkan Discord</a>
            <a class="navbar-item" href="https://reddit.com/r/vulkan">Reddit</a>
            <a class="navbar-item" href="https://stackoverflow.com/questions/tagged/vulkan">Stack Overflow</a>
            <a class="navbar-item" href="https://fosstodon.org/@vulkan">Mastodon</a>
          </div>
        </div>
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="features" data-version="latest">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <button class="nav-menu-toggle" aria-label="Toggle expand/collapse all" style="display: none"></button>
    <h3 class="title"><a href="../index.html">Vulkan Feature Descriptions</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../index.html">Vulkan Roadmap and Feature Descriptions</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="Roadmap.html">Vulkan Roadmap</a>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Feature Descriptions</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_AMDX_shader_enqueue.html">VK_AMDX_shader_enqueue</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_AMD_anti_lag.html">VK_AMD_anti_lag</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_AMD_shader_early_and_late_fragment_tests.html">VK_AMD_shader_early_and_late_fragment_tests</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_ANDROID_external_format_resolve.html">VK_ANDROID_external_format_resolve</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_ARM_render_pass_striped.html">VK_ARM_render_pass_striped</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_attachment_feedback_loop_dynamic_state.html">VK_EXT_attachment_feedback_loop_dynamic_state</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_attachment_feedback_loop_layout.html">VK_EXT_attachment_feedback_loop_layout</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_calibrated_timestamps.html">VK_EXT_calibrated_timestamps</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_depth_bias_control.html">VK_EXT_depth_bias_control</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_depth_clamp_control.html">VK_EXT_depth_clamp_control</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_descriptor_buffer.html">VK_EXT_descriptor_buffer</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_device_fault.html">VK_EXT_device_fault</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_device_generated_commands.html">VK_EXT_device_generated_commands</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_dynamic_rendering_unused_attachments.html">VK_EXT_dynamic_rendering_unused_attachments</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_extended_dynamic_state3.html">VK_EXT_extended_dynamic_state3</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_external_memory_acquire_unmodified.html">VK_EXT_external_memory_acquire_unmodified</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_frame_boundary.html">Proposal: <code>VK_EXT_frame_boundary</code></a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_graphics_pipeline_library.html">VK_EXT_graphics_pipeline_library</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_host_image_copy.html">VK_EXT_host_image_copy</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_image_2d_array_of_3d.html">VK_EXT_image_2d_array_of_3d</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_image_compression_control.html">VK_EXT_image_compression_control</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_image_sliced_view_of_3d.html">VK_EXT_image_sliced_view_of_3d</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_layer_settings.html">VK_EXT_layer_settings</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_legacy_dithering.html">VK_EXT_legacy_dithering</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_legacy_vertex_attributes.html">VK_EXT_legacy_vertex_attributes</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_map_memory_placed.html">VK_EXT_map_memory_placed</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_mesh_shader.html">VK_EXT_mesh_shader</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_metal_objects.html">VK_EXT_metal_objects</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_multisampled_render_to_single_sampled.html">VK_EXT_multisampled_render_to_single_sampled</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_mutable_descriptor_type.html">VK_EXT_mutable_descriptor_type</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_non_seamless_cube_map.html">VK_EXT_non_seamless_cube_map</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_opacity_micromap.html">VK_EXT_opacity_micromap</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_pipeline_library_group_handles.html">VK_EXT_pipeline_library_group_handles</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_pipeline_protected_access.html">VK_EXT_pipeline_protected_access</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_present_mode_fifo_latest_ready.html">VK_EXT_present_mode_fifo_latest_ready</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_primitives_generated_query.html">VK_EXT_primitives_generated_query</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_rasterization_order_attachment_access.html">VK_EXT_rasterization_order_attachment_access</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_shader_module_identifier.html">VK_EXT_shader_module_identifier</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_shader_object.html">VK_EXT_shader_object</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_shader_replicated_composites.html">VK_EXT_shader_replicated_composites</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_shader_tile_image.html">VK_EXT_shader_tile_image</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_subpass_merge_feedback.html">VK_EXT_subpass_merge_feedback</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_surface_maintenance1.html">VK_EXT_surface_maintenance1</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_swapchain_maintenance1.html">VK_EXT_swapchain_maintenance1</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_GOOGLE_surfaceless_query.html">VK_GOOGLE_surfaceless_query</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_HUAWEI_cluster_culling_shader.html">VK_HUAWEI_cluster_culling_shader</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_HUAWEI_invocation_mask.html">VK_HUAWEI_invocation_mask</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_compute_shader_derivatives.html">VK_KHR_compute_shader_derivatives</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_cooperative_matrix.html">VK_KHR_cooperative_matrix</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_dynamic_rendering.html">VK_KHR_dynamic_rendering</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_dynamic_rendering_local_read.html">VK_KHR_dynamic_rendering_local_read</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_fragment_shader_barycentric.html">VK_KHR_fragment_shader_barycentric</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_fragment_shading_rate.html">VK_KHR_fragment_shading_rate</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_load_store_op_none.html">VK_KHR_load_store_op_none</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_maintenance5.html">VK_KHR_maintenance5</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_maintenance6.html">VK_KHR_maintenance6</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_maintenance7.html">VK_KHR_maintenance7</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_map_memory2.html">VK_KHR_map_memory2</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_pipeline_binary.html">VK_KHR_pipeline_binary</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_ray_tracing_position_fetch.html">VK_KHR_ray_tracing_position_fetch</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_shader_expect_assume.html">VK_KHR_shader_expect_assume</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_shader_float_controls2.html">VK_KHR_shader_float_controls2</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_shader_integer_dot_product.html">VK_KHR_shader_integer_dot_product</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_shader_maximal_reconvergence.html">VK_KHR_shader_maximal_reconvergence</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_shader_quad_control.html">VK_KHR_shader_quad_control</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_shader_relaxed_extended_instruction.html">VK_KHR_shader_relaxed_extended_instruction</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_shader_subgroup_rotate.html">Subgroup rotation instruction</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_vertex_attribute_divisor.html">VK_KHR_vertex_attribute_divisor</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_video_decode_av1.html">VK_KHR_video_decode_av1</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_video_decode_h264.html">VK_KHR_video_decode_h264</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_video_decode_h265.html">VK_KHR_video_decode_h265</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_video_decode_queue.html">VK_KHR_video_decode_queue</a>
  </li>
  <li class="nav-item is-current-page" data-depth="2">
    <a class="nav-link" href="VK_KHR_video_encode_h264.html">VK_KHR_video_encode_h264</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_video_encode_h265.html">VK_KHR_video_encode_h265</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_video_encode_queue.html">VK_KHR_video_encode_queue</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_video_maintenance1.html">VK_KHR_video_maintenance1</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_video_queue.html">VK_KHR_video_queue</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_LUNARG_direct_driver_loading.html">VK_LUNARG_direct_driver_loading</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_MSFT_layered_driver.html">VK_MSFT_layered_driver</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_NV_cooperative_matrix2.html">VK_NV_cooperative_matrix2</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_NV_ray_tracing_validation.html">VK_NV_ray_tracing_validation</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_QCOM_image_processing.html">VK_QCOM_image_processing</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_QCOM_tile_properties.html">VK_QCOM_tile_properties</a>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Vulkan Feature Descriptions</span>
    <span class="version">latest</span>
  </div>
  <ul class="components">
    <li class="component">
      <div class="title"><a href="../../../../tutorial/latest/00_Introduction.html">Khronos Vulkan Tutorial</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../../tutorial/latest/00_Introduction.html">latest</a>
        </li>
      </ul>
    </li>
    <li class="component is-current">
      <div class="title"><a href="../index.html">Vulkan Feature Descriptions</a></div>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="../index.html">latest</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../../../guide/latest/index.html">Vulkan Guide</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../../guide/latest/index.html">latest</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../../../samples/latest/README.html">Vulkan Samples</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../../samples/latest/README.html">latest</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../../../spec/latest/index.html">Vulkan Specification</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../../spec/latest/index.html">latest</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../../../../spec/latest/index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../index.html">Vulkan Feature Descriptions</a></li>
    <li>Feature Descriptions</li>
    <li><a href="VK_KHR_video_encode_h264.html">VK_KHR_video_encode_h264</a></li>
  </ul>
</nav>
</div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">VK_KHR_video_encode_h264</h1>
<div id="toc" class="toc">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_problem_statement">1. Problem Statement</a></li>
<li><a href="#_solution_space">2. Solution Space</a></li>
<li><a href="#_proposal">3. Proposal</a>
<ul class="sectlevel2">
<li><a href="#_video_std_headers">3.1. Video Std Headers</a></li>
<li><a href="#_h_264_encode_profiles">3.2. H.264 Encode Profiles</a></li>
<li><a href="#_h_264_encode_capabilities">3.3. H.264 Encode Capabilities</a></li>
<li><a href="#_h_264_encode_parameter_sets">3.4. H.264 Encode Parameter Sets</a></li>
<li><a href="#_h_264_encoding_parameters">3.5. H.264 Encoding Parameters</a></li>
<li><a href="#_h_264_reference_lists">3.6. H.264 Reference Lists</a></li>
<li><a href="#_h_264_rate_control">3.7. H.264 Rate Control</a></li>
</ul>
</li>
<li><a href="#_examples">4. Examples</a>
<ul class="sectlevel2">
<li><a href="#_select_queue_family_with_h_264_encode_support">4.1. Select queue family with H.264 encode support</a></li>
<li><a href="#_check_support_and_query_the_capabilities_for_an_h_264_encode_profile">4.2. Check support and query the capabilities for an H.264 encode profile</a></li>
<li><a href="#_create_and_update_h_264_video_session_parameters_objects">4.3. Create and update H.264 video session parameters objects</a></li>
<li><a href="#_record_h_264_encode_operation_producing_an_i_frame_that_is_also_set_up_as_a_reference">4.4. Record H.264 encode operation producing an I frame that is also set up as a reference</a></li>
<li><a href="#_record_h_264_encode_operation_producing_a_p_frame_with_a_single_forward_reference">4.5. Record H.264 encode operation producing a P frame with a single forward reference</a></li>
<li><a href="#_record_h_264_encode_operation_producing_a_b_frame_with_a_forward_and_a_backward_reference">4.6. Record H.264 encode operation producing a B frame with a forward and a backward reference</a></li>
<li><a href="#_change_the_rate_control_configuration_of_an_h_264_encode_session_with_optional_h_264_controls">4.7. Change the rate control configuration of an H.264 encode session with optional H.264 controls</a></li>
</ul>
</li>
<li><a href="#_issues">5. Issues</a>
<ul class="sectlevel2">
<li><a href="#_resolved_in_what_form_should_codec_specific_parameters_be_provided">5.1. RESOLVED: In what form should codec-specific parameters be provided?</a></li>
<li><a href="#_resolved_why_the_vulkan_video_codec_h264std_video_std_header_does_not_have_a_version_number">5.2. RESOLVED: Why the <code>vulkan_video_codec_h264std</code> video std header does not have a version number?</a></li>
<li><a href="#_resolved_what_are_the_requirements_for_the_codec_specific_input_parameters">5.3. RESOLVED: What are the requirements for the codec-specific input parameters?</a></li>
<li><a href="#_resolved_are_interlaced_frames_supported">5.4. RESOLVED: Are interlaced frames supported?</a></li>
<li><a href="#_resolved_do_we_want_to_allow_the_application_to_specify_separate_reference_lists_for_each_slice">5.5. RESOLVED: Do we want to allow the application to specify separate reference lists for each slice?</a></li>
<li><a href="#_resolved_are_prefix_nal_units_generated_by_the_implementation_when_multiple_temporal_layers_are_used">5.6. RESOLVED: Are prefix NAL units generated by the implementation when multiple temporal layers are used?</a></li>
<li><a href="#_resolved_what_codec_specific_parameters_are_guaranteed_to_not_be_overridden_by_implementations">5.7. RESOLVED: What codec-specific parameters are guaranteed to not be overridden by implementations?</a></li>
<li><a href="#_resolved_how_is_reference_picture_setup_requested_for_h_264_encode_operations">5.8. RESOLVED: How is reference picture setup requested for H.264 encode operations?</a></li>
</ul>
</li>
<li><a href="#_further_functionality">6. Further Functionality</a></li>
</ul>
</div>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>This document outlines a proposal to enable performing H.264/AVC video encode operations in Vulkan.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_problem_statement"><a class="anchor" href="#_problem_statement"></a>1. Problem Statement</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The <code>VK_KHR_video_queue</code> extension introduces support for video coding operations and the <code>VK_KHR_video_encode_queue</code> extension further extends this with APIs specific to video encoding.</p>
</div>
<div class="paragraph">
<p>The goal of this proposal is to build upon this infrastructure to introduce support for encoding elementary video stream sequences compliant with the H.264/AVC video compression standard.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_solution_space"><a class="anchor" href="#_solution_space"></a>2. Solution Space</h2>
<div class="sectionbody">
<div class="paragraph">
<p>As the <code>VK_KHR_video_queue</code> and <code>VK_KHR_video_encode_queue</code> extensions already laid down the architecture for how codec-specific video encode extensions need to be designed, this extension only needs to define the APIs to provide the necessary codec-specific parameters at various points during the use of the codec-independent APIs. In particular:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>APIs allowing to specify H.264 sequence and picture parameter sets (SPS, PPS) to be stored in video session parameters objects</p>
</li>
<li>
<p>APIs allowing to specify H.264 information specific to the encoded picture, including references to previously stored SPS and PPS entries</p>
</li>
<li>
<p>APIs allowing to specify H.264 reference picture information specific to the active reference pictures and optional reconstructed picture used in video encode operations</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Codec-specific encoding parameters are specified by the application through custom definitions provided by a video std header dedicated to H.264 video encoding.</p>
</div>
<div class="paragraph">
<p>This proposal uses the common H.264 definitions first utilized by the <code>VK_KHR_video_decode_h264</code> extension and augments it with another video std header specific to H.264 encoding. Thus this extension uses the following video std headers:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>vulkan_video_codec_h264std</code> - containing common definitions for all H.264 video coding operations</p>
</li>
<li>
<p><code>vulkan_video_codec_h264std_encode</code> - containing definitions specific to H.264 video encoding operations</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>These headers can be included as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">#include &lt;vk_video/vulkan_video_codec_h264std.h&gt;
#include &lt;vk_video/vulkan_video_codec_h264std_encode.h&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_proposal"><a class="anchor" href="#_proposal"></a>3. Proposal</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_video_std_headers"><a class="anchor" href="#_video_std_headers"></a>3.1. Video Std Headers</h3>
<div class="paragraph">
<p>This extension uses the new <code>vulkan_video_codec_h264std_encode</code> video std header. Implementations must always support at least version 1.0.0 of this video std header.</p>
</div>
</div>
<div class="sect2">
<h3 id="_h_264_encode_profiles"><a class="anchor" href="#_h_264_encode_profiles"></a>3.2. H.264 Encode Profiles</h3>
<div class="paragraph">
<p>This extension introduces the new video codec operation <code>VK_VIDEO_CODEC_OPERATION_ENCODE_H264_BIT_KHR</code>. This flag can be used to check whether a particular queue family supports encoding H.264/AVC content, as returned in <code>VkQueueFamilyVideoPropertiesKHR</code>.</p>
</div>
<div class="paragraph">
<p>An H.264 encode profile can be defined through a <code>VkVideoProfileInfoKHR</code> structure using this new video codec operation and by including the following new codec-specific profile information structure in the <code>pNext</code> chain:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">typedef struct VkVideoEncodeH264ProfileInfoKHR {
    VkStructureType                              sType;
    const void*                                  pNext;
    StdVideoH264ProfileIdc                       stdProfileIdc;
} VkVideoEncodeH264ProfileInfoKHR;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>stdProfileIdc</code> specifies the H.264 profile indicator.</p>
</div>
</div>
<div class="sect2">
<h3 id="_h_264_encode_capabilities"><a class="anchor" href="#_h_264_encode_capabilities"></a>3.3. H.264 Encode Capabilities</h3>
<div class="paragraph">
<p>Applications need to include the following new structure in the <code>pNext</code> chain of <code>VkVideoCapabilitiesKHR</code> when calling the <code>vkGetPhysicalDeviceVideoCapabilitiesKHR</code> command to retrieve the capabilities specific to H.264 video encoding:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">typedef struct VkVideoEncodeH264CapabilitiesKHR {
    VkStructureType                        sType;
    void*                                  pNext;
    VkVideoEncodeH264CapabilityFlagsKHR    flags;
    StdVideoH264LevelIdc                   maxLevelIdc;
    uint32_t                               maxSliceCount;
    uint32_t                               maxPPictureL0ReferenceCount;
    uint32_t                               maxBPictureL0ReferenceCount;
    uint32_t                               maxL1ReferenceCount;
    uint32_t                               maxTemporalLayerCount;
    VkBool32                               expectDyadicTemporalLayerPattern;
    int32_t                                minQp;
    int32_t                                maxQp;
    VkBool32                               prefersGopRemainingFrames;
    VkBool32                               requiresGopRemainingFrames;
    VkVideoEncodeH264StdFlagsKHR           stdSyntaxFlags;
} VkVideoEncodeH264CapabilitiesKHR;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>flags</code> indicates support for various H.264 encoding capabilities:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>VK_VIDEO_ENCODE_H264_CAPABILITY_HRD_COMPLIANCE_BIT_KHR</code> - support for generating HRD compliant bitstreams when the related HRD parameters are present</p>
</li>
<li>
<p><code>VK_VIDEO_ENCODE_H264_CAPABILITY_PREDICTION_WEIGHT_TABLE_GENERATED_BIT_KHR</code> - support for generating the weight tables used by the encoding process, when necessary, instead of the application having to provide them</p>
</li>
<li>
<p><code>VK_VIDEO_ENCODE_H264_CAPABILITY_ROW_UNALIGNED_SLICE_BIT_KHR</code> - support for slices that do not start/finish at macroblock row boundaries</p>
</li>
<li>
<p><code>VK_VIDEO_ENCODE_H264_CAPABILITY_DIFFERENT_SLICE_TYPE_BIT_KHR</code> - support for different slice types within a frame</p>
</li>
<li>
<p><code>VK_VIDEO_ENCODE_H264_CAPABILITY_B_FRAME_IN_L0_LIST_BIT_KHR</code> - support for including B pictures in the L0 reference list</p>
</li>
<li>
<p><code>VK_VIDEO_ENCODE_H264_CAPABILITY_B_FRAME_IN_L1_LIST_BIT_KHR</code> - support for including B pictures in the L1 reference list</p>
</li>
<li>
<p><code>VK_VIDEO_ENCODE_H264_CAPABILITY_PER_PICTURE_TYPE_MIN_MAX_QP_BIT_KHR</code> - support for using different min/max QP values for each picture type when rate control is enabled</p>
</li>
<li>
<p><code>VK_VIDEO_ENCODE_H264_CAPABILITY_PER_SLICE_CONSTANT_QP_BIT_KHR</code> - support for using different constant QP values for each slice of a frame when rate control is disabled</p>
</li>
<li>
<p><code>VK_VIDEO_ENCODE_H264_CAPABILITY_GENERATE_PREFIX_NALU_BIT_KHR</code> - support for generating prefix NAL units</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>maxLevelIdc</code> indicates the maximum supported H.264 level indicator.</p>
</div>
<div class="paragraph">
<p><code>maxSliceCount</code> indicates the implementation&#8217;s upper bound on the number of H.264 slices that an encoded frame can contain, although the actual maximum may be smaller for a given frame depending on its dimensions and some of the capability flags described earlier.</p>
</div>
<div class="paragraph">
<p><code>maxPPictureL0ReferenceCount</code>, <code>maxBPictureL0ReferenceCount</code>, and <code>maxL1ReferenceCount</code> indicate the maximum number of reference frames that the encoded frames can refer to through the L0 and L1 reference lists depending on the type of the picture (P or B), respectively. These capabilities do not restrict the number of references the application can include in the L0 and L1 reference lists as, in practice, implementations may restrict the effective number of used references based on the encoded content and/or the capabilities of the encoder implementation. However, they do indirectly indicate whether encoding P or B pictures are supported. In particular:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If <code>maxPPictureL0ReferenceCount</code> is zero, then encoding P pictures is not supported by the implementation</p>
</li>
<li>
<p>If both <code>maxBPictureL0ReferenceCount</code> and <code>maxL1ReferenceCount</code> are zero, then encoding B pictures is not supported by the implementation</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>maxTemporalLayerCount</code> indicates the number of supported H.264 temporal layers, while <code>expectDyadicTemporalLayerPattern</code> indicates whether the multi-layer rate control algorithm of the implementation (if support is indicated by <code>VkVideoEncodeCapabilitiesKHR::maxRateControlLayers</code> being greater than one for the given H.264 encode profile) expects the application to use a dyadic temporal layer pattern for accurate operation.</p>
</div>
<div class="paragraph">
<p><code>minQp</code> and <code>maxQp</code> indicate the supported range of QP values that can be used in the rate control configurations or as the constant QP to be used when rate control is disabled.</p>
</div>
<div class="paragraph">
<p><code>prefersGopRemainingFrames</code> and <code>requiresGopRemainingFrames</code> indicate whether the implementation prefers or requires, respectively, that the application track the remaining number of frames (for each type) in the current GOP (group of pictures), as some implementations may need this information for the accurate operation of their rate control algorithm.</p>
</div>
<div class="paragraph">
<p><code>stdSyntaxFlags</code> contains a set of flags that provide information to the application about which video std parameters or parameter values are supported to be used directly as specified by the application. These flags do not restrict what video std parameter values the application can specify, rather, they provide guarantees about respecting those.</p>
</div>
</div>
<div class="sect2">
<h3 id="_h_264_encode_parameter_sets"><a class="anchor" href="#_h_264_encode_parameter_sets"></a>3.4. H.264 Encode Parameter Sets</h3>
<div class="paragraph">
<p>The use of video session parameters objects is mandatory when encoding H.264 video streams. Applications need to include the following new structure in the <code>pNext</code> chain of <code>VkVideoSessionParametersCreateInfoKHR</code> when creating video session parameters objects for H.264 encode use, to specify the parameter set capacity of the created objects:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">typedef struct VkVideoEncodeH264SessionParametersCreateInfoKHR {
    VkStructureType                                        sType;
    const void*                                            pNext;
    uint32_t                                               maxStdSPSCount;
    uint32_t                                               maxStdPPSCount;
    const VkVideoEncodeH264SessionParametersAddInfoKHR*    pParametersAddInfo;
} VkVideoEncodeH264SessionParametersCreateInfoKHR;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The optional <code>pParametersAddInfo</code> member also allows specifying an initial set of parameter sets to add to the created object:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">typedef struct VkVideoEncodeH264SessionParametersAddInfoKHR {
    VkStructureType                            sType;
    const void*                                pNext;
    uint32_t                                   stdSPSCount;
    const StdVideoH264SequenceParameterSet*    pStdSPSs;
    uint32_t                                   stdPPSCount;
    const StdVideoH264PictureParameterSet*     pStdPPSs;
} VkVideoEncodeH264SessionParametersAddInfoKHR;</code></pre>
</div>
</div>
<div class="paragraph">
<p>This structure can also be included in the <code>pNext</code> chain of <code>VkVideoSessionParametersUpdateInfoKHR</code> used in video session parameters update operations to add further parameter sets to an object after its creation.</p>
</div>
<div class="paragraph">
<p>Individual parameter sets are stored using parameter set IDs as their keys, specifically:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>H.264 SPS entries are identified using a <code>seq_parameter_set_id</code> value</p>
</li>
<li>
<p>H.264 PPS entries are identified using a pair of <code>seq_parameter_set_id</code> and <code>pic_parameter_set_id</code> values</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The H.264/AVC video compression standard always requires an SPS and PPS, hence the application has to add an instance of each parameter set to the used parameters object before being able to record video encode operations.</p>
</div>
<div class="paragraph">
<p>Furthermore, the H.264/AVC video compression standard also allows modifying existing parameter sets, but as parameters already stored in video session parameters objects cannot be changed in Vulkan, the application has to create new parameters objects in such cases, as described in the proposal for <code>VK_KHR_video_queue</code>.</p>
</div>
<div class="paragraph">
<p>As implementations can override parameters in the SPS and PPS entries stored in video session parameters objects, as described in the proposal for <code>VK_KHR_video_encode_queue</code>, this proposal introduces additional structures specific to H.264 encode to be used with the <code>vkGetEncodedVideoSessionParametersKHR</code> command.</p>
</div>
<div class="paragraph">
<p>First, the following new structure has to be included in the <code>pNext</code> chain of <code>VkVideoEncodeSessionParametersGetInfoKHR</code> to identify the H.264 parameter sets that the command is expected to return feedback information or encoded parameter set data for:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">typedef struct VkVideoEncodeH264SessionParametersGetInfoKHR {
    VkStructureType    sType;
    const void*        pNext;
    VkBool32           writeStdSPS;
    VkBool32           writeStdPPS;
    uint32_t           stdSPSId;
    uint32_t           stdPPSId;
} VkVideoEncodeH264SessionParametersGetInfoKHR;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>writeStdSPS</code> and <code>writeStdPPS</code> specify whether SPS or PPS feedback/bitstream data is requested. Both can be requested, if needed.</p>
</div>
<div class="paragraph">
<p><code>stdSPSId</code> and <code>stdPPSId</code> are used to identify the SPS and/or PPS to request data for, the latter being relevant only for PPS queries.</p>
</div>
<div class="paragraph">
<p>When requesting feedback using the <code>vkGetEncodedVideoSessionParametersKHR</code> command, the following new structure can be included in the <code>pNext</code> chain of <code>VkVideoEncodeSessionParametersFeedbackInfoKHR</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">typedef struct VkVideoEncodeH264SessionParametersFeedbackInfoKHR {
    VkStructureType    sType;
    void*              pNext;
    VkBool32           hasStdSPSOverrides;
    VkBool32           hasStdPPSOverrides;
} VkVideoEncodeH264SessionParametersFeedbackInfoKHR;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The resulting values of <code>hasStdSPSOverrides</code> and <code>hasStdPPSOverrides</code> indicate whether overrides were applied to the SPS and/or PPS, respectively, if the corresponding <code>writeStd</code> field was set in the input parameters.</p>
</div>
<div class="paragraph">
<p>When requesting encoded bitstream data using the <code>vkGetEncodedVideoSessionParametersKHR</code> command, the output host data buffer will be filled with the encoded bitstream of the requested H.264 parameter sets.</p>
</div>
<div class="paragraph">
<p>As described in great detail in the proposal for the <code>VK_KHR_video_encode_queue</code> extension, the application may have the option to encode the parameters otherwise stored in video session parameters object on its own. However, this may not result in a compliant bitstream if the implementation applied overrides to SPS or PPS parameters, thus it is generally recommended for applications to use the encoded parameter set data retrieved using the <code>vkGetEncodedVideoSessionParametersKHR</code> command.</p>
</div>
</div>
<div class="sect2">
<h3 id="_h_264_encoding_parameters"><a class="anchor" href="#_h_264_encoding_parameters"></a>3.5. H.264 Encoding Parameters</h3>
<div class="paragraph">
<p>Encode parameters specific to H.264 need to be provided by the application through the <code>pNext</code> chain of <code>VkVideoEncodeInfoKHR</code>, using the following new structure:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">typedef struct VkVideoEncodeH264PictureInfoKHR {
    VkStructureType                             sType;
    const void*                                 pNext;
    uint32_t                                    naluSliceEntryCount;
    const VkVideoEncodeH264NaluSliceInfoKHR*    pNaluSliceEntries;
    const StdVideoEncodeH264PictureInfo*        pStdPictureInfo;
    VkBool32                                    generatePrefixNalu;
} VkVideoEncodeH264PictureInfoKHR;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>naluSliceEntryCount</code> specifies the number of slices to encode for the frame and the elements of the <code>pNaluSliceEntries</code> array provide additional information for each slice, as described later.</p>
</div>
<div class="paragraph">
<p><code>pStdPictureInfo</code> points to the codec-specific encode parameters defined in the <code>vulkan_video_codec_h264std_encode</code> video std header.</p>
</div>
<div class="paragraph">
<p>The active SPS and PPS (sourced from the bound video session parameters object) are identified by the <code>seq_parameter_set_id</code> and <code>pic_parameter_set_id</code> parameters.</p>
</div>
<div class="paragraph">
<p>The structure pointed to by <code>pStdPictureInfo&#8594;pRefLists</code> specifies the codec-specific parameters related to the reference lists. In particular, it specifies the DPB slots corresponding to the elements of the L0 and L1 reference lists, as well as the reference picture marking and reference list modification operations.</p>
</div>
<div class="paragraph">
<p>If the <code>VK_VIDEO_ENCODE_H264_CAPABILITY_GENERATE_PREFIX_NALU_BIT_KHR</code> capability flag is supported, <code>generatePrefixNalu</code> can be set to <code>VK_TRUE</code> to request the generation of prefix NAL units before each encoded slice.</p>
</div>
<div class="paragraph">
<p>The parameters of individual slices are provided through instances of the following new structure:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">typedef struct VkVideoEncodeH264NaluSliceInfoKHR {
    VkStructureType                         sType;
    const void*                             pNext;
    int32_t                                 constantQp;
    const StdVideoEncodeH264SliceHeader*    pStdSliceHeader;
} VkVideoEncodeH264NaluSliceInfoKHR;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>constantQp</code> specifies the constant QP value to use for the slice when rate control is disabled.</p>
</div>
<div class="paragraph">
<p><code>pStdSliceHeader</code> points to the codec-specific encode parameters to use in the slice header.</p>
</div>
<div class="paragraph">
<p>Picture information specific to H.264 for the active reference pictures and the optional reconstructed picture need to be provided by the application through the <code>pNext</code> chain of corresponding elements of <code>VkVideoEncodeInfoKHR::pReferenceSlots</code> and the <code>pNext</code> chain of <code>VkVideoEncodeInfoKHR::pSetupReferenceSlot</code>, respectively, using the following new structure:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">typedef struct VkVideoEncodeH264DpbSlotInfoKHR {
    VkStructureType                           sType;
    const void*                               pNext;
    const StdVideoEncodeH264ReferenceInfo*    pStdReferenceInfo;
} VkVideoEncodeH264DpbSlotInfoKHR;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>pStdReferenceInfo</code> points to the codec-specific reference picture parameters defined in the <code>vulkan_video_codec_h264std_encode</code> video std header.</p>
</div>
<div class="paragraph">
<p>It is the application&#8217;s responsibility to specify codec-specific parameters that are compliant with the rules defined by the H.264/AVC video compression standard. While it is not illegal, from the API usage&#8217;s point of view, to specify non-compliant inputs, they may cause the video encode operation to complete unsuccessfully and will cause the output bitstream and the reconstructed picture, if one is specified, to have undefined contents after the execution of the operation.</p>
</div>
<div class="paragraph">
<p>Implementations may override some of these parameters in order to conform to any restrictions of the encoder implementation, but that will not affect the overall operation of the encoding. The application has the option to also opt-in for additional optimizing overrides that can result in better performance or efficiency tailored to the usage scenario by creating the video session with the new <code>VK_VIDEO_SESSION_CREATE_ALLOW_ENCODE_PARAMETER_OPTIMIZATIONS_BIT_KHR</code> flag.</p>
</div>
<div class="paragraph">
<p>For more information about individual H.264 bitstream syntax elements, derived values, and, in general, how to interpret these parameters, please refer to the corresponding sections of the <a href="https://www.itu.int/rec/T-REC-H.264-202108-I/">ITU-T H.264 Specification</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_h_264_reference_lists"><a class="anchor" href="#_h_264_reference_lists"></a>3.6. H.264 Reference Lists</h3>
<div class="paragraph">
<p>In order to populate the L0 and L1 reference lists used to encode predictive pictures, the application has to set the corresponding elements of the <code>RefPicList0</code> and <code>RefPicList1</code> array members of the structure pointed to by <code>VkVideoEncodeH264PictureInfoKHR::pStdPictureInfo&#8594;pRefLists</code> to the DPB slot indices of the reference pictures, while all unused elements of <code>RefPicList0</code> and <code>RefPicList1</code> have to be set to <code>STD_VIDEO_H264_NO_REFERENCE_PICTURE</code>. As usual, the reference picture resources are specified by including them in the list of active reference pictures according to the codec-independent semantics defined by the <code>VK_KHR_video_encode_queue</code> extension.</p>
</div>
<div class="paragraph">
<p>In all cases the set of DPB slot indices referenced by the L0 and L1 reference lists and the list of active reference pictures specified in <code>VkVideoEncodeInfoKHR::pReferenceSlots</code> must match, but the order in which the active reference pictures are included in the <code>pReferenceSlots</code> array does not matter.</p>
</div>
</div>
<div class="sect2">
<h3 id="_h_264_rate_control"><a class="anchor" href="#_h_264_rate_control"></a>3.7. H.264 Rate Control</h3>
<div class="paragraph">
<p>This proposal adds a set of optional rate control parameters specific to H.264 encoding that provide additional guidance to the implementation&#8217;s rate control algorithm.</p>
</div>
<div class="paragraph">
<p>When rate control is not disabled and not set to implementation-default behavior, the application can include the following new structure in the <code>pNext</code> chain of <code>VkVideoEncodeRateControlInfoKHR</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">typedef struct VkVideoEncodeH264RateControlInfoKHR {
    VkStructureType                         sType;
    const void*                             pNext;
    VkVideoEncodeH264RateControlFlagsKHR    flags;
    uint32_t                                gopFrameCount;
    uint32_t                                idrPeriod;
    uint32_t                                consecutiveBFrameCount;
    uint32_t                                temporalLayerCount;
} VkVideoEncodeH264RateControlInfoKHR;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>flags</code> can include one or more of the following flags:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>VK_VIDEO_ENCODE_H264_RATE_CONTROL_ATTEMPT_HRD_COMPLIANCE_BIT_KHR</code> can be used to indicate that the application would like the implementation&#8217;s rate control algorithm to attempt to produce an HRD compliant bitstream when possible</p>
</li>
<li>
<p><code>VK_VIDEO_ENCODE_H264_RATE_CONTROL_REGULAR_GOP_BIT_KHR</code> can be used to indicate that the application intends to use a regular GOP structure according to the parameters specified in <code>gopFrameCount</code>, <code>idrPeriod</code>, and <code>consecutiveBFrameCount</code></p>
</li>
<li>
<p><code>VK_VIDEO_ENCODE_H264_RATE_CONTROL_REFERENCE_PATTERN_FLAT_BIT_KHR</code> can be used to indicate that the application intends to follow a flat reference pattern in the GOP where each P frame uses the last non-B frame as reference, and each B frame uses the last and next non-B frame as forward and backward references, respectively</p>
</li>
<li>
<p><code>VK_VIDEO_ENCODE_H264_RATE_CONTROL_REFERENCE_PATTERN_DYADIC_BIT_KHR</code> can be used to indicate that the application intends to follow a dyadic reference pattern</p>
</li>
<li>
<p><code>VK_VIDEO_ENCODE_H264_RATE_CONTROL_TEMPORAL_LAYER_PATTERN_DYADIC_BIT_KHR</code> can be used to indicate that the application intends to follow a dyadic temporal layer pattern when using multiple temporal layers</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>gopFrameCount</code>, <code>idrPeriod</code>, and <code>consecutiveBFrameCount</code> specify the GOP size, IDR period, and the number of consecutive B frames between non-B frames, respectively, that define the typical structure of the GOP the implementation&#8217;s rate control algorithm should expect. If <code>VK_VIDEO_ENCODE_H264_RATE_CONTROL_REGULAR_GOP_BIT_KHR</code> is also specified in <code>flags</code>, the implementation will expect all GOPs to follow this structure, while otherwise it may assume that the application will diverge from these values from time to time. If any of these values are zero, then the implementation&#8217;s rate control algorithm will not make any assumptions about the corresponding parameter of the GOP structure.</p>
</div>
<div class="paragraph">
<p><code>temporalLayerCount</code> indicates the number of H.264 temporal layers that the application intends to use and it is expected to match the number of rate control layers when multi-layer rate control is used.</p>
</div>
<div class="paragraph">
<p>The following new structure can be included in the <code>pNext</code> chain of <code>VkVideoEncodeRateControlLayerInfoKHR</code> to specify additional per-rate-control-layer guidance parameters specific to H.264 encode:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">typedef struct VkVideoEncodeH264RateControlLayerInfoKHR {
    VkStructureType                  sType;
    const void*                      pNext;
    VkBool32                         useMinQp;
    VkVideoEncodeH264QpKHR           minQp;
    VkBool32                         useMaxQp;
    VkVideoEncodeH264QpKHR           maxQp;
    VkBool32                         useMaxFrameSize;
    VkVideoEncodeH264FrameSizeKHR    maxFrameSize;
} VkVideoEncodeH264RateControlLayerInfoKHR;</code></pre>
</div>
</div>
<div class="paragraph">
<p>When <code>useMinQp</code> is set to <code>VK_TRUE</code>, <code>minQp</code> specifies the lower bound on the QP values, for each picture type, that the implementation&#8217;s rate control algorithm should use. Similarly, when <code>useMaxQp</code> is set to <code>VK_TRUE</code>, <code>maxQp</code> specifies the upper bound on the QP values.</p>
</div>
<div class="paragraph">
<p>When <code>useMaxFrameSize</code> is set to <code>VK_TRUE</code>, <code>maxFrameSize</code> specifies the maximum frame size in bytes, for each picture type, that the implementation&#8217;s rate control algorithm should target.</p>
</div>
<div class="paragraph">
<p>Some implementations may benefit from or require additional guidance on the remaining number of frames in the currently encoded GOP, as indicated by the <code>prefersGopRemainingFrames</code> and <code>requiresGopRemainingFrames</code> capabilities, respectively. This may be the case either due to the implementation not being able to track the current position of the encoded stream within the GOP, or because the implementation may be able to use this information to better react to dynamic changes to the GOP structure. This proposal solves this by introducing the following new structure that can be included in the <code>pNext</code> chain of <code>VkVideoBeginCodingInfoKHR</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">typedef struct VkVideoEncodeH264GopRemainingFrameInfoKHR {
    VkStructureType    sType;
    const void*        pNext;
    VkBool32           useGopRemainingFrames;
    uint32_t           gopRemainingI;
    uint32_t           gopRemainingP;
    uint32_t           gopRemainingB;
} VkVideoEncodeH264GopRemainingFrameInfoKHR;</code></pre>
</div>
</div>
<div class="paragraph">
<p>When <code>useGopRemainingFrames</code> is set to <code>VK_TRUE</code>, the implementation&#8217;s rate control algorithm may use the values specified in <code>gopRemainingI</code>, <code>gopRemainingP</code>, and <code>gopRemainingB</code> as a guidance on the number of remaining frames of the corresponding type in the currently encoded GOP.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_examples"><a class="anchor" href="#_examples"></a>4. Examples</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_select_queue_family_with_h_264_encode_support"><a class="anchor" href="#_select_queue_family_with_h_264_encode_support"></a>4.1. Select queue family with H.264 encode support</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">uint32_t queueFamilyIndex;
uint32_t queueFamilyCount;

vkGetPhysicalDeviceQueueFamilyProperties2(physicalDevice, &amp;queueFamilyCount, NULL);

VkQueueFamilyProperties2* props = calloc(queueFamilyCount,
    sizeof(VkQueueFamilyProperties2));
VkQueueFamilyVideoPropertiesKHR* videoProps = calloc(queueFamilyCount,
    sizeof(VkQueueFamilyVideoPropertiesKHR));

for (queueFamilyIndex = 0; queueFamilyIndex &lt; queueFamilyCount; ++queueFamilyIndex) {
    props[queueFamilyIndex].sType = VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2;
    props[queueFamilyIndex].pNext = &amp;videoProps[queueFamilyIndex];

    videoProps[queueFamilyIndex].sType = VK_STRUCTURE_TYPE_QUEUE_FAMILY_VIDEO_PROPERTIES_KHR;
}

vkGetPhysicalDeviceQueueFamilyProperties2(physicalDevice, &amp;queueFamilyCount, props);

for (queueFamilyIndex = 0; queueFamilyIndex &lt; queueFamilyCount; ++queueFamilyIndex) {
    if ((props[queueFamilyIndex].queueFamilyProperties.queueFlags &amp; VK_QUEUE_VIDEO_ENCODE_BIT_KHR) != 0 &amp;&amp;
        (videoProps[queueFamilyIndex].videoCodecOperations &amp; VK_VIDEO_CODEC_OPERATION_ENCODE_H264_BIT_KHR) != 0) {
        break;
    }
}

if (queueFamilyIndex &lt; queueFamilyCount) {
    // Found appropriate queue family
    ...
} else {
    // Did not find a queue family with the needed capabilities
    ...
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_check_support_and_query_the_capabilities_for_an_h_264_encode_profile"><a class="anchor" href="#_check_support_and_query_the_capabilities_for_an_h_264_encode_profile"></a>4.2. Check support and query the capabilities for an H.264 encode profile</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">VkResult result;

VkVideoEncodeH264ProfileInfoKHR encodeH264ProfileInfo = {
    .sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PROFILE_INFO_KHR,
    .pNext = NULL,
    .stdProfileIdc = STD_VIDEO_H264_PROFILE_IDC_BASELINE
};

VkVideoProfileInfoKHR profileInfo = {
    .sType = VK_STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR,
    .pNext = &amp;encodeH264ProfileInfo,
    .videoCodecOperation = VK_VIDEO_CODEC_OPERATION_ENCODE_H264_BIT_KHR,
    .chromaSubsampling = VK_VIDEO_CHROMA_SUBSAMPLING_420_BIT_KHR,
    .lumaBitDepth = VK_VIDEO_COMPONENT_BIT_DEPTH_8_BIT_KHR,
    .chromaBitDepth = VK_VIDEO_COMPONENT_BIT_DEPTH_8_BIT_KHR
};

VkVideoEncodeH264CapabilitiesKHR encodeH264Capabilities = {
    .sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_CAPABILITIES_KHR,
    .pNext = NULL,
};

VkVideoEncodeCapabilitiesKHR encodeCapabilities = {
    .sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_CAPABILITIES_KHR,
    .pNext = &amp;encodeH264Capabilities
}

VkVideoCapabilitiesKHR capabilities = {
    .sType = VK_STRUCTURE_TYPE_VIDEO_CAPABILITIES_KHR,
    .pNext = &amp;encodeCapabilities
};

result = vkGetPhysicalDeviceVideoCapabilitiesKHR(physicalDevice, &amp;profileInfo, &amp;capabilities);

if (result == VK_SUCCESS) {
    // Profile is supported, check additional capabilities
    ...
} else {
    // Profile is not supported, result provides additional information about why
    ...
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_create_and_update_h_264_video_session_parameters_objects"><a class="anchor" href="#_create_and_update_h_264_video_session_parameters_objects"></a>4.3. Create and update H.264 video session parameters objects</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">VkVideoSessionParametersKHR videoSessionParams = VK_NULL_HANDLE;

VkVideoEncodeH264SessionParametersCreateInfoKHR encodeH264CreateInfo = {
    .sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR,
    .pNext = NULL,
    .maxStdSPSCount = ... // SPS capacity
    .maxStdPPSCount = ... // PPS capacity
    .pParametersAddInfo = ... // parameters to add at creation time or NULL
};

VkVideoSessionParametersCreateInfoKHR createInfo = {
    .sType = VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_CREATE_INFO_KHR,
    .pNext = &amp;encodeH264CreateInfo,
    .flags = 0,
    .videoSessionParametersTemplate = ... // template to use or VK_NULL_HANDLE
    .videoSession = videoSession
};

vkCreateVideoSessionParametersKHR(device, &amp;createInfo, NULL, &amp;videoSessionParams);

...

StdVideoH264SequenceParameterSet sps = {};
// parse and populate SPS parameters
...

StdVideoH264PictureParameterSet pps = {};
// parse and populate PPS parameters
...

VkVideoEncodeH264SessionParametersAddInfoKHR encodeH264AddInfo = {
    .sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR,
    .pNext = NULL,
    .stdSPSCount = 1,
    .pStdSPSs = &amp;sps,
    .stdPPSCount = 1,
    .pStdPPSs = &amp;pps
};

VkVideoSessionParametersUpdateInfoKHR updateInfo = {
    .sType = VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_UPDATE_INFO_KHR,
    .pNext = &amp;encodeH264AddInfo,
    .updateSequenceCount = 1 // incremented for each subsequent update
};

vkUpdateVideoSessionParametersKHR(device, &amp;videoSessionParams, &amp;updateInfo);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_record_h_264_encode_operation_producing_an_i_frame_that_is_also_set_up_as_a_reference"><a class="anchor" href="#_record_h_264_encode_operation_producing_an_i_frame_that_is_also_set_up_as_a_reference"></a>4.4. Record H.264 encode operation producing an I frame that is also set up as a reference</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">// Bound reference resource list provided has to include reconstructed picture resource
vkCmdBeginVideoCodingKHR(commandBuffer, ...);

StdVideoEncodeH264ReferenceInfo stdReferenceInfo = {};
// Populate H.264 reference picture info for the reconstructed picture
stdReferenceInfo.primary_pic_type = STD_VIDEO_H264_PICTURE_TYPE_I;
...

VkVideoEncodeH264DpbSlotInfoKHR encodeH264DpbSlotInfo = {
    .sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_DPB_SLOT_INFO_KHR,
    .pNext = NULL,
    .pStdReferenceInfo = &amp;stdReferenceInfo
};

VkVideoReferenceSlotInfoKHR setupSlotInfo = {
    .sType = VK_STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_INFO_KHR,
    .pNext = &amp;encodeH264DpbSlotInfo
    ...
};

StdVideoEncodeH264ReferenceListsInfo stdRefListInfo = {};
// No references are used so just initialize the RefPicLists
for (uint32_t i = 0; i &lt; STD_VIDEO_H264_MAX_NUM_LIST_REF; ++i) {
    stdRefListInfo.RefPicList0[i] = STD_VIDEO_H264_NO_REFERENCE_PICTURE;
    stdRefListInfo.RefPicList1[i] = STD_VIDEO_H264_NO_REFERENCE_PICTURE;
}
// Populate H.264 reference list modification/marking ops and other parameters
...

StdVideoEncodeH264PictureInfo stdPictureInfo = {};
// Populate H.264 picture info for the encode input picture
...
// Make sure that the reconstructed picture is requested to be set up as reference
stdPictureInfo.flags.is_reference = 1;
...
stdPictureInfo.primary_pic_type = STD_VIDEO_H264_PICTURE_TYPE_I;
...
stdPictureInfo.pRefLists = &amp;stdRefListInfo;

VkVideoEncodeH264PictureInfoKHR encodeH264PictureInfo = {
    .sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PICTURE_INFO_KHR,
    .pNext = NULL,
    .naluSliceEntryCount = ... // number of slices to encode
    .pNaluSliceEntries = ... // pointer to the array of slice parameters
    .pStdPictureInfo = &amp;stdPictureInfo
};

VkVideoEncodeInfoKHR encodeInfo = {
    .sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_INFO_KHR,
    .pNext = &amp;encodeH264PictureInfo,
    ...
    .pSetupReferenceSlot = &amp;setupSlotInfo,
    ...
};

vkCmdEncodeVideoKHR(commandBuffer, &amp;encodeInfo);

vkCmdEndVideoCodingKHR(commandBuffer, ...);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_record_h_264_encode_operation_producing_a_p_frame_with_a_single_forward_reference"><a class="anchor" href="#_record_h_264_encode_operation_producing_a_p_frame_with_a_single_forward_reference"></a>4.5. Record H.264 encode operation producing a P frame with a single forward reference</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">// Bound reference resource list provided has to include the used reference picture resource
vkCmdBeginVideoCodingKHR(commandBuffer, ...);

StdVideoEncodeH264ReferenceInfo stdForwardReferenceInfo = {};
// Populate H.264 reference picture info for the forward referenced picture
...

VkVideoEncodeH264DpbSlotInfoKHR encodeH264DpbSlotInfo = {
    .sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_DPB_SLOT_INFO_KHR,
    .pNext = NULL,
    .pStdReferenceInfo = &amp;stdForwardReferenceInfo
};

VkVideoReferenceSlotInfoKHR referenceSlotInfo = {
    .sType = VK_STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_INFO_KHR,
    .pNext = &amp;encodeH264DpbSlotInfo,
    .slotIndex = ... // DPB slot index of the forward reference picture
    ...
};

StdVideoEncodeH264ReferenceListsInfo stdRefListInfo = {};
// Initialize the RefPicLists and add the forward reference to the L0 list
for (uint32_t i = 0; i &lt; STD_VIDEO_H264_MAX_NUM_LIST_REF; ++i) {
    stdRefListInfo.RefPicList0[i] = STD_VIDEO_H264_NO_REFERENCE_PICTURE;
    stdRefListInfo.RefPicList1[i] = STD_VIDEO_H264_NO_REFERENCE_PICTURE;
}
stdRefListInfo.RefPicList0[0] = ... // DPB slot index of the forward reference picture
// Populate H.264 reference list modification/marking ops and other parameters
...

StdVideoEncodeH264PictureInfo stdPictureInfo = {};
// Populate H.264 picture info for the encode input picture
...
stdPictureInfo.primary_pic_type = STD_VIDEO_H264_PICTURE_TYPE_P;
...
stdPictureInfo.pRefLists = &amp;stdRefListInfo;

VkVideoEncodeH264PictureInfoKHR encodeH264PictureInfo = {
    .sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PICTURE_INFO_KHR,
    .pNext = NULL,
    .naluSliceEntryCount = ... // number of slices to encode
    .pNaluSliceEntries = ... // pointer to the array of slice parameters
    .pStdPictureInfo = &amp;stdPictureInfo
};

VkVideoEncodeInfoKHR encodeInfo = {
    .sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_INFO_KHR,
    .pNext = &amp;encodeH264PictureInfo,
    ...
    .referenceSlotCount = 1,
    .pReferenceSlots = &amp;referenceSlotInfo
};

vkCmdEncodeVideoKHR(commandBuffer, &amp;encodeInfo);

vkCmdEndVideoCodingKHR(commandBuffer, ...);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_record_h_264_encode_operation_producing_a_b_frame_with_a_forward_and_a_backward_reference"><a class="anchor" href="#_record_h_264_encode_operation_producing_a_b_frame_with_a_forward_and_a_backward_reference"></a>4.6. Record H.264 encode operation producing a B frame with a forward and a backward reference</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">// Bound reference resource list provided has to include the used reference picture resources
vkCmdBeginVideoCodingKHR(commandBuffer, ...);

StdVideoEncodeH264ReferenceInfo stdForwardReferenceInfo = {};
// Populate H.264 reference picture info for the forward referenced picture
...

StdVideoEncodeH264ReferenceInfo stdBackwardReferenceInfo = {};
// Populate H.264 reference picture info for the backward referenced picture
...

VkVideoEncodeH264DpbSlotInfoKHR encodeH264DpbSlotInfo[] = {
    {
        .sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_DPB_SLOT_INFO_KHR,
        .pNext = NULL,
        .pStdReferenceInfo = &amp;stdForwardReferenceInfo
    },
    {
        .sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_DPB_SLOT_INFO_KHR,
        .pNext = NULL,
        .pStdReferenceInfo = &amp;stdBackwardReferenceInfo
    }
};

VkVideoReferenceSlotInfoKHR referenceSlotInfo[] = {
    {
        .sType = VK_STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_INFO_KHR,
        .pNext = &amp;encodeH264DpbSlotInfo[0],
        .slotIndex = ... // DPB slot index of the forward reference picture
        ...
    },
    {
        .sType = VK_STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_INFO_KHR,
        .pNext = &amp;encodeH264DpbSlotInfo[1],
        .slotIndex = ... // DPB slot index of the backward reference picture
        ...
    }
};

StdVideoEncodeH264ReferenceListsInfo stdRefListInfo = {};
// Initialize the RefPicLists, add the forward reference to the L0 list,
// and add the backward reference to the L1 list
for (uint32_t i = 0; i &lt; STD_VIDEO_H264_MAX_NUM_LIST_REF; ++i) {
    stdRefListInfo.RefPicList0[i] = STD_VIDEO_H264_NO_REFERENCE_PICTURE;
    stdRefListInfo.RefPicList1[i] = STD_VIDEO_H264_NO_REFERENCE_PICTURE;
}
stdRefListInfo.RefPicList0[0] = ... // DPB slot index of the forward reference picture
stdRefListInfo.RefPicList1[0] = ... // DPB slot index of the backward reference picture
// Populate H.264 reference list modification/marking ops and other parameters
...

StdVideoEncodeH264PictureInfo stdPictureInfo = {};
// Populate H.264 picture info for the encode input picture
...
stdPictureInfo.primary_pic_type = STD_VIDEO_H264_PICTURE_TYPE_B;
...
stdPictureInfo.pRefLists = &amp;stdRefListInfo;

VkVideoEncodeH264PictureInfoKHR encodeH264PictureInfo = {
    .sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PICTURE_INFO_KHR,
    .pNext = NULL,
    .naluSliceEntryCount = ... // number of slices to encode
    .pNaluSliceEntries = ... // pointer to the array of slice parameters
    .pStdPictureInfo = &amp;stdPictureInfo
};

VkVideoEncodeInfoKHR encodeInfo = {
    .sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_INFO_KHR,
    .pNext = &amp;encodeH264PictureInfo,
    ...
    .referenceSlotCount = sizeof(referenceSlotInfo) / sizeof(referenceSlotInfo[0]),
    .pReferenceSlots = &amp;referenceSlotInfo[0]
};

vkCmdEncodeVideoKHR(commandBuffer, &amp;encodeInfo);

vkCmdEndVideoCodingKHR(commandBuffer, ...);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_change_the_rate_control_configuration_of_an_h_264_encode_session_with_optional_h_264_controls"><a class="anchor" href="#_change_the_rate_control_configuration_of_an_h_264_encode_session_with_optional_h_264_controls"></a>4.7. Change the rate control configuration of an H.264 encode session with optional H.264 controls</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">vkCmdBeginVideoCodingKHR(commandBuffer, ...);

// Include the optional H.264 rate control layer information
// In this example we restrict the QP range to be used by the implementation
VkVideoEncodeH264RateControlLayerInfoKHR rateControlLayersH264[] = {
    {
        .sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_LAYER_INFO_KHR,
        .pNext = NULL,
        .useMinQp = VK_TRUE,
        .minQp = { /* min I frame QP */, /* min P frame QP */, /* min B frame QP */ },
        .useMaxQp = VK_TRUE,
        .minQp = { /* max I frame QP */, /* max P frame QP */, /* max B frame QP */ },
        .useMaxFrameSize = VK_FALSE,
        .maxFrameSize = { 0, 0, 0 }
    },
    ...
};

VkVideoEncodeRateControlLayerInfoKHR rateControlLayers[] = {
    {
        .sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_LAYER_INFO_KHR,
        .pNext = &amp;rateControlLayersH264[0],
        ...
    },
    ...
};

// Include the optional H.264 global rate control information
VkVideoEncodeH264RateControlInfoKHR rateControlInfoH264 = {
    .sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_INFO_KHR,
    .pNext = NULL,
    .flags = VK_VIDEO_ENCODE_H264_RATE_CONTROL_REGULAR_GOP_BIT_KHR // Indicate the use of a regular GOP structure...
           | VK_VIDEO_ENCODE_H264_RATE_CONTROL_TEMPORAL_LAYER_PATTERN_DYADIC_BIT_KHR, // ... and a dyadic temporal layer pattern
    // Indicate a GOP structure of the form IBBBPBBBPBBBI with an IDR frame at the beginning of every 10th GOP
    .gopFrameCount = 12,
    .idrPeriod = 120,
    .consecutiveBFrameCount = 3,
    // This example uses multiple temporal layers with per layer rate control
    .temporalLayerCount = sizeof(rateControlLayers) / sizeof(rateControlLayers[0])
};

VkVideoEncodeRateControlInfoKHR rateControlInfo = {
    .sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_INFO_KHR,
    .pNext = &amp;rateControlInfoH264,
    ...
    .layerCount = sizeof(rateControlLayers) / sizeof(rateControlLayers[0]),
    .pLayers = rateControlLayers,
    ...
};

// Change the rate control configuration for the video session
VkVideoCodingControlInfoKHR controlInfo = {
    .sType = VK_STRUCTURE_TYPE_VIDEO_CODING_CONTROL_INFO_KHR,
    .pNext = &amp;rateControlInfo,
    .flags = VK_VIDEO_CODING_CONTROL_ENCODE_RATE_CONTROL_BIT_KHR
};

vkCmdControlVideoCodingKHR(commandBuffer, &amp;controlInfo);

...

vkCmdEndVideoCodingKHR(commandBuffer, ...);</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_issues"><a class="anchor" href="#_issues"></a>5. Issues</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_resolved_in_what_form_should_codec_specific_parameters_be_provided"><a class="anchor" href="#_resolved_in_what_form_should_codec_specific_parameters_be_provided"></a>5.1. RESOLVED: In what form should codec-specific parameters be provided?</h3>
<div class="paragraph">
<p>In the form of structures defined by the <code>vulkan_video_codec_h264std_encode</code> and <code>vulkan_video_codec_h264std</code> video std headers. Applications are responsible to populate the structures defined by the video std headers. It is also the application&#8217;s responsibility to maintain and manage these data structures, as needed, to be able to provide them as inputs to video encode operations where needed.</p>
</div>
</div>
<div class="sect2">
<h3 id="_resolved_why_the_vulkan_video_codec_h264std_video_std_header_does_not_have_a_version_number"><a class="anchor" href="#_resolved_why_the_vulkan_video_codec_h264std_video_std_header_does_not_have_a_version_number"></a>5.2. RESOLVED: Why the <code>vulkan_video_codec_h264std</code> video std header does not have a version number?</h3>
<div class="paragraph">
<p>The <code>vulkan_video_codec_h264std</code> video std header was introduced to share common definitions used in both H.264/AVC video decoding and video encoding, as the two functionalities were designed in parallel. However, as no video coding extension uses this video std header directly, only as a dependency of the video std header specific to the particular video coding operation, no separate versioning scheme was deemed necessary.</p>
</div>
</div>
<div class="sect2">
<h3 id="_resolved_what_are_the_requirements_for_the_codec_specific_input_parameters"><a class="anchor" href="#_resolved_what_are_the_requirements_for_the_codec_specific_input_parameters"></a>5.3. RESOLVED: What are the requirements for the codec-specific input parameters?</h3>
<div class="paragraph">
<p>It is legal from an API usage perspective for the application to provide any values for the codec-specific input parameters (parameter sets, picture information, etc.). However, if the input data does not conform to the requirements of the H.264/AVC video compression standard, then video encode operations may complete unsuccessfully and, in general, the outputs produced by the video encode operation will have undefined contents.</p>
</div>
<div class="paragraph">
<p>In addition, certain commands may return the <code>VK_ERROR_INVALID_VIDEO_STD_PARAMETERS_KHR</code> error if any of the specified codec-specific parameters do not adhere to the syntactic or semantic requirements of the H.264/AVC video compression standard or if values derived from parameters according to the rules defined by the H.264/AVC video compression standard do not adhere to the capabilities of the H.264/AVC video compression standard or the implementation. In particular, in this extension the following commands may return this error code:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>vkCreateVideoSessionParametersKHR</code> or <code>vkUpdateVideoSessionParametersKHR</code> - if the specified parameter sets are invalid according to these rules</p>
</li>
<li>
<p><code>vkEndCommandBuffer</code> - if the codec-specific picture information provided to video encode operations are invalid according to these rules</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Generating errors in the cases above, however, is not required so applications should not rely on receiving an error code for the purposes of verifying the correctness of the used codec-specific parameters.</p>
</div>
</div>
<div class="sect2">
<h3 id="_resolved_are_interlaced_frames_supported"><a class="anchor" href="#_resolved_are_interlaced_frames_supported"></a>5.4. RESOLVED: Are interlaced frames supported?</h3>
<div class="paragraph">
<p>No. Encoding interlaced H.264 content does not seem like an important use case to support.</p>
</div>
</div>
<div class="sect2">
<h3 id="_resolved_do_we_want_to_allow_the_application_to_specify_separate_reference_lists_for_each_slice"><a class="anchor" href="#_resolved_do_we_want_to_allow_the_application_to_specify_separate_reference_lists_for_each_slice"></a>5.5. RESOLVED: Do we want to allow the application to specify separate reference lists for each slice?</h3>
<div class="paragraph">
<p>Not in this extension. While the H.264/AVC video compression standard seems to support this, such flexibility is not exposed here for the sake of simplicity. If the need arises to support per slice reference lists operations, a layered extension can introduce the necessary APIs to enable it.</p>
</div>
</div>
<div class="sect2">
<h3 id="_resolved_are_prefix_nal_units_generated_by_the_implementation_when_multiple_temporal_layers_are_used"><a class="anchor" href="#_resolved_are_prefix_nal_units_generated_by_the_implementation_when_multiple_temporal_layers_are_used"></a>5.6. RESOLVED: Are prefix NAL units generated by the implementation when multiple temporal layers are used?</h3>
<div class="paragraph">
<p>Only when the <code>VK_VIDEO_ENCODE_H264_CAPABILITY_GENERATE_PREFIX_NALU_BIT_KHR</code> capability flag is supported by the implementation and the application explicitly requests the generation of prefix NAL units using the <code>generatePrefixNalu</code> parameter.</p>
</div>
<div class="paragraph">
<p>If an application intends to use multiple temporal layers on an implementation that does not support the generation of prefix NALU units, then the application is responsible for inserting those into the final bitstream.</p>
</div>
</div>
<div class="sect2">
<h3 id="_resolved_what_codec_specific_parameters_are_guaranteed_to_not_be_overridden_by_implementations"><a class="anchor" href="#_resolved_what_codec_specific_parameters_are_guaranteed_to_not_be_overridden_by_implementations"></a>5.7. RESOLVED: What codec-specific parameters are guaranteed to not be overridden by implementations?</h3>
<div class="paragraph">
<p>This proposal only requires that implementations do not override the <code>primary_pic_type</code> and <code>slice_type</code> parameters, as the used picture and slice types are fundamental to the general operation of H.264 encoding. In addition, bits set in the <code>stdSyntaxFlags</code> capability provide additional guarantees about other Video Std parameters that the implementation will use without overriding them. No further restrictions are included in this extension regarding codec-specific parameter overrides, however, future extensions may include capability flags providing additional guarantees based on the needs of the users of the API.</p>
</div>
</div>
<div class="sect2">
<h3 id="_resolved_how_is_reference_picture_setup_requested_for_h_264_encode_operations"><a class="anchor" href="#_resolved_how_is_reference_picture_setup_requested_for_h_264_encode_operations"></a>5.8. RESOLVED: How is reference picture setup requested for H.264 encode operations?</h3>
<div class="paragraph">
<p>As specifying a reconstructed picture DPB slot and resource is always required per the latest revision of the video extensions, additional codec syntax controls whether reference picture setup is requested and, in response, the DPB slot is activated with the reconstructed picture.</p>
</div>
<div class="paragraph">
<p>For H.264 encode, reference picture setup is requested and the DPB slot specified for the reconstructed picture is activated with the picture if and only if the <code>StdVideoEncodeH264PictureInfo::flags.is_reference</code> flag is set.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_further_functionality"><a class="anchor" href="#_further_functionality"></a>6. Further Functionality</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Future extensions can further extend the capabilities provided here, e.g. exposing support for encode modes allowing per-slice input and/or output.</p>
</div>
</div>
</div>
</article>
  </div>
</main>
</div>
<script id="site-script" src="../../../../_/js/site.js" data-ui-root-path="../../../../_"></script>
<script async src="../../../../_/js/vendor/highlight.js"></script>
<script src="../../../../_/js/vendor/lunr.js"></script>
<script src="../../../../_/js/search-ui.js" id="search-ui-script" data-site-root-path="../../../.." data-snippet-length="100" data-stylesheet="../../../../_/css/search.css"></script>
<script async src="../../../../search-index.js"></script>
  </body>
</html>

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>VK_KHR_video_encode_quantization_map :: Vulkan Documentation Project</title>
    <meta name="generator" content="Antora 3.1.10">
    <script>
      !function (theme) {
        if (theme === 'dark') document.documentElement.classList.add('dark')
        else document.documentElement.classList.add('light')
      }(localStorage && localStorage.getItem('theme') || (matchMedia('(prefers-color-scheme: dark)')?.matches && 'dark'))
    </script>
    <link rel="stylesheet" href="../../../../_/css/site.css">
    <link rel="apple-touch-icon" sizes="180x180" href="../../../../_/img/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="../../../../_/img/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="../../../../_/img/favicon-16x16.png">
    <link rel="manifest" href="../../../../_/static/site.webmanifest">
    <link rel="mask-icon" href="../../../../_/img/safari-pinned-tab.svg" color="#a41e22">
    <meta name="msapplication-TileColor" content="#ffc40d">
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="../../../.."><img class="navbar-item" alt="Vulkan White Label" src="../../../../_/Vulkan_Docs.svg" /></a>
      <div class="navbar-item search hide-for-print">
        <div id="search-field" class="field has-filter">
          <label for="search-input"></label>
          <input id="search-input" type="text" placeholder="Search the docs">
          <label class="filter checkbox">
            <input type="checkbox" data-facet-filter="component:features" checked> In this component
          </label>
        </div>
      </div>
      <button class="navbar-burger" aria-controls="topbar-nav" aria-expanded="false" aria-label="Toggle main menu">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <!-- <a class="navbar-item" href="#">Home</a> -->
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Specs</a>
          <div class="navbar-dropdown is-right">
            <a class="navbar-item" href="../../../../spec/latest/chapters/introduction.html">Vulkan API</a>
            <a class="navbar-item" href="../../../../glsl/latest/index.html">GLSL</a>
            <a class="navbar-item" href="../../../../guide/latest/hlsl.html">HLSL</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Education</a>
          <div class="navbar-dropdown is-right">
            <a class="navbar-item" href="../../../../features/latest/features/index.html">Vulkan Feature Descriptions</a>
            <a class="navbar-item" href="../../../../guide/latest/index.html">Vulkan Guide</a>
            <a class="navbar-item" href="../../../../samples/latest/README.html">Vulkan Samples</a>
            <a class="navbar-item" href="../../../../tutorial/latest/index.html">Vulkan Tutorial</a>
            <a class="navbar-item" href="https://www.youtube.com/c/vulkan">YouTube</a>
            <a class="navbar-item" href="https://vulkan.org">More Info at Vulkan.org</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Feedback</a>
          <div class="navbar-dropdown is-right">
            <a class="navbar-item" href="https://github.com/KhronosGroup/Vulkan-Site/issues/new/choose" target="_blank">Report a Problem</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Community</a>
          <div class="navbar-dropdown is-right">
            <a class="navbar-item" href="https://discord.gg/vulkan">Vulkan Discord</a>
            <a class="navbar-item" href="https://reddit.com/r/vulkan">Reddit</a>
            <a class="navbar-item" href="https://stackoverflow.com/questions/tagged/vulkan">Stack Overflow</a>
            <a class="navbar-item" href="https://fosstodon.org/@vulkan">Mastodon</a>
          </div>
        </div>
      </div>
    </div>
    <label class="theme-toggler">
      <input type="checkbox" id="switch-theme-checkbox" name="switch-theme-checkbox"/>
      <span class="icon"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="moon" class="svg-inline--fa fa-moon moon" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><path fill="currentColor" d="M223.5 32C100 32 0 132.3 0 256S100 480 223.5 480c60.6 0 115.5-24.2 155.8-63.4c5-4.9 6.3-12.5 3.1-18.7s-10.1-9.7-17-8.5c-9.8 1.7-19.8 2.6-30.1 2.6c-96.9 0-175.5-78.8-175.5-176c0-65.8 36-123.1 89.3-153.3c6.1-3.5 9.2-10.5 7.7-17.3s-7.3-11.9-14.3-12.5c-6.3-.5-12.6-.8-19-.8z"></path>
        </svg>
        <svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="sun" class="svg-inline--fa fa-sun sun" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M361.5 1.2c5 2.1 8.6 6.6 9.6 11.9L391 121l107.9 19.8c5.3 1 9.8 4.6 11.9 9.6s1.5 10.7-1.6 15.2L446.9 256l62.3 90.3c3.1 4.5 3.7 10.2 1.6 15.2s-6.6 8.6-11.9 9.6L391 391 371.1 498.9c-1 5.3-4.6 9.8-9.6 11.9s-10.7 1.5-15.2-1.6L256 446.9l-90.3 62.3c-4.5 3.1-10.2 3.7-15.2 1.6s-8.6-6.6-9.6-11.9L121 391 13.1 371.1c-5.3-1-9.8-4.6-11.9-9.6s-1.5-10.7 1.6-15.2L65.1 256 2.8 165.7c-3.1-4.5-3.7-10.2-1.6-15.2s6.6-8.6 11.9-9.6L121 121 140.9 13.1c1-5.3 4.6-9.8 9.6-11.9s10.7-1.5 15.2 1.6L256 65.1 346.3 2.8c4.5-3.1 10.2-3.7 15.2-1.6zM160 256a96 96 0 1 1 192 0 96 96 0 1 1 -192 0zm224 0a128 128 0 1 0 -256 0 128 128 0 1 0 256 0z"></path>
        </svg></span>
    </label>
  </nav>
</header>
<script>
  window.onload = function() {
    let e = document.getElementById("switch-theme-checkbox")
    e.checked = document.documentElement.classList.contains("dark");
    e.checked ? e.parentElement.classList.add("active") : e.parentElement.classList.remove("active")
  }
  !function() {
    let e = document.getElementById("switch-theme-checkbox")
    e.checked = document.documentElement.classList.contains("dark")
    e.addEventListener("change", function() {
      if (document.documentElement.classList.contains("light")) {
        document.documentElement.classList.remove("light")
        document.documentElement.classList.add("dark")
      } else if (document.documentElement.classList.contains("dark")) {
        document.documentElement.classList.remove("dark")
        document.documentElement.classList.add("light")
      } else {
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
          document.documentElement.classList.add("dark")
        } else {
          document.documentElement.classList.add("light")
        }
      }
      document.documentElement.setAttribute("data-theme", this.checked ? "dark" : "light"),
        function(e) {
          window.localStorage && window.localStorage.setItem("theme", e)
        }(this.checked ? "dark" : "light"), this.checked ? this.parentElement.classList.add("active") : this.parentElement.classList.remove("active")
    }.bind(e))
  }();
</script>
<div class="body">
<div class="nav-container" data-component="features" data-version="latest">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <button class="nav-menu-toggle" aria-label="Toggle expand/collapse all" style="display: none"></button>
    <h3 class="title"><a href="../index.html">Vulkan Feature Descriptions</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../index.html">Vulkan Roadmap and Feature Descriptions</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="Roadmap.html">Vulkan Roadmap</a>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Feature Descriptions</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_AMDX_shader_enqueue.html">VK_AMDX_shader_enqueue</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_AMD_anti_lag.html">VK_AMD_anti_lag</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_AMD_shader_early_and_late_fragment_tests.html">VK_AMD_shader_early_and_late_fragment_tests</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_ANDROID_external_format_resolve.html">VK_ANDROID_external_format_resolve</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_ARM_pipeline_opacity_micromap.html">VK_ARM_pipeline_opacity_micromap</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_ARM_render_pass_striped.html">VK_ARM_render_pass_striped</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_attachment_feedback_loop_dynamic_state.html">VK_EXT_attachment_feedback_loop_dynamic_state</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_attachment_feedback_loop_layout.html">VK_EXT_attachment_feedback_loop_layout</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_calibrated_timestamps.html">VK_EXT_calibrated_timestamps</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_depth_bias_control.html">VK_EXT_depth_bias_control</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_depth_clamp_control.html">VK_EXT_depth_clamp_control</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_descriptor_buffer.html">VK_EXT_descriptor_buffer</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_device_fault.html">VK_EXT_device_fault</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_device_generated_commands.html">VK_EXT_device_generated_commands</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_dynamic_rendering_unused_attachments.html">VK_EXT_dynamic_rendering_unused_attachments</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_extended_dynamic_state3.html">VK_EXT_extended_dynamic_state3</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_external_memory_acquire_unmodified.html">VK_EXT_external_memory_acquire_unmodified</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_frame_boundary.html">Proposal: <code>VK_EXT_frame_boundary</code></a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_graphics_pipeline_library.html">VK_EXT_graphics_pipeline_library</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_host_image_copy.html">VK_EXT_host_image_copy</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_image_2d_array_of_3d.html">VK_EXT_image_2d_array_of_3d</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_image_compression_control.html">VK_EXT_image_compression_control</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_image_sliced_view_of_3d.html">VK_EXT_image_sliced_view_of_3d</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_layer_settings.html">VK_EXT_layer_settings</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_legacy_dithering.html">VK_EXT_legacy_dithering</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_legacy_vertex_attributes.html">VK_EXT_legacy_vertex_attributes</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_map_memory_placed.html">VK_EXT_map_memory_placed</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_mesh_shader.html">VK_EXT_mesh_shader</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_metal_objects.html">VK_EXT_metal_objects</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_multisampled_render_to_single_sampled.html">VK_EXT_multisampled_render_to_single_sampled</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_mutable_descriptor_type.html">VK_EXT_mutable_descriptor_type</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_non_seamless_cube_map.html">VK_EXT_non_seamless_cube_map</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_opacity_micromap.html">VK_EXT_opacity_micromap</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_pipeline_library_group_handles.html">VK_EXT_pipeline_library_group_handles</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_pipeline_protected_access.html">VK_EXT_pipeline_protected_access</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_present_mode_fifo_latest_ready.html">VK_EXT_present_mode_fifo_latest_ready</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_primitives_generated_query.html">VK_EXT_primitives_generated_query</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_rasterization_order_attachment_access.html">VK_EXT_rasterization_order_attachment_access</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_shader_module_identifier.html">VK_EXT_shader_module_identifier</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_shader_object.html">VK_EXT_shader_object</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_shader_replicated_composites.html">VK_EXT_shader_replicated_composites</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_shader_tile_image.html">VK_EXT_shader_tile_image</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_subpass_merge_feedback.html">VK_EXT_subpass_merge_feedback</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_surface_maintenance1.html">VK_EXT_surface_maintenance1</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_swapchain_maintenance1.html">VK_EXT_swapchain_maintenance1</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_GOOGLE_surfaceless_query.html">VK_GOOGLE_surfaceless_query</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_HUAWEI_cluster_culling_shader.html">VK_HUAWEI_cluster_culling_shader</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_HUAWEI_invocation_mask.html">VK_HUAWEI_invocation_mask</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_compute_shader_derivatives.html">VK_KHR_compute_shader_derivatives</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_cooperative_matrix.html">VK_KHR_cooperative_matrix</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_dynamic_rendering.html">VK_KHR_dynamic_rendering</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_dynamic_rendering_local_read.html">VK_KHR_dynamic_rendering_local_read</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_fragment_shader_barycentric.html">VK_KHR_fragment_shader_barycentric</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_fragment_shading_rate.html">VK_KHR_fragment_shading_rate</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_load_store_op_none.html">VK_KHR_load_store_op_none</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_maintenance5.html">VK_KHR_maintenance5</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_maintenance6.html">VK_KHR_maintenance6</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_maintenance7.html">VK_KHR_maintenance7</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_maintenance8.html">VK_KHR_maintenance8</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_map_memory2.html">VK_KHR_map_memory2</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_pipeline_binary.html">VK_KHR_pipeline_binary</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_ray_tracing_position_fetch.html">VK_KHR_ray_tracing_position_fetch</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_shader_expect_assume.html">VK_KHR_shader_expect_assume</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_shader_float_controls2.html">VK_KHR_shader_float_controls2</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_shader_integer_dot_product.html">VK_KHR_shader_integer_dot_product</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_shader_maximal_reconvergence.html">VK_KHR_shader_maximal_reconvergence</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_shader_quad_control.html">VK_KHR_shader_quad_control</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_shader_relaxed_extended_instruction.html">VK_KHR_shader_relaxed_extended_instruction</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_shader_subgroup_rotate.html">Subgroup rotation instruction</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_vertex_attribute_divisor.html">VK_KHR_vertex_attribute_divisor</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_video_decode_av1.html">VK_KHR_video_decode_av1</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_video_decode_h264.html">VK_KHR_video_decode_h264</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_video_decode_h265.html">VK_KHR_video_decode_h265</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_video_decode_queue.html">VK_KHR_video_decode_queue</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_video_encode_av1.html">VK_KHR_video_encode_av1</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_video_encode_h264.html">VK_KHR_video_encode_h264</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_video_encode_h265.html">VK_KHR_video_encode_h265</a>
  </li>
  <li class="nav-item is-current-page" data-depth="2">
    <a class="nav-link" href="VK_KHR_video_encode_quantization_map.html">VK_KHR_video_encode_quantization_map</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_video_encode_queue.html">VK_KHR_video_encode_queue</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_video_maintenance1.html">VK_KHR_video_maintenance1</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_video_queue.html">VK_KHR_video_queue</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_LUNARG_direct_driver_loading.html">VK_LUNARG_direct_driver_loading</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_MSFT_layered_driver.html">VK_MSFT_layered_driver</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_NV_cooperative_matrix2.html">VK_NV_cooperative_matrix2</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_NV_display_stereo.html">VK_NV_display_stereo</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_NV_ray_tracing_validation.html">VK_NV_ray_tracing_validation</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_QCOM_image_processing.html">VK_QCOM_image_processing</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_QCOM_tile_properties.html">VK_QCOM_tile_properties</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_VERSION_1_4.html">Vulkan 1.4</a>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Vulkan Feature Descriptions</span>
    <span class="version">latest</span>
  </div>
  <ul class="components">
    <li class="component">
      <div class="title"><a href="../../../../tutorial/latest/00_Introduction.html">Khronos Vulkan Tutorial</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../../tutorial/latest/00_Introduction.html">latest</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../../../glsl/latest/index.html">OpenGL Shading Language Specification</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../../glsl/latest/index.html">latest</a>
        </li>
      </ul>
    </li>
    <li class="component is-current">
      <div class="title"><a href="../index.html">Vulkan Feature Descriptions</a></div>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="../index.html">latest</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../../../guide/latest/index.html">Vulkan Guide</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../../guide/latest/index.html">latest</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../../../samples/latest/README.html">Vulkan Samples</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../../samples/latest/README.html">latest</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../../../spec/latest/index.html">Vulkan Specification</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../../spec/latest/index.html">latest</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../../../../spec/latest/index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../index.html">Vulkan Feature Descriptions</a></li>
    <li>Feature Descriptions</li>
    <li><a href="VK_KHR_video_encode_quantization_map.html">VK_KHR_video_encode_quantization_map</a></li>
  </ul>
</nav>
</div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">VK_KHR_video_encode_quantization_map</h1>
<div id="toc" class="toc">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_problem_statement">1. Problem Statement</a></li>
<li><a href="#_solution_space">2. Solution Space</a></li>
<li><a href="#_proposal">3. Proposal</a>
<ul class="sectlevel2">
<li><a href="#_new_video_profile_capabilities">3.1. New Video Profile Capabilities</a></li>
<li><a href="#_new_image_usage_flags">3.2. New Image Usage Flags</a></li>
<li><a href="#_new_format_feature_flags">3.3. New Format Feature Flags</a></li>
<li><a href="#_quantization_map_capabilities">3.4. Quantization Map Capabilities</a></li>
<li><a href="#_querying_quantization_map_formats">3.5. Querying Quantization Map Formats</a></li>
<li><a href="#_codec_specific_details">3.6. Codec-Specific Details</a></li>
<li><a href="#_using_quantization_maps">3.7. Using Quantization Maps</a></li>
</ul>
</li>
<li><a href="#_examples">4. Examples</a>
<ul class="sectlevel2">
<li><a href="#_enumerate_supported_quantization_map_formats_for_a_video_profile">4.1. Enumerate supported quantization map formats for a video profile</a></li>
<li><a href="#_using_quantization_maps_2">4.2. Using quantization maps</a></li>
</ul>
</li>
<li><a href="#_issues">5. Issues</a>
<ul class="sectlevel2">
<li><a href="#_resolved_do_we_need_separate_extensions_for_each_video_codec">5.1. RESOLVED: Do we need separate extensions for each video codec?</a></li>
<li><a href="#_resolved_how_should_quantization_maps_be_provided_to_the_implementation">5.2. RESOLVED: How should quantization maps be provided to the implementation?</a></li>
<li><a href="#_resolved_can_all_implementations_support_quantization_delta_maps_or_do_some_implementations_only_support_absolute_quantization_maps">5.3. RESOLVED: Can all implementations support quantization delta maps, or do some implementations only support absolute quantization maps?</a></li>
<li><a href="#_resolved_are_quantization_parameters_clamped_to_the_allowed_range_before_or_after_applying_the_quantization_map">5.4. RESOLVED: Are quantization parameters clamped to the allowed range before or after applying the quantization map?</a></li>
<li><a href="#_resolved_what_is_the_granularity_of_quantization_maps_i_e_the_texel_size_of_the_rectangular_blocks_each_quantization_control_value_applies_to">5.5. RESOLVED: What is the granularity of quantization maps (i.e. the texel size of the rectangular blocks each quantization control value applies to)?</a></li>
<li><a href="#_resolved_should_we_report_the_supported_quantization_map_granularities_through_individual_entries_as_a_vkextent2d_or_should_we_use_a_bitmask_where_each_flag_corresponds_to_a_supported_block_size">5.6. RESOLVED: Should we report the supported quantization map granularities through individual entries as a <code>VkExtent2D</code> or should we use a bitmask where each flag corresponds to a supported block size?</a></li>
<li><a href="#_resolved_do_we_need_a_capability_for_the_maximum_extent_of_quantization_maps">5.7. RESOLVED: Do we need a capability for the maximum extent of quantization maps?</a></li>
<li><a href="#_resolved_can_subregions_of_a_larger_image_be_used_as_a_quantization_map">5.8. RESOLVED: Can subregions of a larger image be used as a quantization map?</a></li>
<li><a href="#_resolved_should_we_require_an_opt_in_at_video_session_creation_time_to_use_quantization_maps">5.9. RESOLVED: Should we require an opt-in at video session creation time to use quantization maps?</a></li>
<li><a href="#_resolved_can_applications_use_quantization_maps_only_on_a_subset_of_the_pictures_encoded_within_a_video_stream">5.10. RESOLVED: Can applications use quantization maps only on a subset of the pictures encoded within a video stream?</a></li>
<li><a href="#_resolved_why_does_this_proposal_introduce_the_vk_video_encode_h264_capability_mb_qp_diff_wraparound_bit_khr_capability_flag">5.11. RESOLVED: Why does this proposal introduce the <code>VK_VIDEO_ENCODE_H264_CAPABILITY_MB_QP_DIFF_WRAPAROUND_BIT_KHR</code> capability flag?</a></li>
<li><a href="#_resolved_why_does_this_proposal_introduce_the_vk_video_encode_h265_capability_cu_qp_diff_wraparound_bit_khr_capability_flag">5.12. RESOLVED: Why does this proposal introduce the <code>VK_VIDEO_ENCODE_H265_CAPABILITY_CU_QP_DIFF_WRAPAROUND_BIT_KHR</code> capability flag?</a></li>
</ul>
</li>
</ul>
</div>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>This document outlines a proposal that enables fine grained control of codec-specific quantization parameters in video encode operations.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_problem_statement"><a class="anchor" href="#_problem_statement"></a>1. Problem Statement</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Currently, the video encode extensions support the following application control over the codec-specific quantization parameters used by encoder implementations:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Specifying explicit quantization parameters for individual codec-specific picture subregions when rate control is disabled (e.g. in case of H.264 encode, specifying a constant QP value to use for each slice)</p>
</li>
<li>
<p>Specifying the range of quantization parameters the implementation can use when rate control is enabled (e.g. in case of H.264 encode, specifying minimum and maximum QP values to use for each picture type)</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>However, it is common for applications to need finer control over the selection of quantization parameters to improve the quality in specific regions of the pictures or to better control the distribution of bitstream budget between high-frequency and low-frequency picture regions.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_solution_space"><a class="anchor" href="#_solution_space"></a>2. Solution Space</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The following new controls have been considered for inclusion in this proposal:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Enable specifying explicit quantization parameters for individual regions of the encoded picture at a finer granularity when rate control is disabled</p>
</li>
<li>
<p>Enable specifying quantization adjustment values for individual regions of the encoded picture when rate control is enabled</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>As there are implementations that support all of these controls, it is desired to enable support for all of them.</p>
</div>
<div class="paragraph">
<p>The following options have been considered to express the mapping of application-specified quantization adjustment parameters to individual regions of the encoded picture for (1) and (2):</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Use a quantization map (2D grid of quantization adjustment parameters) that control the quantization parameters for individual grid-aligned rectangular blocks of the encoded picture (e.g. on a per coding block basis)</p>
</li>
<li>
<p>Specify a list of (overlapping or non-overlapping) rectangular regions and corresponding quantization adjustment parameters to use</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Support for quantization maps is common, but implementations supporting quantization rectangle lists are not. While specifying quantization adjustment parameters for list of rectangles can typically be implemented in terms of quantization maps, this proposal does not include support for them in order to limit the scope of this proposal and to avoid encoders having to implement them through emulation.</p>
</div>
<div class="paragraph">
<p>When it comes to the form in which quantization adjustment parameters are specified, the following options have been considered:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Specify absolute quantization parameter values (e.g. in case of H.264 encode, specify a map of absolute QP values to use for individual regions)</p>
</li>
<li>
<p>Specify relative quantization parameter values (e.g. in case of H.264 encode, specify a map of QP delta values to add/subtract from the QP values that would otherwise be used according to the current rate control configuration)</p>
</li>
<li>
<p>Specify relative "emphasis" values that indirectly control the relative quantization parameter values chosen by the implementation, indicating the "importance" of individual regions</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Specifying absolute quantization parameter values only makes sense when rate control is disabled. However, as existing APIs already provide controls to set the absolute value of quantization parameters at various codec-specific granularities, supporting absolute quantization maps seems unnecessary, as the same effect can be achieved by combining existing absolute quantization parameter controls with a quantization delta map (e.g. in case of H.264 encode, per-slice constant QP can be combined with a QP delta map to achieve the same effect as an absolute QP map could provide).</p>
</div>
<div class="paragraph">
<p>Accordingly, this proposal suggests to introduce the following new controls:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The ability to specify quantization delta maps to directly control the relative quantization parameter values on a per-block basis for all rate control modes (including when rate control is disabled)</p>
</li>
<li>
<p>The ability to specify "emphasis" maps to indirectly control the relative quantization parameter values on a per-block basis when rate control is enabled</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_proposal"><a class="anchor" href="#_proposal"></a>3. Proposal</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_new_video_profile_capabilities"><a class="anchor" href="#_new_video_profile_capabilities"></a>3.1. New Video Profile Capabilities</h3>
<div class="paragraph">
<p>The new capabilities of this proposal are exposed through video encode profile capability flags in <code>VkVideoEncodeCapabilitiesKHR::flags</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>VK_VIDEO_ENCODE_CAPABILITY_QUANTIZATION_DELTA_MAP_BIT_KHR</code> indicates support for quantization delta maps (e.g. in case of H.264 encode, support for QP delta maps)</p>
</li>
<li>
<p><code>VK_VIDEO_ENCODE_CAPABILITY_EMPHASIS_MAP_BIT_KHR</code> indicates support for emphasis maps</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>These video encode capability flags can only be exposed for video encode profiles targeting video codecs for which the extension defines the codec-specific behavior.</p>
</div>
<div class="paragraph">
<p>The following additional H.264 encode profile capability is introduced:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>VK_VIDEO_ENCODE_H264_CAPABILITY_MB_QP_DIFF_WRAPAROUND_BIT_KHR</code> indicates support for wraparound during the calculation of the QP values of subsequent macroblocks</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If the implementation does not support <code>VK_VIDEO_ENCODE_H264_CAPABILITY_MB_QP_DIFF_WRAPAROUND_BIT_KHR</code> then the maximum QP difference across subsequent macroblocks is limited to the [-(26 + QpBdOffsetY / 2), 25 + QpBdOffsetY / 2] range.</p>
</div>
<div class="paragraph">
<p>Similarly, the following additional H.265 encode profile capability is introduced:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>VK_VIDEO_ENCODE_H265_CAPABILITY_CU_QP_DIFF_WRAPAROUND_BIT_KHR</code> indicates support for wraparound during the calculation of the QP values of subsequent coding units</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If the implementation does not support <code>VK_VIDEO_ENCODE_H265_CAPABILITY_CU_QP_DIFF_WRAPAROUND_BIT_KHR</code> then the maximum QP difference across subsequent coding units is limited to the [-(26 + QpBdOffsetY / 2), 25 + QpBdOffsetY / 2] range.</p>
</div>
</div>
<div class="sect2">
<h3 id="_new_image_usage_flags"><a class="anchor" href="#_new_image_usage_flags"></a>3.2. New Image Usage Flags</h3>
<div class="paragraph">
<p>Quantization delta maps and emphasis maps are represented by image objects. Accordingly, this proposal introduces the following new image usage flags:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>VK_IMAGE_USAGE_VIDEO_ENCODE_QUANTIZATION_DELTA_MAP_BIT_KHR</code> to request quantization delta map usage</p>
</li>
<li>
<p><code>VK_IMAGE_USAGE_VIDEO_ENCODE_EMPHASIS_MAP_BIT_KHR</code> to request emphasis map usage</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Just like in case of other video-specific image usages, support for these flags and their use in combination with other image parameters depends on the used video profile and thus the set of supported image formats and other creation parameters for them can be enumerated using the <code>vkGetPhysicalDeviceVideoFormatPropertiesKHR</code> command, as discussed later.</p>
</div>
<div class="paragraph">
<p>This proposal also introduces a new optimal image layout to use with quantization maps called <code>VK_IMAGE_LAYOUT_VIDEO_ENCODE_QUANTIZATION_MAP_KHR</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_new_format_feature_flags"><a class="anchor" href="#_new_format_feature_flags"></a>3.3. New Format Feature Flags</h3>
<div class="paragraph">
<p>To indicate which formats are compatible with the new video encode usage flags, the following new format feature flags are introduced:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>VK_FORMAT_FEATURE_2_VIDEO_ENCODE_QUANTIZATION_DELTA_MAP_BIT_KHR</code> indicates support for quantization delta map usage</p>
</li>
<li>
<p><code>VK_FORMAT_FEATURE_2_VIDEO_ENCODE_EMPHASIS_MAP_BIT_KHR</code> indicates support for emphasis map usage</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Just like in case of other video-specific format features, the presence of the format flags alone, as returned by the various format queries, is not sufficient to indicate that an image with that format is usable with video encoding using any particular video encode profile. Actual compatibility with a specific video encode profile has to be verified using the <code>vkGetPhysicalDeviceVideoFormatPropertiesKHR</code> command, as discussed later.</p>
</div>
</div>
<div class="sect2">
<h3 id="_quantization_map_capabilities"><a class="anchor" href="#_quantization_map_capabilities"></a>3.4. Quantization Map Capabilities</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">typedef struct VkVideoEncodeQuantizationMapCapabilitiesKHR {
    VkStructureType       sType;
    void*                 pNext;
    VkExtent2D            maxQuantizationMapExtent;
} VkVideoEncodeQuantizationMapCapabilitiesKHR;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>maxQuantizationMapExtent</code> is the maximum extent of quantization map images.</p>
</div>
<div class="paragraph">
<p>Quantization maps have additional restrictions compared to other Vulkan images: they have to be 2D, single sampled images with no mip levels, and they are limited to the maximum extent indicated by <code>maxQuantizationMapExtent</code> as well as any video coding specific format restrictions, as returned by a corresponding call to <code>vkGetPhysicalDeviceVideoFormatPropertiesKHR</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_querying_quantization_map_formats"><a class="anchor" href="#_querying_quantization_map_formats"></a>3.5. Querying Quantization Map Formats</h3>
<div class="paragraph">
<p>As with all other video coding image usage flags, applications can query the list of supported formats for quantization delta maps and emphasis maps by specifying the corresponding image usage flag in the <code>VkPhysicalDeviceVideoFormatInfoKHR</code> structure passed to <code>vkGetPhysicalDeviceVideoFormatPropertiesKHR</code>.</p>
</div>
<div class="paragraph">
<p>In addition to the common video format properties returned in <code>VkVideoFormatPropertiesKHR</code>, the following additional properties are returned for quantization maps:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">typedef struct VkVideoFormatQuantizationMapPropertiesKHR {
    VkStructureType       sType;
    void*                 pNext;
    VkExtent2D            quantizationMapTexelSize;
} VkVideoFormatQuantizationMapPropertiesKHR;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>quantizationMapTexelSize</code> is the size of the block of encode picture texels corresponding to each texel in the quantization map (i.e. the granularity).</p>
</div>
<div class="paragraph">
<p>Emphasis maps always have single channel unsigned normalized integer format and <code>VK_FORMAT_R8_UNORM</code> is always supported, while quantization delta map formats are codec-specific in nature.</p>
</div>
</div>
<div class="sect2">
<h3 id="_codec_specific_details"><a class="anchor" href="#_codec_specific_details"></a>3.6. Codec-Specific Details</h3>
<div class="paragraph">
<p>This section describes the details for all video codecs supported by this proposal.</p>
</div>
<div class="sect3">
<h4 id="_h_264_encode"><a class="anchor" href="#_h_264_encode"></a>3.6.1. H.264 Encode</h4>
<div class="paragraph">
<p>In case of H.264 encode profiles, quantization delta maps are expected to contain QP delta values and thus the supported formats will always be single channel integer formats. The final QP value used to encode individual H.264 macroblocks is calculated by applying the QP delta map value corresponding to the macroblock as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If rate control is disabled, the final QP value is the sum of the QP delta map value and the constant QP value specified for the slice in question</p>
</li>
<li>
<p>If rate control is enabled, the QP value is the sum of the QP delta map value and the QP value determined by rate control, and the final QP value is clamped to the range of QP values allowed based on the profile capabilities and the configured rate control settings</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The allowed range of values that can be used in the texels of the QP delta map can be retrieved by including the following new structure in the <code>pNext</code> chain of <code>VkVideoCapabilitiesKHR</code> when calling <code>vkGetPhysicalDeviceVideoCapabilitiesKHR</code> with an H.264 encode profile:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">typedef struct VkVideoEncodeH264QuantizationMapCapabilitiesKHR {
    VkStructureType       sType;
    void*                 pNext;
    int32_t               minQpDelta;
    int32_t               maxQpDelta;
} VkVideoEncodeH264QuantizationMapCapabilitiesKHR;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_h_265_encode"><a class="anchor" href="#_h_265_encode"></a>3.6.2. H.265 Encode</h4>
<div class="paragraph">
<p>In case of H.265 encode profiles, quantization delta maps are expected to contain QP delta values and thus the supported formats will always be single channel integer formats. The final QP value used to encode individual H.265 coding blocks is calculated by applying the QP delta map value corresponding to the coding block as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If rate control is disabled, the final QP value is the sum of the QP delta map value and the constant QP value specified for the slice segment in question</p>
</li>
<li>
<p>If rate control is enabled, the QP value is the sum of the QP delta map value and the QP value determined by rate control, and the final QP value is clamped to the range of QP values allowed based on the profile capabilities and the configured rate control settings</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The allowed range of values that can be used in the texels of the QP delta map can be retrieved by including the following new structure in the <code>pNext</code> chain of <code>VkVideoCapabilitiesKHR</code> when calling <code>vkGetPhysicalDeviceVideoCapabilitiesKHR</code> with an H.265 encode profile:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">typedef struct VkVideoEncodeH265QuantizationMapCapabilitiesKHR {
    VkStructureType                     sType;
    void*                               pNext;
    int32_t                             minQpDelta;
    int32_t                             maxQpDelta;
} VkVideoEncodeH265QuantizationMapCapabilitiesKHR;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The H.265 video compression standard allows for different CTB sizes. Some implementations support different quantization map texel sizes depending on the effective CTB size, as indicated in the active SPS. Accordingly, this proposal also includes information about the CTB sizes a particular quantization map video format is compatible with. This is returned in the <code>compatibleCtbSizes</code> member of the following new structure that can be included in the <code>pNext</code> chain of <code>VkVideoFormatPropertiesKHR</code> when calling <code>vkGetPhysicalDeviceVideoFormatPropertiesKHR</code> with an H.265 encode profile and with <code>VkPhysicalDeviceVideoFormatInfoKHR::imageUsage</code> including one of the quantization map usage flags:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">typedef struct VkVideoFormatH265QuantizationMapPropertiesKHR {
    VkStructureType                     sType;
    void*                               pNext;
    VkVideoEncodeH265CtbSizeFlagsKHR    compatibleCtbSizes;
} VkVideoFormatH265QuantizationMapPropertiesKHR;</code></pre>
</div>
</div>
<div class="paragraph">
<p>On implementations where the quantization map texel size is independent from the used CTB size, <code>compatibleCtbSizes</code> is expected to match <code>VkVideoEncodeH265CapabilitiesKHR::ctbSizes</code> (assuming quantization maps are supported for all CTB sizes supported by the video profile).</p>
</div>
<div class="paragraph">
<p>On implementations where the quantization map texel size depends on the used CTB size, separate entries will be returned by <code>vkGetPhysicalDeviceVideoFormatPropertiesKHR</code> with different values returned in <code>compatibleCtbSizes</code>.</p>
</div>
<div class="paragraph">
<p><code>compatibleCtbSizes</code> does not limit the application from using any specific quantization map texel size supported by the implementation, but the used quantization map texel size may have an effect on codec-specific parameter overrides that the implementation has to perform as the use of certain quantization map texel sizes may limit the set of H.265 coding block or CTB sizes the implementation can encode with, which may require corresponding overrides in the H.265 SPS and PPS parameters.</p>
</div>
</div>
<div class="sect3">
<h4 id="_av1_encode"><a class="anchor" href="#_av1_encode"></a>3.6.3. AV1 Encode</h4>
<div class="paragraph">
<p>In case of AV1 encode profiles, quantization delta maps are expected to contain quantizer index delta values and thus the supported formats will always be single channel integer formats. The final quantizer index value used to encode individual AV1 blocks is calculated by applying the quantizer index delta map value corresponding to the block as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If rate control is disabled, the final quantizer index value is the sum of the quantizer index delta map value and the constant quantizer index value specified for the frame</p>
</li>
<li>
<p>If rate control is enabled, the quantizer index value is the sum of the quantizer index delta map value and the quantizer index value determined by rate control, and the final quantizer index value is clamped to the range of quantizer index values allowed based on the profile capabilities and the configured rate control settings</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The allowed range of values that can be used in the texels of the quantizer index delta map can be retrieved by including the following new structure in the <code>pNext</code> chain of <code>VkVideoCapabilitiesKHR</code> when calling <code>vkGetPhysicalDeviceVideoCapabilitiesKHR</code> with an AV1 encode profile:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">typedef struct VkVideoEncodeAV1QuantizationMapCapabilitiesKHR {
    VkStructureType                     sType;
    void*                               pNext;
    int32_t                             minQIndexDelta;
    int32_t                             maxQIndexDelta;
} VkVideoEncodeAV1QuantizationMapCapabilitiesKHR;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The AV1 video compression standard allows for different superblock sizes. Some implementations support different quantization map texel sizes depending on the effective superblock size, as indicated in the active sequence header. Accordingly, this proposal also includes information about the superblock sizes a particular quantization map video format is compatible with. This is returned in the <code>compatibleSuperblockSizes</code> member of the following new structure that can be included in the <code>pNext</code> chain of <code>VkVideoFormatPropertiesKHR</code> when calling <code>vkGetPhysicalDeviceVideoFormatPropertiesKHR</code> with an AV1 encode profile and with <code>VkPhysicalDeviceVideoFormatInfoKHR::imageUsage</code> including one of the quantization map usage flags:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">typedef struct VkVideoFormatAV1QuantizationMapPropertiesKHR {
    VkStructureType                         sType;
    void*                                   pNext;
    VkVideoEncodeAV1SuperblockSizeFlagsKHR  compatibleSuperblockSizes;
} VkVideoFormatAV1QuantizationMapPropertiesKHR;</code></pre>
</div>
</div>
<div class="paragraph">
<p>On implementations where the quantization map texel size is independent from the used superblock size, <code>compatibleSuperblockSizes</code> is expected to match <code>VkVideoEncodeAV1CapabilitiesKHR::superblockSizes</code> (assuming quantization maps are supported for all superblock sizes supported by the video profile).</p>
</div>
<div class="paragraph">
<p>On implementations where the quantization map texel size depends on the used superblock size, separate entries will be returned by <code>vkGetPhysicalDeviceVideoFormatPropertiesKHR</code> with different values returned in <code>compatibleSuperblockSizes</code>.</p>
</div>
<div class="paragraph">
<p><code>compatibleSuperblockSizes</code> does not limit the application from using any specific quantization map texel size supported by the implementation, but the used quantization map texel size may have an effect on codec-specific parameter overrides that the implementation has to perform as the use of certain quantization map texel sizes may limit the set of AV1 superblock sizes the implementation can encode with, which may require corresponding overrides in the AV1 sequence header parameters.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_using_quantization_maps"><a class="anchor" href="#_using_quantization_maps"></a>3.7. Using Quantization Maps</h3>
<div class="paragraph">
<p>Applications have to opt in to using quantization maps in a video session using one of the following new video session creation flags:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>VK_VIDEO_SESSION_CREATE_ALLOW_ENCODE_QUANTIZATION_DELTA_MAP_BIT_KHR</code> specifies that the use of quantization delta maps in video encode operations is allowed</p>
</li>
<li>
<p><code>VK_VIDEO_SESSION_CREATE_ALLOW_ENCODE_EMPHASIS_MAP_BIT_KHR</code> specifies that the use of emphasis maps in video encode operations is allowed</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>These flags are mutually exclusive and can only be specified for video sessions created with video encode profiles supporting the corresponding capability flags and may have an impact on the device memory requirements of the video session.</p>
</div>
<div class="paragraph">
<p>Furthermore, as the use of specific quantization map texel sizes may affect the parameter overrides the implementation has to apply (e.g. overriding the range of used H.265 coding block sizes), applications have to opt in to using a specific quantization map texel size for a video session parameters object using the new <code>VK_VIDEO_SESSION_PARAMETERS_CREATE_QUANTIZATION_MAP_COMPATIBLE_BIT_KHR</code> video session parameters creation flag, and specifying the used quantization map texel size through the following new structure included in the <code>pNext</code> chain of <code>VkVideoSessionParametersCreateInfoKHR</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">typedef struct VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR {
    VkStructureType       sType;
    const void*           pNext;
    VkExtent2D            quantizationMapTexelSize;
} VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Applications can reuse the same video session with different quantization map texel sizes, however, they have to create a new video session parameters object specific to each quantization map texel size in order to switch between them across video sequences.</p>
</div>
<div class="paragraph">
<p>The use of quantization maps in individual video encode commands is requested by specifying one of the following new flags in <code>VkVideoEncodeInfoKHR::flags</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>VK_VIDEO_ENCODE_WITH_QUANTIZATION_DELTA_MAP_BIT_KHR</code> indicates the use of a quantization delta map in the video encode operations</p>
</li>
<li>
<p><code>VK_VIDEO_ENCODE_WITH_EMPHASIS_MAP_BIT_KHR</code> indicates the use of an emphasis map in the video encode operations</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When either of these flags is specified, the following new structure included in the <code>pNext</code> chain of <code>VkVideoEncodeInfoKHR</code> is used to specify the quantization map resource itself:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">typedef struct VkVideoEncodeQuantizationMapInfoKHR {
    VkStructureType       sType;
    const void*           pNext;
    VkImageView           quantizationMap;
    VkExtent2D            quantizationMapExtent;
} VkVideoEncodeQuantizationMapInfoKHR;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_examples"><a class="anchor" href="#_examples"></a>4. Examples</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_enumerate_supported_quantization_map_formats_for_a_video_profile"><a class="anchor" href="#_enumerate_supported_quantization_map_formats_for_a_video_profile"></a>4.1. Enumerate supported quantization map formats for a video profile</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">uint32_t formatCount;

VkVideoProfileInfoKHR profileInfo = {
    ...
};

VkVideoProfileListInfoKHR profileListInfo = {
    .sType = VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR,
    .pNext = NULL,
    .profileCount = 1,
    .pProfiles = &amp;profileInfo
};

VkPhysicalDeviceVideoFormatInfoKHR formatInfo = {
    .sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_FORMAT_INFO_KHR,
    .pNext = &amp;profileListInfo,
    .imageUsage = VK_IMAGE_USAGE_VIDEO_ENCODE_{QUANTIZATION_DELTA|EMPHASIS}_MAP_BIT_KHR
};

vkGetPhysicalDeviceVideoFormatPropertiesKHR(physicalDevice, &amp;formatInfo, &amp;formatCount, NULL);

VkVideoFormatPropertiesKHR* formatProps = calloc(formatCount, sizeof(VkVideoFormatPropertiesKHR));
VkVideoFormatQuantizationMapPropertiesKHR* quantizationMapProps = calloc(formatCount, sizeof(VkVideoFormatQuantizationMapPropertiesKHR));

for (uint32_t i = 0; i &lt; formatCount; ++i) {
    formatProps[i].sType = VK_STRUCTURE_TYPE_VIDEO_FORMAT_PROPERTIES_KHR;
    formatProps[i].pNext = &amp;quantizationMapProps[i];

    quantizationMapProps[i].sType = VK_STRUCTURE_TYPE_VIDEO_FORMAT_QUANTIZATION_MAP_PROPERTIES_KHR;
    quantizationMapProps[i].pNext = ... // include any additional codec-specific properties
                                        // for H.265 encode, VkVideoFormatH265QuantizationMapPropertiesKHR can be included
}

vkGetPhysicalDeviceVideoFormatPropertiesKHR(physicalDevice, &amp;formatInfo, &amp;formatCount, formatProps);

for (uint32_t i = 0; i &lt; formatCount; ++i) {
    // Find format and image creation capabilities best suited for the use case
    // For H.265 encode this can also involve finding an entry that is compatible with the CTB sizes the application prefers to encode with
    ...
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_using_quantization_maps_2"><a class="anchor" href="#_using_quantization_maps_2"></a>4.2. Using quantization maps</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">// Create video session with quantization map support
VkVideoSessionKHR videoSession = VK_NULL_HANDLE;
VkVideoSessionCreateInfoKHR videoSessionCreateInfo = { ... };
// Include the corresponding session creation flag
videoSessionCreateInfo.flags |= VK_VIDEO_SESSION_CREATE_ALLOW_ENCODE_{QUANTIZATION_DELTA|EMPHASIS}_MAP_BIT_KHR;
vkCreateVideoSessionKHR(device, &amp;videoSessionCreateInfo, NULL, &amp;videoSession);

// Create video session parameters against the used quantization map texel size
VkVideoSessionParametersKHR videoSessionParameters = VK_NULL_HANDLE;
VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR vspQuantizationMapInfo = {
    .sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_SESSION_PARAMETERS_CREATE_INFO_KHR,
    .pNext = ... // pointer to additional video session parameters create infos
    .quantizationMapTexelSize = ... // one of the supported texel sizes reported by vkGetPhysicalDeviceVideoFormatPropertiesKHR
};
VkVideoSessionParametersCreateInfoKHR videoSessionParametersCreateInfo = {
    .sType = VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_CREATE_INFO_KHR,
    .pNext = &amp;vspQuantizationMapInfo,
    .flags = VK_VIDEO_SESSION_PARAMETERS_CREATE_QUANTIZATION_MAP_COMPATIBLE_BIT_KHR | ...
    ...
};
vkCreateVideoSessionParametersKHR(device, &amp;videoSessionParametersCreateInfo, NULL, &amp;videoSessionParameters);

// Create quantization map image and image view
VkImage image = VK_NULL_HANDLE;
VkImageView imageView = VK_NULL_HANDLE;
VkImageCreateInfo imageCreateInfo = { ... };
// Include the corresponding image usage flag
imageCreateInfo.usage |= VK_IMAGE_USAGE_VIDEO_ENCODE_{QUANTIZATION_DELTA|EMPHASIS}_MAP_BIT_KHR;
vkCreateImage(device, &amp;imageCreateInfo, NULL, &amp;image);
...
vkCreateImageView(device, &amp;imageViewCreateInfo, NULL, &amp;imageView);

// Fill quantization map (e.g. with a compute shader, or using the CPU directly or with an intermediate transfer)
...

// Encode frame using quantization map
vkCmdBeginVideoCodingKHR(commandBuffer, ...);

VkVideoEncodeQuantizationMapInfoKHR encodeQuantizationMapInfo = {
    .sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_INFO_KHR,
    .pNext = ... // pointer to codec-specific picture information structure
    .quantizationMap = imageView,
    .quantizationMapExtent = ... // the extent of the quantization map
}

VkVideoEncodeInfoKHR encodeInfo = {
    .sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_INFO_KHR,
    .pNext = &amp;encodeQuantizationMapInfo,
    .flags = VK_VIDEO_ENCODE_WITH_{QUANTIZATION_DELTA|EMPHASIS}_MAP_BIT_KHR,
    ...
};

vkCmdEncodeVideoKHR(commandBuffer, &amp;encodeInfo);

vkCmdEndVideoCodingKHR(commandBuffer, ...);</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_issues"><a class="anchor" href="#_issues"></a>5. Issues</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_resolved_do_we_need_separate_extensions_for_each_video_codec"><a class="anchor" href="#_resolved_do_we_need_separate_extensions_for_each_video_codec"></a>5.1. RESOLVED: Do we need separate extensions for each video codec?</h3>
<div class="paragraph">
<p>No. While quantization parameter formats and semantics are specific to individual video codecs, the general mechanism is uniform enough to cover support for all video codecs using a single extension. The first revision of this extension covers all currently supported video encode profiles and requires that the new video encode profile capabilities must not be exposed for any video encode profile targeting a codec for which this extension does not specify any specific behavior. This enables future revisions of this extension to introduce support for new video codecs without any backward- or forward-compatibility issues.</p>
</div>
</div>
<div class="sect2">
<h3 id="_resolved_how_should_quantization_maps_be_provided_to_the_implementation"><a class="anchor" href="#_resolved_how_should_quantization_maps_be_provided_to_the_implementation"></a>5.2. RESOLVED: How should quantization maps be provided to the implementation?</h3>
<div class="paragraph">
<p>The following options were considered:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Provide the quantization maps as a two-dimensional array to encode commands (i.e. as host buffers)</p>
</li>
<li>
<p>Provide the quantization maps as buffers to encode commands (i.e. as a device resource with transparent representation)</p>
</li>
<li>
<p>Provide the quantization maps as images to encode commands (i.e. as a device resource with potentially opaque representation)</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Options (2) and (3) provide the additional flexibility that the quantization maps can be efficiently device-generated. Considering that it is common to do so through device-side analysis of the encode input picture, option (1) did not seem reasonable.</p>
</div>
<div class="paragraph">
<p>This proposal chose (3), as the representation, including the format and layout of these maps may be implementation-specific. This still leaves the possibility of transparent representations open, as implementations can choose to expose support for quantization maps in the form of pitch-linear images.</p>
</div>
</div>
<div class="sect2">
<h3 id="_resolved_can_all_implementations_support_quantization_delta_maps_or_do_some_implementations_only_support_absolute_quantization_maps"><a class="anchor" href="#_resolved_can_all_implementations_support_quantization_delta_maps_or_do_some_implementations_only_support_absolute_quantization_maps"></a>5.3. RESOLVED: Can all implementations support quantization delta maps, or do some implementations only support absolute quantization maps?</h3>
<div class="paragraph">
<p>Yes. In order to support quantization delta maps when rate control is disabled, implementations only have to support combining the quantization delta values in the quantization map with the absolute quantization parameters specified for the picture (e.g. the per-slice constant QP value for H.264 encode).</p>
</div>
</div>
<div class="sect2">
<h3 id="_resolved_are_quantization_parameters_clamped_to_the_allowed_range_before_or_after_applying_the_quantization_map"><a class="anchor" href="#_resolved_are_quantization_parameters_clamped_to_the_allowed_range_before_or_after_applying_the_quantization_map"></a>5.4. RESOLVED: Are quantization parameters clamped to the allowed range before or after applying the quantization map?</h3>
<div class="paragraph">
<p>After applying the quantization map.</p>
</div>
<div class="paragraph">
<p>When rate control is disabled, the sum of the quantization map value and the picture&#8217;s quantization value (e.g. the per-slice constant QP value for H.264 encode) is clamped to the supported range of quantization values, as returned in the corresponding codec-specific video profile capabilities.</p>
</div>
<div class="paragraph">
<p>When rate control is enabled, the sum of the quantization map value and the quantization value determined by rate control is clamped to the supported rate of quantization values, as returned in the corresponding codec-specific video profile capabilities. If the supported range is restricted to a subrange in the rate control configuration, then this value is further clamped to that subrange.</p>
</div>
</div>
<div class="sect2">
<h3 id="_resolved_what_is_the_granularity_of_quantization_maps_i_e_the_texel_size_of_the_rectangular_blocks_each_quantization_control_value_applies_to"><a class="anchor" href="#_resolved_what_is_the_granularity_of_quantization_maps_i_e_the_texel_size_of_the_rectangular_blocks_each_quantization_control_value_applies_to"></a>5.5. RESOLVED: What is the granularity of quantization maps (i.e. the texel size of the rectangular blocks each quantization control value applies to)?</h3>
<div class="paragraph">
<p>Different implementations have different answers to this question:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Some implementations use fixed size blocks</p>
</li>
<li>
<p>Some implementations allow the granularity to be selected from a range of different block sizes</p>
</li>
<li>
<p>Some implementations require the quantization map block size to match codec-specific coding block sizes</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Supporting a common block size thus would require implicit conversions of the quantization maps or other potentially expensive operations that may not even be supportable on implementations without appropriate format conversion capabilities.</p>
</div>
<div class="paragraph">
<p>Accordingly, this granularity cannot be a simple video profile capability, and may even depend on other codec-specific parameters (for example, the codec-specific block size for codecs like H.265 which support multiple CTB sizes).</p>
</div>
<div class="paragraph">
<p>This proposal reuses the <code>vkGetPhysicalDeviceVideoFormatPropertiesKHR</code> query with additional result structures to enable querying the list of quantization map formats and the granularity at which they need to be specified.</p>
</div>
</div>
<div class="sect2">
<h3 id="_resolved_should_we_report_the_supported_quantization_map_granularities_through_individual_entries_as_a_vkextent2d_or_should_we_use_a_bitmask_where_each_flag_corresponds_to_a_supported_block_size"><a class="anchor" href="#_resolved_should_we_report_the_supported_quantization_map_granularities_through_individual_entries_as_a_vkextent2d_or_should_we_use_a_bitmask_where_each_flag_corresponds_to_a_supported_block_size"></a>5.6. RESOLVED: Should we report the supported quantization map granularities through individual entries as a <code>VkExtent2D</code> or should we use a bitmask where each flag corresponds to a supported block size?</h3>
<div class="paragraph">
<p>Using a bitmask could avoid the need to have to return multiple entries when multiple granularities are supported for a particular input configuration, but would require enumerating all supportable granularities as flags. Instead, this proposal simply reports separate entries for each supported granularity. This also works better with the resolution of the issue above.</p>
</div>
</div>
<div class="sect2">
<h3 id="_resolved_do_we_need_a_capability_for_the_maximum_extent_of_quantization_maps"><a class="anchor" href="#_resolved_do_we_need_a_capability_for_the_maximum_extent_of_quantization_maps"></a>5.7. RESOLVED: Do we need a capability for the maximum extent of quantization maps?</h3>
<div class="paragraph">
<p>Yes. Quantization maps are expected to be much smaller than the encoded picture and some implementations only support limited extents for quantization maps. A new video profile capability indicates the maximum extent supported for quantization maps and they are expected to be as large as the maximum coded extent divided by the smallest supported quantization map texel size.</p>
</div>
</div>
<div class="sect2">
<h3 id="_resolved_can_subregions_of_a_larger_image_be_used_as_a_quantization_map"><a class="anchor" href="#_resolved_can_subregions_of_a_larger_image_be_used_as_a_quantization_map"></a>5.8. RESOLVED: Can subregions of a larger image be used as a quantization map?</h3>
<div class="paragraph">
<p>Yes. This is in line with the general design of the video coding features to allow reusing the same resources across different resolutions. However, the used quantization map subregion is always expected to start at texel offset (0,0) of the corresponding image subresource.</p>
</div>
</div>
<div class="sect2">
<h3 id="_resolved_should_we_require_an_opt_in_at_video_session_creation_time_to_use_quantization_maps"><a class="anchor" href="#_resolved_should_we_require_an_opt_in_at_video_session_creation_time_to_use_quantization_maps"></a>5.9. RESOLVED: Should we require an opt-in at video session creation time to use quantization maps?</h3>
<div class="paragraph">
<p>Yes. This may also enable some implementations to reduce the device memory usage of video sessions when there is no need to use quantization maps.</p>
</div>
</div>
<div class="sect2">
<h3 id="_resolved_can_applications_use_quantization_maps_only_on_a_subset_of_the_pictures_encoded_within_a_video_stream"><a class="anchor" href="#_resolved_can_applications_use_quantization_maps_only_on_a_subset_of_the_pictures_encoded_within_a_video_stream"></a>5.10. RESOLVED: Can applications use quantization maps only on a subset of the pictures encoded within a video stream?</h3>
<div class="paragraph">
<p>Yes. Implementations do not require quantization maps to be provided for every video encode operation.</p>
</div>
</div>
<div class="sect2">
<h3 id="_resolved_why_does_this_proposal_introduce_the_vk_video_encode_h264_capability_mb_qp_diff_wraparound_bit_khr_capability_flag"><a class="anchor" href="#_resolved_why_does_this_proposal_introduce_the_vk_video_encode_h264_capability_mb_qp_diff_wraparound_bit_khr_capability_flag"></a>5.11. RESOLVED: Why does this proposal introduce the <code>VK_VIDEO_ENCODE_H264_CAPABILITY_MB_QP_DIFF_WRAPAROUND_BIT_KHR</code> capability flag?</h3>
<div class="paragraph">
<p>Some implementations do not support the macroblock QP wraparound logic in equation 7-37 of the H.264 specification and thus cannot encode QP differences across subsequent macroblocks that are outside of the [-(26 + QpBdOffsetY / 2), 25 + QpBdOffsetY / 2] range. As this limitation has an observable effect when using QP delta maps, the presence of this capability flag is used to indicate that the implementation does not have any limitation on the QP values used across subsequent macroblocks.</p>
</div>
</div>
<div class="sect2">
<h3 id="_resolved_why_does_this_proposal_introduce_the_vk_video_encode_h265_capability_cu_qp_diff_wraparound_bit_khr_capability_flag"><a class="anchor" href="#_resolved_why_does_this_proposal_introduce_the_vk_video_encode_h265_capability_cu_qp_diff_wraparound_bit_khr_capability_flag"></a>5.12. RESOLVED: Why does this proposal introduce the <code>VK_VIDEO_ENCODE_H265_CAPABILITY_CU_QP_DIFF_WRAPAROUND_BIT_KHR</code> capability flag?</h3>
<div class="paragraph">
<p>Some implementations do not support the coding unit QP wraparound logic in equation 8-283 of the H.265 specification and thus cannot encode QP differences across subsequent coding units that are outside of the [-(26 + QpBdOffsetY / 2), 25 + QpBdOffsetY / 2] range. As this limitation has an observable effect when using QP delta maps, the presence of this capability flag is used to indicate that the implementation does not have any limitation on the QP values used across subsequent coding units.</p>
</div>
</div>
</div>
</div>
</article>
  </div>
</main>
</div>
<script id="site-script" src="../../../../_/js/site.js" data-ui-root-path="../../../../_"></script>
<script async src="../../../../_/js/vendor/highlight.js"></script>
<script src="../../../../_/js/vendor/lunr.js"></script>
<script src="https://cdn.jsdelivr.net/pako/1.0.3/pako.min.js"></script>
<script src="../../../../_/js/search-ui.js" id="search-ui-script" data-site-root-path="../../../.." data-snippet-length="100" data-stylesheet="../../../../_/css/search.css"></script>
<script async src="../../../../search-index.js"></script>
  </body>
</html>

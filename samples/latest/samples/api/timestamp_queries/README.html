<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Timestamp queries :: Vulkan Documentation Project</title>
    <meta name="generator" content="Antora 3.1.4">
    <link rel="stylesheet" href="../../../../../_/css/site.css">
    <link rel="apple-touch-icon" sizes="180x180" href="../../../../../_/img/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="../../../../../_/img/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="../../../../../_/img/favicon-16x16.png">
    <link rel="manifest" href="../../../../../_/static/site.webmanifest">
    <link rel="mask-icon" href="../../../../../_/img/safari-pinned-tab.svg" color="#a41e22">
    <meta name="msapplication-TileColor" content="#ffc40d">
    <meta name="theme-color" content="#ffffff">
    <script>var uiRootPath = '../../../../../_'</script>
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="../../../../.."><img class="navbar-item" alt="Vulkan White Label" src="../../../../../_/Vulkan_Docs.svg" /></a>
      <div class="navbar-item search hide-for-print">
        <div id="search-field" class="field">
          <label for="search-input"></label><input id="search-input" type="text" placeholder="Search the docs">
        </div>
      </div>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <!-- <a class="navbar-item" href="#">Home</a> -->
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Specs</a>
          <div class="navbar-dropdown is-right">
            <a class="navbar-item" href="../../../../../spec/latest/chapters/introduction.html">Vulkan 1.3</a>
            <a class="navbar-item" href="https://registry.khronos.org/OpenGL/specs/gl/GLSLangSpec.4.60.html">GLSL</a>
            <a class="navbar-item" href="../../../../../guide/latest/hlsl.html">HLSL</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Education</a>
          <div class="navbar-dropdown is-right">
            <a class="navbar-item" href="../../../../../guide/latest/index.html">Vulkan Guide</a>
            <a class="navbar-item" href="../../../../../tutorial/latest/index.html">Vulkan Tutorial</a>
            <a class="navbar-item" href="../../../../../samples/latest/README.html">Vulkan Samples</a>
            <a class="navbar-item" href="https://www.youtube.com/c/vulkan">YouTube</a>
            <a class="navbar-item" href="https://vulkan.org">More Info at Vulkan.org</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Community</a>
          <div class="navbar-dropdown is-right">
            <a class="navbar-item" href="https://discord.gg/vulkan">Vulkan Discord</a>
            <a class="navbar-item" href="https://reddit.com/r/vulkan">Reddit</a>
            <a class="navbar-item" href="https://stackoverflow.com/questions/tagged/vulkan">Stack Overflow</a>
            <a class="navbar-item" href="https://fosstodon.org/@vulkan">Mastodon</a>
          </div>
        </div>
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="samples" data-version="latest">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="../../../README.html">Vulkan Samples</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../README.html">Samples overview</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../vulkan_basics.html">Vulkan basics</a>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../../framework/README.html">Sample framework</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../../components/README.html">Framework components</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../README.html">Api usage samples</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../compute_nbody/README.html">Compute N-body</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../hpp_compute_nbody/README.html">Compute N-body (Vulkan-Hpp)</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../dynamic_uniform_buffers/README.html">Dynamic uniform buffers</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../hpp_dynamic_uniform_buffers/README.html">Dynamic Uniform Buffers (Vulkan-Hpp)</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../hdr/README.html">HDR</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../hpp_hdr/README.html">HDR (Vulkan-Hpp)</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../hello_triangle/README.html">Hello Triangle</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../hpp_hello_triangle/README.html">Hello Triangle (Vulkan-Hpp)</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../hlsl_shaders/README.html">HLSL Shaders</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../hpp_hlsl_shaders/README.html">HLSL Shaders (Vulkan-Hpp)</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../instancing/README.html">Instancing</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../hpp_instancing/README.html">Instancing (Vulkan-Hpp)</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../separate_image_sampler/README.html">Separate image sampler</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../hpp_separate_image_sampler/README.html">Separate image sampler (Vulkan-Hpp)</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../terrain_tessellation/README.html">Terrain tessellation</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../hpp_terrain_tessellation/README.html">Terrain tessellation (Vulkan-Hpp)</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../texture_loading/README.html">Texture loading</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../hpp_texture_loading/README.html">Texture loading (Vulkan-Hpp)</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../texture_mipmap_generation/README.html">Texture mipmap generation</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../hpp_texture_mipmap_generation/README.html">Texture mipmap generation (Vulkan-Hpp)</a>
  </li>
</ul>
  </li>
  <li class="nav-item is-current-page" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="README.html">Timestamp queries</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../hpp_timestamp_queries/README.html">Timestamp queries (Vulkan-Hpp)</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../oit_linked_lists/README.html">OIT linked lists</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../hpp_oit_linked_lists/README.html">OIT linked lists (Vulkan-Hpp)</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../oit_depth_peeling/README.html">OIT depth peeling</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../extensions/README.html">Extension usage samples</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../extensions/buffer_device_address/README.html">Buffer device address</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../extensions/calibrated_timestamps/README.html">Calibrated timestamps</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../extensions/conditional_rendering/README.html">Conditional rendering</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../extensions/conservative_rasterization/README.html">Conservative rasterization</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../extensions/debug_utils/README.html">Debug utils</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../extensions/descriptor_buffer_basic/README.html">Descriptor buffer basic</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../extensions/descriptor_indexing/README.html">Descriptor indexing</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../extensions/dynamic_line_rasterization/README.html">Dynamic line rasterization</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../extensions/dynamic_rendering/README.html">Dynamic rendering</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../extensions/extended_dynamic_state2/README.html">Extended dynamic state2</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../extensions/fragment_shader_barycentric/README.html">Fragment shader barycentric</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../extensions/fragment_shading_rate/README.html">Fragment shading rate</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../extensions/fragment_shading_rate_dynamic/README.html">Fragment shading rate dynamic</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../extensions/full_screen_exclusive/README.html">Full screen exclusive</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../extensions/graphics_pipeline_library/README.html">Graphics pipeline library</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../extensions/gshader_to_mshader/README.html">Geometry shader to mesh shader</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../extensions/logic_op_dynamic_state/README.html">Logic op dynamic state</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../extensions/memory_budget/README.html">Memory budget</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../extensions/mesh_shader_culling/README.html">Mesh shader culling</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../extensions/mesh_shading/README.html">Mesh shading</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../extensions/open_cl_interop/README.html">OpenCL interop</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../extensions/open_cl_interop_arm/README.html">OpenCL interop (Arm)</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../extensions/open_gl_interop/README.html">OpenGL interop</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../extensions/portability/README.html">Portability</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../extensions/push_descriptors/README.html">Push descriptors</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../extensions/ray_tracing_basic/README.html">Raytracing basic</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../extensions/ray_tracing_extended/README.html">Raytracing extended</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../extensions/ray_queries/README.html">Ray queries</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../extensions/ray_tracing_reflection/README.html">Ray tracing reflection</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../extensions/shader_object/README.html">Shader Object</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../extensions/sparse_image/README.html">Sparse Image</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../extensions/synchronization_2/README.html">Synchronization 2</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../extensions/timeline_semaphore/README.html">Timeline semaphore</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../extensions/vertex_dynamic_state/README.html">Vertex dynamic state</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../performance/README.html">Performance samples</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../performance/16bit_arithmetic/README.html">16bit arithmetic</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../performance/16bit_storage_input_output/README.html">16bit storage input output</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../performance/afbc/README.html">AFBC</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../performance/async_compute/README.html">Async compute</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../performance/command_buffer_usage/README.html">Command buffer usage</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../performance/constant_data/README.html">Constant data</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../performance/descriptor_management/README.html">Descriptor management</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../performance/layout_transitions/README.html">Layout transitions</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../performance/msaa/README.html">MSAA</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../performance/multithreading_render_passes/README.html">Multithreading render passes</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../performance/multi_draw_indirect/README.html">Multi draw indirect</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../performance/pipeline_barriers/README.html">Pipeline barriers</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../performance/pipeline_cache/README.html">Pipeline cache</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../performance/hpp_pipeline_cache/README.html">Pipeline cache (Vulkan-Hpp)</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../performance/render_passes/README.html">Render passes</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../performance/specialization_constants/README.html">Specialization constants</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../performance/subpasses/README.html">Subpasses</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../performance/surface_rotation/README.html">Surface rotation</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../performance/swapchain_images/README.html">Swapchain images</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../performance/hpp_swapchain_images/README.html">Swapchain images (Vulkan-Hpp)</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../performance/texture_compression_basisu/README.html">Texture compression basisu</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../performance/texture_compression_comparison/README.html">Texture compression comparison</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../performance/wait_idle/README.html">Wait idle</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../tooling/README.html">Tooling samples</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../tooling/profiles/README.html">Profiles</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../general/README.html">General samples</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../general/mobile_nerf/README.html">Mobile NeRF</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../../docs/README.html">General documentation</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../../docs/build.html">Build guide</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../../docs/memory_limits.html">Memory limits</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../../docs/misc.html">Miscellaneous</a>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Vulkan Samples</span>
    <span class="version">latest</span>
  </div>
  <ul class="components">
    <li class="component">
      <a class="title" href="../../../../../tutorial/latest/00_Introduction.html">Khronos Vulkan Tutorial</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../../../tutorial/latest/00_Introduction.html">latest</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <a class="title" href="../../../../../guide/latest/index.html">Vulkan Guide</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../../../guide/latest/index.html">latest</a>
        </li>
      </ul>
    </li>
    <li class="component is-current">
      <a class="title" href="../../../README.html">Vulkan Samples</a>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="../../../README.html">latest</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <a class="title" href="../../../../../spec/latest/index.html">Vulkan Specification and Proposals</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../../../spec/latest/index.html">latest</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../../../../../spec/latest/index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../../../README.html">Vulkan Samples</a></li>
    <li><a href="../README.html">Api usage samples</a></li>
    <li><a href="README.html">Timestamp queries</a></li>
  </ul>
</nav>
    <!--
  <div class="edit-this-page"><a href="https://github.com/KhronosGroup/Vulkan-Samples/edit/main/antora/modules/ROOT/pages/samples/api/timestamp_queries/README.adoc">Edit this Page</a></div>
      -->
</div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">Timestamp queries</h1>
<div id="preamble">
<div class="sectionbody">
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The source for this sample can be found in the <a href="https://github.com/KhronosGroup/Vulkan-Samples/tree/main/samples/api/timestamp_queries">Khronos Vulkan samples github repository</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This tutorial, along with the accompanying example code, shows how to use timestamp queries to measure timings on the GPU.</p>
</div>
<div class="paragraph">
<p>The sample, based on the HDR one, does multiple render passes and will use timestamp queries to get GPU timings for the different render passes.
This is done by writing GPU timestamps at certain points within a command buffer.
These can then be read on the host and used for approximate profiling and to e.g.
improve performance where needed.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_introduction"><a class="anchor" href="#_introduction"></a>Introduction</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Vulkan offers several <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html#queries">query types</a> that allow you to query different types of information from the GPU.
One such query type is the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html#queries-timestamps">timestamp query</a>.</p>
</div>
<div class="paragraph">
<p>This provides your application with a mechanism to time the execution of commands on the GPU.
As with the other query types, a query pool is then used to either directly fetch or copy over the results to the host.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_a_few_important_notes_on_timestamp_queries"><a class="anchor" href="#_a_few_important_notes_on_timestamp_queries"></a>A few important notes on timestamp queries</h2>
<div class="sectionbody">
<div class="paragraph">
<p>It&#8217;s important to know that timestamp queries differ greatly from how timing can be done on the CPU with e.g.
the high performance counter.
This is mostly due to how a GPU&#8217;s dispatches, overlaps and finishes work across different stages of the pipeline.
So while technically you can specify any pipeline stage at which the timestamp should be written, a lot of stage combinations and orderings won&#8217;t give meaningful result.
This also means that you you can&#8217;t compare timestamps taken on different queues.</p>
</div>
<div class="paragraph">
<p>So while it may may sound reasonable to write timestamps for the vertex and fragment shader stage directly one after another, that will usually not return meaningful results due to how the GPU works.</p>
</div>
<div class="paragraph">
<p>And so for this example, we take the same approach as some popular CPU/GPU profilers by only using the top and bottom stages of the pipeline.
This combination is known to give proper approximate timing results on most GPUs.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_checking_for_support"><a class="anchor" href="#_checking_for_support"></a>Checking for support</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Not all GPUs support timestamp queries, so before using them we need to make sure that they can be used.
This differs slightly from checking other features with a simple <code>VkBool</code>.
Here we need to check if the <code>timestampPeriod</code> limit of the physical device is greater than zero.
If that&#8217;s the case, timestamp queries are supported:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">VkPhysicalDeviceLimits device_limits = device-&gt;get_gpu().get_properties().limits;
if (device_limits.timestampPeriod == 0)
{
	throw std::runtime_error{"The selected device does not support timestamp queries!"};
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Another limit we need to check is <code>timestampComputeAndGraphics</code>.
If this is <code>VK_TRUE</code>, all graphics and compute pipelines support timestamp queries and the above check is sufficient.
If not, we need to check if the queue we want to use supports timestamps:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">if (!device_limits.timestampComputeAndGraphics)
{
	// Check if the graphics queue used in this sample supports time stamps
	VkQueueFamilyProperties graphics_queue_family_properties = device-&gt;get_suitable_graphics_queue().get_properties();
	if (graphics_queue_family_properties.timestampValidBits == 0)
	{
		throw std::runtime_error{"The selected graphics queue family does not support timestamp queries!"};
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_creating_the_query_pool"><a class="anchor" href="#_creating_the_query_pool"></a>Creating the query pool</h2>
<div class="sectionbody">
<div class="paragraph">
<p>As with all query types, we first need to create a pool for the timestamp queries.
This is used to store and read back the results (see <code>prepare_time_stamp_queries</code>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">VkQueryPoolCreateInfo query_pool_info{};
query_pool_info.sType = VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO;
query_pool_info.queryType = VK_QUERY_TYPE_TIMESTAMP;
query_pool_info.queryCount = static_cast&lt;uint32_t&gt;(time_stamps.size());
VK_CHECK(vkCreateQueryPool(device-&gt;get_handle(), &amp;query_pool_info, nullptr, &amp;query_pool_timestamps));</code></pre>
</div>
</div>
<div class="paragraph">
<p>The interesting parts are the <code>queryType</code>, which we set to <code>VK_QUERY_TYPE_TIMESTAMP</code> for using timestamp queries and the <code>queryCount</code>, which is the maximum number of the the timestamp query result this pool can store.</p>
</div>
<div class="paragraph">
<p>For this sample we&#8217;ll be using 6 time points, one for the start and one for the end of three render passes.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resetting_the_query_pool"><a class="anchor" href="#_resetting_the_query_pool"></a>Resetting the query pool</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Before we can start writing data to the query pool, we need to reset it.
When using Vulkan 1.0 or 1.1, this requires us to enable the <code>VK_EXT_host_query_reset</code> extension:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">add_device_extension(VK_EXT_HOST_QUERY_RESET_EXTENSION_NAME);</code></pre>
</div>
</div>
<div class="paragraph">
<p>With using Vulkan 1.2 this extension has become part of the core and we won&#8217;t have to manually enable it.</p>
</div>
<div class="paragraph">
<p>Independent of this, we also need to enable the <code>hostQueryReset</code> physical device feature:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">auto &amp;requested_extension_features= gpu.request_extension_features&lt;VkPhysicalDeviceHostQueryResetFeaturesEXT&gt;(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES_EXT);
requested_extension_features.hostQueryReset = VK_TRUE;</code></pre>
</div>
</div>
<div class="paragraph">
<p>With features and extensions properly enabled, we can now reset the pool at the start of the command buffer, before writing the first timestamp.
This is done using <code>vkCmdResetQueryPool</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">...
vkBeginCommandBuffer(draw_cmd_buffers[i], &amp;command_buffer_begin_info);
vkCmdResetQueryPool(draw_cmd_buffers[i], query_pool_timestamps, 0, static_cast&lt;uint32_t&gt;(time_stamps.size()));</code></pre>
</div>
</div>
<hr>
</div>
</div>
<div class="sect1">
<h2 id="_writing_time_stamps"><a class="anchor" href="#_writing_time_stamps"></a>Writing time stamps</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Unlike getting CPU side timing information that can be queried immediately, with GPU time stamps we need to tell the implementation inside a command buffer when/where to write timestamps instead.
The results are then fetched afterwards (see below).</p>
</div>
<div class="paragraph">
<p>This is done inside the command buffer with <code>vkCmdWriteTimestamp</code>.
This function will request a timestamp to be written from the GPU for a certain pipeline stage and write that value to memory.</p>
</div>
<div class="paragraph">
<p>The most interesting part of calling this function is the <code>pipelineStage</code> argument.
As noted earlier, it&#8217;s technically possible to use any pipeline stage in here, not all pipeline stages will yield proper results due to how GPUs overlap work.
It&#8217;s also important to note that not all implementations are able to latch timers at all pipeline stages (e.g.
if they don&#8217;t have hardware that maps to a given stage) and may return timers at a later pipeline stage instead.</p>
</div>
<div class="paragraph">
<p>Calling this function also defines an execution dependency similar to a barrier on all commands that were submitted before it.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">vkCmdWriteTimestamp(draw_cmd_buffers[i], VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT, query_pool_timestamps, 0);
// Do some work
for (int i = 0; i &lt; draw_call_count; i++) {
	vkCmdDraw(...);
}
vkCmdWriteTimestamp(draw_cmd_buffers[i], VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT, query_pool_timestamps, 1);</code></pre>
</div>
</div>
<div class="paragraph">
<p>To measure GPU times for the draw calls(s) we first tell the GPU to write a timestamp at the <code>VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT</code> pipeline stage.
This is not a real pipeline stage (as in e.g.
the vertex or fragment stages) but a special constant that tells the GPU to write the timestamp when all previous commands have been processed by the GPU&#8217;s command processor.
This ensures that we get a timestamp right before starting on the draw calls we want to measure, which will be the base for calculating our delta time.</p>
</div>
<div class="paragraph">
<p>The second timestamp is written at the <code>VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT</code> pipeline stage.
Once again this is not a real pipeline stage, but it again tells the GPU to write the timestamp after all work has been finished.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_getting_the_results"><a class="anchor" href="#_getting_the_results"></a>Getting the results</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Reading back the results can be done in two ways:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Copy the results into a <code>VkBuffer</code> inside the command buffer using <code>vkCmdCopyQueryPoolResults</code></p>
</li>
<li>
<p>Get the results after the command buffer has finished executing using <code>vkGetQueryPoolResults</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For our sample we&#8217;ll use option two (see <code>get_time_stamp_results</code>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">vkQueueSubmit();
...
// The number of timestamps changes if the bloom pass is disabled
uint32_t count = bloom ? time_stamps.size() : time_stamps.size() - 2;

vkGetQueryPoolResults(
	device-&gt;get_handle(),
	query_pool_timestamps,
	0,
	count,
	time_stamps.size() * sizeof(uint64_t),
	time_stamps.data(),
	sizeof(uint64_t),
	VK_QUERY_RESULT_64_BIT | VK_QUERY_RESULT_WAIT_BIT);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Most arguments are straightforward, e.g.
where the data will be copied to (the <code>time_stamps</code> vector).
The important part here are the <code>VK_QUERY_RESULT_</code> flags used here.</p>
</div>
<div class="paragraph">
<p><code>VK_QUERY_RESULT_64_BIT</code> will tell the api that we want to get the results as 64 bit values.
Without this flag, we would only get 32 bit values.
And since timestamp queries can operate in nanoseconds, only using 32 bits could result into an overflow.
E.g.
if your device has a <code>timestampPeriod</code> of 1, so that one increment in the result maps to exactly one nanosecond, with 32 bit precision you&#8217;d run into such an overflow after only about 0.43 seconds.</p>
</div>
<div class="paragraph">
<p>The <code>VK_QUERY_RESULT_WAIT_BIT</code> bit then tells the api to wait for all results to be available.
So when using this flag the values written to our <code>time_stamps</code> vector is guaranteed to be available after calling <code>vkGetQueryPoolResults</code>.
This is fine for our use-case where we want to immediately access the results, but may introduce unnecessary stalls in other scenarios.</p>
</div>
<div class="paragraph">
<p>Alternatively you can use the <code>VK_QUERY_RESULT_WITH_AVAILABILITY_BIT</code> flag, which will let you poll the availability of the results and defer writing new timestamps until the results are available.
This should be the preferred way of fetching the results in a real-world application.
Using this flag an additional availability value is inserted after each query value.
If that value becomes non-zero, the result is available.
You then check availability before writing the timestamp again.</p>
</div>
<div class="paragraph">
<p>Here is a basic example of how this could look like for a single timestamp value:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">// time_stamp_with_availibility[current_frame * 2] contains the queried timestamp
// time_stamp_with_availibility[current_frame * 2 + 1] contains availability of the timestamp
std::array&lt;uint64_t, max_frames_in_flight * 2&gt; time_stamp_with_availibility{};

void drawFrame()
{
	vkBeginCommandBuffer(command_buffer, &amp;command_buffer_begin_info);

	// Only write new timestamp if previous result is available
	if (time_stamp_with_availibility[current_frame * 2 + 1] != 0) {
		vkCmdWriteTimestamp(command_buffer, VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT, query_pool_timestamps, 0);
	}

	// Issue draw commands

	vkEndCommandBuffer(command_buffer);

	// Get deferred time stamp query for the current frame
	vkGetQueryPoolResults(
		device,
		query_pool_timestamps,
		0,
		1,
		2 * sizeof(uint64_t),
		&amp;time_stamp_with_availibility[Current_frame * max_frames_in_flight],
		2 * sizeof(uint64_t),
		VK_QUERY_RESULT_64_BIT | VK_QUERY_RESULT_WITH_AVAILABILITY_BIT);

	// Display time stamp for the current frame if available
	if (time_stamp_with_availibility[current_frame * 2 + 1] != 0) {
		std::cout &lt;&lt; "Timestamp = " &lt;&lt; time_stamp_with_availibility[current_frame * 2] &lt;&lt; "\n";
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_interpreting_the_results"><a class="anchor" href="#_interpreting_the_results"></a>Interpreting the results</h2>
<div class="sectionbody">
<div class="paragraph">
<p>After we have read back the results to the host, we are ready to interpret them.
E.g.
for displaying them in a user interface.</p>
</div>
<div class="paragraph">
<p>The results we got back do not actually contain a time value, but rather a number of "ticks".
So to get the actual time value we need to translate these values first.</p>
</div>
<div class="paragraph">
<p>This is done using <code>timestampPeriod</code> limit of the physical device.
It contains the number of nanoseconds it takes for a timestamp query value to be increased by 1 ("tick").</p>
</div>
<div class="paragraph">
<p>In our sample, we want to display the delta between two timestamps in milliseconds, so in addition to the above rule we also multiply the value accordingly.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">VkPhysicalDeviceLimits device_limits = device-&gt;get_gpu().get_properties().limits;
float delta_in_ms = float(time_stamps[1] - time_stamps[0]) * device_limits.timestampPeriod / 1000000.0f;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_vkcmdwritetimestamp2"><a class="anchor" href="#_vkcmdwritetimestamp2"></a>vkCmdWriteTimestamp2</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_synchronization2.html">VK_KHR_synchronization2</a> extension introduced <code>vkCmdWriteTimestamp2</code>.
This is pretty much the same as the <code>vkCmdWriteTimestamp</code> function used in this sample, but adds support for some additional pipeline stages using <code>VkPipelineStageFlags2</code>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_verdict"><a class="anchor" href="#_verdict"></a>Verdict</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Even though timestamp queries are limited due to how a GPU works, they can still be useful for profiling and finding performance GPU bottlenecks.
ul for profiling and finding performance GPU bottlenecks.</p>
</div>
</div>
</div>
</article>
  </div>
</main>
</div>
<footer class="footer">
    <!--
  <p>This page was built using the Antora default UI.</p>
  <p>The source code for this UI is licensed under the terms of the MPL-2.0 license.</p>
    -->
</footer>
<script id="site-script" src="../../../../../_/js/site.js" data-ui-root-path="../../../../../_"></script>
<script async src="../../../../../_/js/vendor/highlight.js"></script>
<script src="../../../../../_/js/vendor/lunr.js"></script>
<script src="../../../../../_/js/search-ui.js" id="search-ui-script" data-site-root-path="../../../../.." data-snippet-length="100" data-stylesheet="../../../../../_/css/search.css"></script>
<script async src="../../../../../search-index.js"></script>
  </body>
</html>

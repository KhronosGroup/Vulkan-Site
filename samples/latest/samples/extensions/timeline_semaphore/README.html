<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Timeline semaphore :: Vulkan Documentation Project Demo</title>
    <meta name="generator" content="Antora 3.1.4">
    <link rel="stylesheet" href="../../../../../_/css/site.css">
    <script>var uiRootPath = '../../../../../_'</script>
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="../../../../..">Vulkan Documentation Project Demo</a>
      <div class="navbar-item">
        <img alt="Vulkan White Label" src="../../../../../_/Vulkan_White_Dec16.svg" height="100%" />
      </div>
      <div class="navbar-item search hide-for-print">
        <div id="search-field" class="field">
          <label for="search-input"></label><input id="search-input" type="text" placeholder="Search the docs">
        </div>
      </div>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <!-- <a class="navbar-item" href="#">Home</a> -->
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Specs</a>
          <div class="navbar-dropdown is-right">
            <a class="navbar-item" href="../../../../../spec/latest/chapters/introduction.html">Vulkan 1.3</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Guides</a>
          <div class="navbar-dropdown is-right">
            <a class="navbar-item" href="../../../../../guide/latest/index.html">Vulkan Guide</a>
          </div>
        </div>
            <!--
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Tools</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">TBD</a>
          </div>
        </div>
            -->
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Tutorial</a>
          <div class="navbar-dropdown is-right">
            <a class="navbar-item" href="../../../../../tutorial/latest/index.html">Vulkan Tutorial</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Samples</a>
          <div class="navbar-dropdown is-right">
            <a class="navbar-item" href="../../../../../samples/latest/README.html">Vulkan Samples</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Help</a>
          <div class="navbar-dropdown is-right">
            <a class="navbar-item" href="https://discord.gg/vulkan">Vulkan Discord</a>
            <a class="navbar-item" href="https://khr.io/khrdiscord">Khronos Discord</a>
          </div>
        </div>
            <!--
        <div class="navbar-item">
          <span class="control">
            <a class="button is-primary" href="#">Download</a>
          </span>
        </div>
            -->
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="samples" data-version="latest">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="../../../README.html">Vulkan Samples</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../../README.html">Readme</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="#vulkan_basics.adoc">Vulkan basics</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../../framework/README.html">Sample framework</a>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="#api/README.adoc">Api usage samples</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="#api/compute_nbody/README.adoc">Compute N-body❕</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="#api/hpp_compute_nbody/README.adoc">hpp compute nbody❕</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="#api/dynamic_uniform_buffers/README.adoc">Dynamic uniform buffers❕</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="#api/hpp_dynamic_uniform_buffers/README.adoc">hpp dynamic uniform buffers❕</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="#api/hdr/README.adoc">HDR❕</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="#api/hpp_hdr/README.adoc">hpp hdr❕</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="#api/hello_triangle/README.adoc">Hello Triangle❕</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="#api/hpp_hello_triangle/README.adoc">hpp hello triangle❕</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="#api/hlsl_shaders/README.adoc">HLSL Shaders</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="#api/hpp_hlsl_shaders/README.adoc">hpp hlsl shaders</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="#api/instancing/README.adoc">Instancing❕</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="#api/hpp_instancing/README.adoc">hpp instancing❕</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="#api/separate_image_sampler/README.adoc">Separate image sampler</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="#api/hpp_separate_image_sampler/README.adoc">hpp separate image sampler</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="#api/terrain_tessellation/README.adoc">Terrain tessellation❕</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="#api/hpp_terrain_tessellation/README.adoc">hpp terrain tessellation❕</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="#api/texture_loading/README.adoc">Texture loading❕</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="#api/hpp_texture_loading/README.adoc">hpp texture loading❕</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="#api/texture_mipmap_generation/README.adoc">Texture mipmap generation</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="#api/hpp_texture_mipmap_generation/README.adoc">hpp texture mipmap generation</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="#api/timestamp_queries/README.adoc">Timestamp queries</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="#api/hpp_timestamp_queries/README.adoc">hpp timestamp queries</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="#extensions/README.adoc">Extension usage samples</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="#extensions/buffer_device_address/README.adoc">Buffer device address</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="#extensions/calibrated_timestamps/README.adoc">Calibrated timestamps</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="#extensions/conditional_rendering/README.adoc">Conditional rendering</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="#extensions/conservative_rasterization/README.adoc">Conservative rasterization❕</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="#extensions/debug_utils/README.adoc">Debug utils</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="#extensions/descriptor_buffer_basic/README.adoc">Descriptor buffer basic</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="#extensions/descriptor_indexing/README.adoc">Descriptor indexing</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="#extensions/dynamic_rendering/README.adoc">Dynamic rendering</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="#extensions/extended_dynamic_state2/README.adoc">Extended dynamic state2</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="#extensions/fragment_shader_barycentric/README.adoc">Fragment shader barycentric</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="#extensions/fragment_shading_rate/README.adoc">Fragment shading rate❕</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="#extensions/fragment_shading_rate_dynamic/README.adoc">Fragment shading rate dynamic</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="#extensions/full_screen_exclusive/README.adoc">Full screen exclusive</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="#extensions/graphics_pipeline_library/README.adoc">Graphics pipeline library</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="#extensions/logic_op_dynamic_state/README.adoc">Logic op dynamic state</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="#extensions/memory_budget/README.adoc">Memory budget</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="#extensions/mesh_shader_culling/README.adoc">Mesh shader culling</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="#extensions/mesh_shading/README.adoc">Mesh shading❕</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="#extensions/open_cl_interop/README.adoc">OpenCL interop (Cross-vendor)</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="#extensions/open_cl_interop_arm/README.adoc">OpenCl interop (Arm)</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="#extensions/open_gl_interop/README.adoc">OpenGL interop❕</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="#extensions/portability/README.adoc">Portability</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="#extensions/push_descriptors/README.adoc">Push descriptors❕</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="#extensions/raytracing_basic/README.adoc">Raytracing basic❕</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="#extensions/raytracing_extended/README.adoc">Raytracing extended</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="#extensions/ray_queries/README.adoc">Ray queries❕</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="#extensions/ray_tracing_reflection/README.adoc">Ray tracing reflection</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="#extensions/synchronization_2/README.adoc">Synchronization 2❕</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="#extensions/timeline_semaphore/README.adoc">Timeline semaphore</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="#extensions/vertex_dynamic_state/README.adoc">Vertex dynamic state</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="#performance/README.adoc">Performance samples</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="#performance/16bit_arithmetic/README.adoc">16bit arithmetic</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="#performance/16bit_storage_input_output/README.adoc">16bit storage input output</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="#performance/afbc/README.adoc">AFBC</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="#performance/async_compute/README.adoc">Async compute</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="#performance/command_buffer_usage/README.adoc">Command buffer usage</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="#performance/constant_data/README.adoc">Constant data</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="#performance/descriptor_management/README.adoc">Descriptor management</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="#performance/layout_transitions/README.adoc">Layout transitions</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="#performance/msaa/README.adoc">MSAA</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="#performance/multithreading_render_passes/README.adoc">Multithreading render passes</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="#performance/multi_draw_indirect/README.adoc">Multi draw indirect</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="#performance/pipeline_barriers/README.adoc">Pipeline barriers</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="#performance/pipeline_cache/README.adoc">Pipeline cache</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="#performance/hpp_pipeline_cache/README.adoc">hpp pipeline cache</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="#performance/render_passes/README.adoc">Render passes</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="#performance/specialization_constants/README.adoc">Specialization constants</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="#performance/subpasses/README.adoc">Subpasses</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="#performance/surface_rotation/README.adoc">Surface rotation</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="#performance/swapchain_images/README.adoc">Swapchain images</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="#performance/hpp_swapchain_images/README.adoc">hpp swapchain images</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="#performance/texture_compression_basisu/README.adoc">Texture compression basisu</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="#performance/texture_compression_comparison/README.adoc">Texture compression comparison❕</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="#performance/wait_idle/README.adoc">Wait idle</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="#tooling/README.adoc">Tooling samples</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="#tooling/profiles/README.adoc">Profiles</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="#docs/README.adoc">General documentation</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../../docs/build.html">Build guide</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="#docs/create_sample.adoc">Creating a new sample</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="#docs/debug_graphs.adoc">Debug graphics</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../../docs/memory_limits.html">Memory limits</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../../docs/misc.html">Miscellaneous</a>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Vulkan Samples</span>
    <span class="version">latest</span>
  </div>
  <ul class="components">
    <li class="component">
      <a class="title" href="../../../../../guide/latest/index.html">Vulkan Guide</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../../../guide/latest/index.html">latest</a>
        </li>
      </ul>
    </li>
    <li class="component is-current">
      <a class="title" href="../../../README.html">Vulkan Samples</a>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="../../../README.html">latest</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <a class="title" href="../../../../../spec/latest/index.html">Vulkan Specification and Proposals</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../../../spec/latest/index.html">latest</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../../../../../spec/latest/index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../../../README.html">Vulkan Samples</a></li>
    <li><a href="README.html">Timeline semaphore</a></li>
  </ul>
</nav>
    <!--
  <div class="edit-this-page"><a href="https://github.com/gpx1000/Vulkan-Samples/edit/antora/antora/modules/ROOT/pages/samples/extensions/timeline_semaphore/README.adoc">Edit this Page</a></div>
      -->
</div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">Timeline semaphore</h1>
<div class="sect1">
<h2 id="_overview"><a class="anchor" href="#_overview"></a>Overview</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In Vulkan 1.0, we were introduced to <code>VkSemaphore</code> which is able to synchronize work between Vulkan queues.
It has some peculiar behavior which makes it somewhat difficult to use in practice.
The timeline semaphore is designed to solve these problems and it also makes the queue synchronization model closer to what we see in D3D12.</p>
</div>
<div class="paragraph">
<p>The existing semaphore as-is works fine in normal situations, but as applications learn to take advantage of async compute, async transfer, and other advanced synchronization use cases, there are problems which are hard to ignore.</p>
</div>
<div class="sect2">
<h3 id="_the_binary_semaphore_problems"><a class="anchor" href="#_the_binary_semaphore_problems"></a>The binary semaphore problems</h3>
<div class="paragraph">
<p>The existing semaphore type is now called a <code>BINARY</code> semaphore, as signals and waits must always happen in 1:1 pairs.
Completing a wait for a semaphore on the <code>VkQueue</code> also <strong>unsignals it</strong>.
This is problematic for more advanced use cases where we wish to create a single producer, multiple consumers scenario.
To make binary semaphores work, we would have to signal multiple semaphores in a single <code>vkQueueSubmit</code>, and then assign one semaphore to each waiting queue.
This is rather awkward, since it might not be obvious at signal time how this scenario will play out, and juggling N semaphores just for this case is not fun.</p>
</div>
<div class="paragraph">
<p>When juggling N semaphores, it might also happen that a semaphore was not required after all, and we are now sitting with a signalled semaphore which cannot be recycled and signalled again unless we wait for it first.
The solution here is to just destroy such "hung" semaphores, which is unfortunate.
Ideally we would be able to reset semaphores on the host as well, but no such API exists and submitting a wait to GPU just for the purpose of unsignalling a semaphore is silly.</p>
</div>
<div class="paragraph">
<p>There is also an object bloat problem.
Usually, there are many submissions in flight on a GPU, and to be able to synchronize with each submission, we must keep track of a certain number of semaphores which are in-flight at any one time.
This is doable, but inelegant.
There is a similar problem for <code>VkFence</code> as well.</p>
</div>
<div class="paragraph">
<p>The final problem is a lack of out-of-order signal and wait.
This is a somewhat of a niche problem, but in a world with free threaded task graphs, it could make sense to be able to submit work out of order and let synchronization objects take care of synchronization on the GPU.
With binary semaphores, a signal must be submitted before the wait, which guarantees forward progress, but guarantees jank in the engine.
There are certainly good reasons for this restriction, but it removes some flexibility.</p>
</div>
</div>
<div class="sect2">
<h3 id="_viewing_a_vkqueue_as_a_sequence_thinking_in_terms_of_counters"><a class="anchor" href="#_viewing_a_vkqueue_as_a_sequence_thinking_in_terms_of_counters"></a>Viewing a <code>VkQueue</code> as a sequence - thinking in terms of counters</h3>
<div class="paragraph">
<p>In order to signal on a <code>VkQueue</code>, we wait for everything that happened before we signal anything.
This also means that future signal operations will wait for a superset of the operations in the signal that came before.
In this sense, instead of thinking of synchronizing against individual submissions, we can think about things like "Wait for submission #134 on compute queue to complete", i.e.
we just associate a single monotonically increasing number to a queue.
Submitting to a <code>VkQueue</code> can now be considered a simple increment of the monotonically increasing number.</p>
</div>
<div class="paragraph">
<p>This is the foundation of timeline semaphores.
A <code>VkSemaphore</code> can have a 64-bit counter associated with it and there are two new operations we can do:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>As a signal semaphore, wait for everything to complete in queue, then <strong>monotonically</strong> bump counter value to <code>$old_value + $increment</code>, where <code>$increment</code> is usually 1.</p>
</li>
<li>
<p>As a wait semaphore, wait for the counter of the semaphore to reach <strong>at least</strong> the wait count value.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>From an application point of view, there is no longer a need to own synchronization objects and applications can instead agree on 64-bit counters.</p>
</div>
</div>
<div class="sect2">
<h3 id="_out_of_order_signal_and_wait"><a class="anchor" href="#_out_of_order_signal_and_wait"></a>Out-of-order signal and wait</h3>
<div class="paragraph">
<p>Timeline semaphores also adds support for submitting waits before the corresponding signal operation.
This hands over the burden to the driver, where it will need to either hold back submissions on its own, or defer this work to the kernel driver.
Either way, the application no longer needs to hold back submissions.</p>
</div>
<div class="paragraph">
<p>This can be quite useful when applications have multiple threads which perform queue submission, since ensuring ordering otherwise would require a lot of careful thread synchronization.</p>
</div>
</div>
<div class="sect2">
<h3 id="_single_producer_multiple_consumers"><a class="anchor" href="#_single_producer_multiple_consumers"></a>Single producer, multiple consumers</h3>
<div class="paragraph">
<p>There is no unsignal operation with timeline semaphores, so it&#8217;s perfectly fine to do something like:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Signal graphics queue, value 40</p>
</li>
<li>
<p>Wait async compute queue 0, value 40</p>
</li>
<li>
<p>Wait async compute queue 1, value 39</p>
</li>
<li>
<p>Wait async compute queue 2, value 36</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Once the counter reaches 40, it will always be at least 40, and we can keep waiting for this counter as long as we wish.</p>
</div>
</div>
<div class="sect2">
<h3 id="_integration_of_host_signal_and_wait_good_night_sweet_vkfence"><a class="anchor" href="#_integration_of_host_signal_and_wait_good_night_sweet_vkfence"></a>Integration of host signal and wait, good night sweet <code>VkFence</code></h3>
<div class="paragraph">
<p>VkFence is somewhat redundant when we have timeline semaphores, since we can now wait for counter values on CPU as well.
There is not even a requirement to externally synchronize <code>VkSemaphore</code> objects when doing so, which is very nice!
To synchronize GPU work with CPU, we just need to know the timeline value we signalled with.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_using_timeline_semaphores"><a class="anchor" href="#_using_timeline_semaphores"></a>Using timeline semaphores</h2>
<div class="sectionbody">
<div class="paragraph">
<p>First, we need to create a <code>VkSemaphore</code> with <code>TIMELINE</code> type.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">// A timeline semaphore is still a semaphore, but it is of TIMELINE type rather than BINARY.
VkSemaphoreCreateInfo        create_info = vkb::initializers::semaphore_create_info();
VkSemaphoreTypeCreateInfoKHR type_create_info{VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO_KHR};

type_create_info.semaphoreType = VK_SEMAPHORE_TYPE_TIMELINE_KHR;
type_create_info.initialValue  = 0;
create_info.pNext              = &amp;type_create_info;

VK_CHECK(vkCreateSemaphore(get_device().get_handle(), &amp;create_info, nullptr, &amp;timeline.semaphore));</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can signal the timeline in <code>vkQueueSubmit</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">VkSubmitInfo submit         = vkb::initializers::submit_info();
submit.pSignalSemaphores    = &amp;timeline.semaphore;
submit.signalSemaphoreCount = 1;
submit.pCommandBuffers      = &amp;cmd;
submit.commandBufferCount   = 1;

// For every timeline semaphore we signal, we give an auxillary timeline value.
VkTimelineSemaphoreSubmitInfoKHR timeline_info{VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO_KHR};
timeline_info.signalSemaphoreValueCount = 1;
timeline_info.pSignalSemaphoreValues    = &amp;timeline.timeline;

submit.pNext = &amp;timeline_info;

VK_CHECK(vkQueueSubmit(signal_queue, 1, &amp;submit, VK_NULL_HANDLE));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Similarly, we can wait in <code>vkQueueSubmit</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">const VkPipelineStageFlags wait_stages = VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT;

VkSubmitInfo submit       = vkb::initializers::submit_info();
submit.pWaitSemaphores    = &amp;timeline.semaphore;
submit.pWaitDstStageMask  = &amp;wait_stages;
submit.waitSemaphoreCount = 1;
submit.pCommandBuffers    = &amp;cmd;
submit.commandBufferCount = 1;

VkTimelineSemaphoreSubmitInfoKHR timeline_info{VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO_KHR};
timeline_info.waitSemaphoreValueCount = 1;
timeline_info.pWaitSemaphoreValues    = &amp;timeline.timeline;

submit.pNext = &amp;timeline_info;

VK_CHECK(vkQueueSubmit(wait_queue, 1, &amp;submit, VK_NULL_HANDLE));</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can wait for one or more semaphores on host as well!</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">VkSemaphoreWaitInfoKHR wait_info{VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO_KHR};
wait_info.pSemaphores    = &amp;semaphore;
wait_info.semaphoreCount = 1;
wait_info.pValues        = &amp;value;
VK_CHECK(vkWaitSemaphoresKHR(device-&gt;get_handle(), &amp;wait_info, UINT64_MAX));</code></pre>
</div>
</div>
<div class="paragraph">
<p>A somewhat esoteric feature is to signal a timeline on host, this can be used to "kick" the GPU.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">VkSemaphoreSignalInfoKHR signal_info{VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO_KHR};
signal_info.semaphore = semaphore;
signal_info.value     = value;
VK_CHECK(vkSignalSemaphoreKHR(device-&gt;get_handle(), &amp;signal_info));</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_the_sample"><a class="anchor" href="#_the_sample"></a>The sample</h2>
<div class="sectionbody">
<div class="imageblock">
<div class="content">
<img src="../../../_images/samples/extensions/timeline_semaphore/images/sample.png" alt="Sample">
</div>
</div>
<div class="paragraph">
<p>This sample demonstrates an esoteric way of implementing the well-known "Game of Life".
Through this sample we end up using all the core features of timeline semaphores.</p>
</div>
<div class="sect2">
<h3 id="_the_queues"><a class="anchor" href="#_the_queues"></a>The queues</h3>
<div class="paragraph">
<p>In this sample, we make use of two <code>VkQueues</code>, an async compute queue which performs simulation, and the main graphics queue which blits to swapchain and presents the results.
The two queues need to carefully synchronize with each other.
This sample could trivially be done with binary semaphores of course, so in this sample we implement it in a difficult way to demonstrate the full API capabilities.</p>
</div>
</div>
<div class="sect2">
<h3 id="_async_worker_thread_out_of_order_submission"><a class="anchor" href="#_async_worker_thread_out_of_order_submission"></a>Async worker thread - out-of-order submission</h3>
<div class="paragraph">
<p>The key aspect we use to demonstrate out of order submission is a dedicated worker thread which does all work related to simulation on the async compute queue.
It never synchronizes with the main thread except at teardown, so the only way it synchronizes is through timeline semaphores.
Submission order is completely out-of-order in this case and forward progress in the async queue is generally blocked by the main thread submitting more work.</p>
</div>
</div>
<div class="sect2">
<h3 id="_data_flow"><a class="anchor" href="#_data_flow"></a>Data flow</h3>
<div class="paragraph">
<p>To simulate "Game of Life", we allocate two images of 64x64 RGBA8.
First, one image is initialized with initial state, and from here there is a ping-pong where image N is updated, while reading from image 1 - N.</p>
</div>
<div class="paragraph">
<p>After updating image N, the main thread will sample from image N.
Before async compute updates the same image index N again, it must wait for graphics queue to complete.
With the double buffer in play, the async queue can run ahead for a little while and it will be mostly stalled by graphics queue.</p>
</div>
<div class="paragraph">
<p>The sequential flow of the rendering is something like, assuming two timeline semaphores A and G:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Async compute write image 1.</p>
</li>
<li>
<p>Async compute signal A = 1.</p>
</li>
<li>
<p>Graphics wait A = 1.</p>
</li>
<li>
<p>Graphics read image 1.</p>
</li>
<li>
<p>Graphics signal G = 1.</p>
</li>
<li>
<p>Async compute wait A = 1.
(Could use pipeline barrier of course, but hey!)</p>
</li>
<li>
<p>Async compute write image 0.</p>
</li>
<li>
<p>Async compute signal A = 2.</p>
</li>
<li>
<p>Graphics wait A = 2.</p>
</li>
<li>
<p>Graphics read image 0.</p>
</li>
<li>
<p>Graphics signal G = 2.</p>
</li>
<li>
<p>Async compute wait G = 1.
(Resolve write-after-read hazard)</p>
</li>
<li>
<p>Async compute wait A = 2.
(Could use pipeline barrier of course, but hey!)</p>
</li>
<li>
<p>Async compute wait host A = 1.
(Wait for command buffer to retire so we can re-record it!)</p>
</li>
<li>
<p>Async compute write image 1.</p>
</li>
<li>
<p>Async compute signal A = 3.</p>
</li>
<li>
<p>Graphics wait A = 3.</p>
</li>
<li>
<p>Graphics read image 1.</p>
</li>
<li>
<p>Graphics signal G = 3.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>And so on &#8230;&#8203;
With out of order signal, we can end up observing this order of submissions instead.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Async compute write image 1.</p>
</li>
<li>
<p>Async compute signal A = 1.</p>
</li>
<li>
<p>Async compute wait A = 1.</p>
</li>
<li>
<p>Async compute write image 0.</p>
</li>
<li>
<p>Async compute signal A = 2.</p>
</li>
<li>
<p>Async compute wait G = 1.
(Out of order submission, queue progress is stalled, but we can keep recording)</p>
</li>
<li>
<p>Async compute wait A = 2.</p>
</li>
<li>
<p>Async compute wait host A = 1.</p>
</li>
<li>
<p>Async compute write image 1.</p>
</li>
<li>
<p>Async compute signal A = 3.</p>
</li>
<li>
<p>Graphics wait A = 1.</p>
</li>
<li>
<p>Graphics read image 1.</p>
</li>
<li>
<p>Graphics signal G = 1.
(Unblocks queue forward progress)</p>
</li>
<li>
<p>Graphics wait A = 2.</p>
</li>
<li>
<p>Graphics read image 0.</p>
</li>
<li>
<p>Graphics signal G = 2.</p>
</li>
<li>
<p>Graphics wait A = 3.</p>
</li>
<li>
<p>Graphics read image 1.</p>
</li>
<li>
<p>Graphics signal G = 3.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When submitting out of order, it is important that you don&#8217;t just submit work way ahead of where the GPU actually is, since the latency becomes extremely large.
The natural place to keep submission explosion under control here is the place where we wait for the timeline on host, since we need to re-record command buffers anyways.</p>
</div>
</div>
<div class="sect2">
<h3 id="_avoiding_deadlocks_in_vkdevicewaitidle"><a class="anchor" href="#_avoiding_deadlocks_in_vkdevicewaitidle"></a>Avoiding deadlocks in <code>vkDeviceWaitIdle</code></h3>
<div class="paragraph">
<p>When submitting out-of-order we end up in a situation where a queue cannot see any forward progress until another queue submits.
Calling <code>vkDeviceWaitIdle</code> at this point triggers a deadlock of the application since <code>vkDeviceWaitIdle</code> will never finish, as there is one queue which cannot make forward progress.
While calling <code>vkDeviceWaitIdle</code>, you cannot call <code>vkQueueSubmit</code> due to external synchronization rules.</p>
</div>
<div class="paragraph">
<p>Instead, just wait for timeline semaphores on host to "drain" the GPU, or if you must use API calls, use <code>vkQueueWaitIdle</code> and only wait on queues which you need.</p>
</div>
</div>
<div class="sect2">
<h3 id="_avoiding_deadlocks_when_tearing_down_worker_thread"><a class="anchor" href="#_avoiding_deadlocks_when_tearing_down_worker_thread"></a>Avoiding deadlocks when tearing down worker thread</h3>
<div class="paragraph">
<p>Similar to <code>vkDeviceWaitIdle</code>, when tearing down the application, an out-of-order submission might be waiting on work which never comes, and that queue becomes deadlocked.
To alleviate this, we can make use of host signalling of timeline semaphores to unblock everything in one fell swoop.</p>
</div>
<div class="paragraph">
<p>From <code>TimelineSemaphore::finish()</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">// Draining queues which submit out-of-order can be quite tricky, since QueueWaitIdle can deadlock for threads which want to run ahead.
// If we call Submit waiting for a semaphore which is yet to be signalled,
// QueueWaitIdle will not finish until a signal in another thread happens.
// Here's an approach we can use to safely tear down the queue.

// Drain the main thread timeline.
// The async queue might be stalled waiting on the main queue to finish rendering a future frame which it never completes,
// but we might never hit that count, since we're tearing down the application now.
wait_timeline_cpu(main_thread_timeline);

// Now we're guaranteed that the graphics timeline is at N and the async compute queue is blocked at N + num_frames + 1, waiting for N + 1 to finish.
// Since we're not reading any more in graphics queue, we can jump bump the timeline on CPU towards infinity.
// On the next loop iteration, we will exit the rendering loop and QueueWaitIdle will not be blocked on async thread anymore.
// Just bump the timeline by INT32_MAX which is min-spec for maxTimelineSemaphoreValueDifference.
// This is a useful way to mark a timeline semaphore as "permanently" signalled.
main_thread_timeline.timeline += std::numeric_limits&lt;int32_t&gt;::max();

// Order matters here, this works kinda like a condition variable.
// If the timeline update is observed, we should see that the worker is not alive anymore.
async_compute_worker.alive = false;
signal_timeline_cpu(main_thread_timeline, main_thread_timeline_lock);

// This will now complete in finite time.
if (async_compute_worker.thread.joinable())
{
    async_compute_worker.thread.join();
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_out_of_order_submission_fallbacks_for_single_queue_implementations"><a class="anchor" href="#_out_of_order_submission_fallbacks_for_single_queue_implementations"></a>Out-of-order submission fallbacks for single queue implementations</h3>
<div class="paragraph">
<p>Since this sample needs to run on all implementations which support timeline semaphores, the sample also demonstrates the limitations of out-of-order queue submissions.
It&#8217;s easy to land in a situation where you deadlock the GPU or driver which only happens on single queue Vulkan implementations.
There are two fixes we need to make this work.</p>
</div>
<div class="sect3">
<h4 id="_holding_back_submissions"><a class="anchor" href="#_holding_back_submissions"></a>Holding back submissions</h4>
<div class="paragraph">
<p>This workaround ensures that submissions happen in-order, where forward progress can always be made.
Since we are using multiple submission threads this sample uses a condition variable to only allow a wait to be submitted if it ensures forward progress.
This is handled by <code>TimelineSemaphore::update_pending()</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">std::lock_guard&lt;std::mutex&gt; holder{lock.lock};
lock.pending_timeline = timeline;
lock.cond.notify_one();</code></pre>
</div>
</div>
<div class="paragraph">
<p>and <code>TimelineSemaphore::wait_pending()</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">std::unique_lock&lt;std::mutex&gt; holder{lock.lock};
lock.cond.wait(holder, [&amp;lock, timeline]() -&gt; bool {
    return lock.pending_timeline &gt;= timeline;
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>Blocking like this only works when multiple threads can submit, but that&#8217;s what this sample is doing, so it is a simple fix.</p>
</div>
<div class="paragraph">
<p>The most robust workaround is probably to not lean too heavily on out-of-order submission unless you know you have all the <code>VkQueues</code> you need to resolve the dependencies properly.</p>
</div>
</div>
<div class="sect3">
<h4 id="_locking_vkqueuesubmit"><a class="anchor" href="#_locking_vkqueuesubmit"></a>Locking <code>vkQueueSubmit</code></h4>
<div class="paragraph">
<p>If two threads end up submitting to the same queue at the same time, we need to add locks due to external synchronization requirement of the <code>VkQueue</code>.
In this sample, we only add the locks if we&#8217;re applying workarounds.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_api_limitations"><a class="anchor" href="#_api_limitations"></a>API limitations</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Currently, the Vulkan WSI swapchain does not support timeline semaphores.
In practice, this isn&#8217;t too big of a deal as swapchain integration tends to be a "special case" either way in most rendering backends.
The acquire and release semaphores have no analog in other modern APIs.</p>
</div>
<div class="paragraph">
<p>Another related issue with WSI swapchains is that when using binary semaphores, it is not possible to use wait-before-signal.
The specification states that in order to submit a wait on a binary semaphore all dependencies for that semaphore wait must have been submitted already.
This means that we need to potentially block a bit on host before we can call vkQueuePresentKHR.
The sample does this right before calling <code>ApiVulkanSample::submit_frame()</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">// Before we call present, which uses a binary semaphore, we must ensure that all dependent submissions
// have been submitted, so that the presenting queue is unblocked at the time of calling.
wait_pending(async_compute_timeline_lock, main_thread_timeline.timeline);

ApiVulkanSample::submit_frame();</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_conclusion"><a class="anchor" href="#_conclusion"></a>Conclusion</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Timeline semaphores grants a lot of flexibility to applications.
With modern approaches of task graphs, many threads and free flowing synchronization, timeline semaphores simplify a lot of things and removes the need for emulating a similar concept with binary semaphores and fences.</p>
</div>
<div class="paragraph">
<p>Be careful with out-of-order submissions.
There are various pitfalls with this approach which have been outlined in this sample.</p>
</div>
</div>
</div>
</article>
  </div>
</main>
</div>
<footer class="footer">
    <!--
  <p>This page was built using the Antora default UI.</p>
  <p>The source code for this UI is licensed under the terms of the MPL-2.0 license.</p>
    -->
</footer>
<script id="site-script" src="../../../../../_/js/site.js" data-ui-root-path="../../../../../_"></script>
<script async src="../../../../../_/js/vendor/highlight.js"></script>
<script src="../../../../../_/js/vendor/lunr.js"></script>
<script src="../../../../../_/js/search-ui.js" id="search-ui-script" data-site-root-path="../../../../.." data-snippet-length="100" data-stylesheet="../../../../../_/css/search.css"></script>
<script async src="../../../../../search-index.js"></script>
  </body>
</html>

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Descriptor indexing :: Vulkan Documentation Project Demo</title>
    <meta name="generator" content="Antora 3.1.4">
    <link rel="stylesheet" href="../../../../../_/css/site.css">
    <script>var uiRootPath = '../../../../../_'</script>
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="../../../../.."><img class="navbar-item" alt="Vulkan White Label" src="../../../../../_/Vulkan_White_Dec16.svg" /></a>
      <div class="navbar-item search hide-for-print">
        <div id="search-field" class="field">
          <label for="search-input"></label><input id="search-input" type="text" placeholder="Search the docs">
        </div>
      </div>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <!-- <a class="navbar-item" href="#">Home</a> -->
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Specs</a>
          <div class="navbar-dropdown is-right">
            <a class="navbar-item" href="../../../../../spec/latest/chapters/introduction.html">Vulkan 1.3</a>
            <a class="navbar-item" href="https://registry.khronos.org/OpenGL/specs/gl/GLSLangSpec.4.60.html">GLSL</a>
            <a class="navbar-item" href="/guide/latest/hlsl.html">HLSL</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Education</a>
          <div class="navbar-dropdown is-right">
            <a class="navbar-item" href="../../../../../guide/latest/index.html">Vulkan Guide</a>
            <a class="navbar-item" href="../../../../../tutorial/latest/index.html">Vulkan Tutorial</a>
            <a class="navbar-item" href="../../../../../samples/latest/README.html">Vulkan Samples</a>
            <a class="navbar-item" href="https://www.youtube.com/c/vulkan">YouTube</a>
            <a class="navbar-item" href="https://vulkan.org">More Info at Vulkan.org</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Community</a>
          <div class="navbar-dropdown is-right">
            <a class="navbar-item" href="https://discord.gg/vulkan">Vulkan Discord</a>
            <a class="navbar-item" href="https://reddit.com/r/vulkan">Reddit</a>
            <a class="navbar-item" href="https://stackoverflow.com/questions/tagged/vulkan">Stack Overflow</a>
            <a class="navbar-item" href="https://twitter.com/vulkanapi">X</a>
            <a class="navbar-item" href="https://fosstodon.org/@vulkan">Mastodon</a>
          </div>
        </div>
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="samples" data-version="latest">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="../../../README.html">Vulkan Samples</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../vulkan_basics.html">Vulkan basics</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../../framework/README.html">Sample framework</a>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../api/README.html">Api usage samples</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../api/compute_nbody/README.html">Compute N-body</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../api/hpp_compute_nbody/README.html">Compute N-body (Vulkan.hpp)</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../api/dynamic_uniform_buffers/README.html">Dynamic uniform buffers</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../api/hpp_dynamic_uniform_buffers/README.html">Dynamic Uniform Buffers (Vulkan.hpp)</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../api/hdr/README.html">HDR</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../api/hpp_hdr/README.html">HDR (Vulkan.hpp)</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../api/hello_triangle/README.html">Hello Triangle</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../api/hpp_hello_triangle/README.html">Hello Triangle (Vulkan.hpp)</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../api/hlsl_shaders/README.html">HLSL Shaders</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../api/hpp_hlsl_shaders/README.html">HLSL Shaders (Vulkan.hpp)</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../api/instancing/README.html">Instancing</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../api/hpp_instancing/README.html">Instancing (Vulkan.hpp)</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../api/separate_image_sampler/README.html">Separate image sampler</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../api/hpp_separate_image_sampler/README.html">Separate image sampler (Vulkan.hpp)</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../api/terrain_tessellation/README.html">Terrain tessellation</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../api/hpp_terrain_tessellation/README.html">Terrain tessellation (Vulkan.hpp)</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../api/texture_loading/README.html">Texture loading</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../api/hpp_texture_loading/README.html">Texture loading (Vulkan.hpp)</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../api/texture_mipmap_generation/README.html">Texture mipmap generation</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../api/hpp_texture_mipmap_generation/README.html">Texture mipmap generation (Vulkan.hpp)</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../api/timestamp_queries/README.html">Timestamp queries</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../api/hpp_timestamp_queries/README.html">Timestamp queries (Vulkan.hpp)</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../README.html">Extension usage samples</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../buffer_device_address/README.html">Buffer device address</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../calibrated_timestamps/README.html">Calibrated timestamps</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../conditional_rendering/README.html">Conditional rendering</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../conservative_rasterization/README.html">Conservative rasterization</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../debug_utils/README.html">Debug utils</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../descriptor_buffer_basic/README.html">Descriptor buffer basic</a>
  </li>
  <li class="nav-item is-current-page" data-depth="2">
    <a class="nav-link" href="README.html">Descriptor indexing</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../dynamic_line_rasterization/README.html">Dynamic line rasterization</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../dynamic_rendering/README.html">Dynamic rendering</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../extended_dynamic_state2/README.html">Extended dynamic state2</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../fragment_shader_barycentric/README.html">Fragment shader barycentric</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../fragment_shading_rate/README.html">Fragment shading rate</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../fragment_shading_rate_dynamic/README.html">Fragment shading rate dynamic</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../full_screen_exclusive/README.html">Full screen exclusive</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../graphics_pipeline_library/README.html">Graphics pipeline library</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../gshader_to_mshader/README.html">Geometry shader to mesh shader</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../logic_op_dynamic_state/README.html">Logic op dynamic state</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../memory_budget/README.html">Memory budget</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../mesh_shader_culling/README.html">Mesh shader culling</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../mesh_shading/README.html">Mesh shading</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../open_cl_interop/README.html">OpenCL interop</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../open_gl_interop/README.html">OpenGL interop</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../portability/README.html">Portability</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../push_descriptors/README.html">Push descriptors</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../raytracing_basic/README.html">Raytracing basic</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../raytracing_extended/README.html">Raytracing extended</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../ray_queries/README.html">Ray queries</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../ray_tracing_reflection/README.html">Ray tracing reflection</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../shader_object/README.html">Shader Object</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../synchronization_2/README.html">Synchronization 2</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../timeline_semaphore/README.html">Timeline semaphore</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../vertex_dynamic_state/README.html">Vertex dynamic state</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../performance/README.html">Performance samples</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../performance/16bit_arithmetic/README.html">16bit arithmetic</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../performance/16bit_storage_input_output/README.html">16bit storage input output</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../performance/afbc/README.html">AFBC</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../performance/async_compute/README.html">Async compute</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../performance/command_buffer_usage/README.html">Command buffer usage</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../performance/constant_data/README.html">Constant data</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../performance/descriptor_management/README.html">Descriptor management</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../performance/layout_transitions/README.html">Layout transitions</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../performance/msaa/README.html">MSAA</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../performance/multithreading_render_passes/README.html">Multithreading render passes</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../performance/multi_draw_indirect/README.html">Multi draw indirect</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../performance/pipeline_barriers/README.html">Pipeline barriers</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../performance/pipeline_cache/README.html">Pipeline cache</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../performance/hpp_pipeline_cache/README.html">Pipeline cache (Vulkan.hpp)</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../performance/render_passes/README.html">Render passes</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../performance/specialization_constants/README.html">Specialization constants</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../performance/subpasses/README.html">Subpasses</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../performance/surface_rotation/README.html">Surface rotation</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../performance/swapchain_images/README.html">Swapchain images</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../performance/hpp_swapchain_images/README.html">Swapchain images (Vulkan.hpp)</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../performance/texture_compression_basisu/README.html">Texture compression basisu</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../performance/texture_compression_comparison/README.html">Texture compression comparison</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../performance/wait_idle/README.html">Wait idle</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../tooling/README.html">Tooling samples</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../tooling/profiles/README.html">Profiles</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="#docs/README.adoc">General documentation</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../../docs/build.html">Build guide</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../../docs/memory_limits.html">Memory limits</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../../docs/misc.html">Miscellaneous</a>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Vulkan Samples</span>
    <span class="version">latest</span>
  </div>
  <ul class="components">
    <li class="component">
      <a class="title" href="../../../../../tutorial/latest/00_Introduction.html">Khronos Vulkan Tutorial</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../../../tutorial/latest/00_Introduction.html">latest</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <a class="title" href="../../../../../guide/latest/index.html">Vulkan Guide</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../../../guide/latest/index.html">latest</a>
        </li>
      </ul>
    </li>
    <li class="component is-current">
      <a class="title" href="../../../README.html">Vulkan Samples</a>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="../../../README.html">latest</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <a class="title" href="../../../../../spec/latest/index.html">Vulkan Specification and Proposals</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../../../spec/latest/index.html">latest</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../../../../../spec/latest/index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../../../README.html">Vulkan Samples</a></li>
    <li><a href="../README.html">Extension usage samples</a></li>
    <li><a href="README.html">Descriptor indexing</a></li>
  </ul>
</nav>
    <!--
  <div class="edit-this-page"><a href="https://github.com/KhronosGroup/Vulkan-Samples/edit/main/antora/modules/ROOT/pages/samples/extensions/descriptor_indexing/README.adoc">Edit this Page</a></div>
      -->
</div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">Descriptor indexing</h1>
<div id="preamble">
<div class="sectionbody">
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The source for this sample can be found in the <a href="https://github.com/KhronosGroup/Vulkan-Samples/tree/main/samples/extensions/descriptor_indexing">Khronos Vulkan samples github repository</a>.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_overview"><a class="anchor" href="#_overview"></a>Overview</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Descriptor indexing is an extension which adds a <strong>lot</strong> of flexibility to how resources are accessed.
The core functionality of this extension is that we can treat descriptor memory as one massive array, and we can freely access any resource we want at any time, by indexing.
The main insight is that if an array is large enough, an index into that array is indistinguishable from a pointer.
By allowing free access to any resource at any time, we can efficiently implement some advanced algorithms which rely on this functionality.</p>
</div>
<div class="paragraph">
<p>Descriptor indexing is also known by the term "bindless", which refers to the fact that binding individual descriptor sets and descriptors is no longer the primary way we keep shader pipelines fed.
Instead, we can bind a huge descriptor set once and just index into a large number of descriptors.
"Bindless algorithms" are generally built around this flexibility where we either index freely into a lot of descriptors at once, or update descriptors where we please.
In this model, "binding" descriptors is not a concern anymore.
At most, we need to write/copy descriptors to where we need them and we can now consider descriptors more like memory blobs rather than highly structured API objects.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_use_cases"><a class="anchor" href="#_use_cases"></a>Use cases</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_update_after_bind_streaming_descriptors_concurrently"><a class="anchor" href="#_update_after_bind_streaming_descriptors_concurrently"></a>Update-After-Bind, streaming descriptors concurrently</h3>
<div class="paragraph">
<p>The first major feature is update-after-bind.
In Vulkan, you generally have to create a <code>VkDescriptorSet</code> and update it with all descriptors before you call <code>vkCmdBindDescriptorSets</code>.
After a set is bound, the descriptor set cannot be updated again until the GPU is done using it.
This gives drivers a lot of flexibility in how they access the descriptors.
They are free to copy the descriptors and pack them somewhere else, promote them to hardware registers, the list goes on.</p>
</div>
<div class="paragraph">
<p>Update-After-Bind gives flexibility to applications instead.
Descriptors can be updated at any time as long as they are not actually accessed by the GPU.
Descriptors can also be updated while the descriptor set is bound to a command buffer, which enables a "streaming" use case.</p>
</div>
<div class="paragraph">
<p>The <a href="../../performance/constant_data">Constant Data performance sample</a> also demonstrates update-after-bind descriptors.</p>
</div>
<div class="sect3">
<h4 id="_concurrent_updates"><a class="anchor" href="#_concurrent_updates"></a>Concurrent updates</h4>
<div class="paragraph">
<p>Another "hidden" feature of update-after-bind is that it is possible to update the descriptor set from multiple threads.
This is very useful for true "bindless" since unrelated tasks might want to update descriptors in different parts of the streamed/bindless descriptor set.</p>
</div>
</div>
<div class="sect3">
<h4 id="_descriptor_flags"><a class="anchor" href="#_descriptor_flags"></a>Descriptor flags</h4>
<div class="paragraph">
<p>To enable UPDATE_AFTER_BIND_BIT features for a descriptor binding, there is a little song and dance that must be performed.</p>
</div>
<div class="paragraph">
<p>In <code>VkDescriptorSetLayoutCreateInfo</code> we must pass down binding flags in a separate struct with <code>pNext</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">VkDescriptorSetLayoutCreateInfo set_layout_create_info{VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO};
set_layout_create_info.flags = VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT;
const VkDescriptorBindingFlagsEXT flags =
    VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT |
    VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT_EXT |
    VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT |
    VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT;

VkDescriptorSetLayoutBindingFlagsCreateInfoEXT binding_flags{};
binding_flags.sType          = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT;
binding_flags.bindingCount   = 1;
binding_flags.pBindingFlags  = &amp;flags;
set_layout_create_info.pNext = &amp;binding_flags;

VK_CHECK(vkCreateDescriptorSetLayout(get_device().get_handle(), &amp;set_layout_create_info, nullptr, &amp;descriptors.set_layout));</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>VkDescriptorPool</code> must also be created with UPDATE_AFTER_BIND_BIT.
Note that there is global limit to how many UPDATE_AFTER_BIND_BIT descriptors can be allocated at any point.
The min-spec here is 500k, which should be good enough.</p>
</div>
<div class="paragraph">
<p>See code for more detailed comments.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_non_uniform_indexing_enabling_advanced_algorithms"><a class="anchor" href="#_non_uniform_indexing_enabling_advanced_algorithms"></a>Non-uniform indexing, enabling advanced algorithms</h3>
<div class="paragraph">
<p>While update-after-bind adds flexibility to descriptor management, non-uniform indexing adds great flexibility for shaders.</p>
</div>
<div class="sect3">
<h4 id="_the_different_levels_of_indexing_resources"><a class="anchor" href="#_the_different_levels_of_indexing_resources"></a>The different levels of indexing resources</h4>
<div class="paragraph">
<p>How we access resources has changed a lot over the years.
Mostly this is due to hardware considerations, but modern hardware is generally quite flexible in how resources are accessed.</p>
</div>
<div class="sect4">
<h5 id="_constant_indexing"><a class="anchor" href="#_constant_indexing"></a>Constant indexing</h5>
<div class="paragraph">
<p>In the beginning there was constant indexing.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">layout(set = 0, binding = 0) uniform sampler2D Tex[4];

texture(Tex[0], ...);
texture(Tex[2], ...);

// We can trivially flatten a constant-indexed array into individual resources,
// so, constant indexing requires no fancy hardware indexing support.
layout(set = 0, binding = 0) uniform sampler2D Tex0;
layout(set = 0, binding = 1) uniform sampler2D Tex1;
layout(set = 0, binding = 2) uniform sampler2D Tex2;
layout(set = 0, binding = 3) uniform sampler2D Tex3;</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_dynamic_indexing"><a class="anchor" href="#_dynamic_indexing"></a>Dynamic indexing</h5>
<div class="paragraph">
<p>After constant indexing we have dynamic indexing.
This has been supported since Vulkan 1.0.
The dynamic indexing features allow us to use a non-constant expression to index an array.
The restriction is that the index must be <strong>dynamically uniform</strong>, which will be explained later &#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">layout(set = 0, binding = 0) uniform sampler2D Tex[4];

texture(Tex[dynamically_uniform_expression], ...);</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_non_uniform_indexing"><a class="anchor" href="#_non_uniform_indexing"></a>Non-uniform indexing</h5>
<div class="paragraph">
<p>Non-uniform indexing completely removes all restrictions on how we index into arrays, but we must notify our intent to the compiler.
Normally, drivers and hardware can assume that the dynamically uniform guarantee holds, and optimize for that case.
If we use the <code>nonuniformEXT</code> decoration in <code>GL_EXT_nonuniform_qualifier</code> we can let the compiler know that the guarantee does not necessarily hold, and the compiler will deal with it in the most efficient way possible for the target hardware.</p>
</div>
<div class="paragraph">
<p>The rationale for having to annotate like this is that driver compiler backends would be forced to be more conservative than necessary if applications were not required to use <code>nonuniformEXT</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">// Unsized arrays, nice!
layout(set = 0, binding = 0) uniform sampler2D Tex[];
texture(Tex[nonuniformEXT(arbitrary_expression)], ...);</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_non_uniform_indexing_vs_texture_atlas_vs_texture_array"><a class="anchor" href="#_non_uniform_indexing_vs_texture_atlas_vs_texture_array"></a>Non-uniform indexing vs. texture atlas vs. texture array</h4>
<div class="paragraph">
<p>Accessing arbitrary textures in a draw call is not a new problem, and graphics programmers have found ways over the years to workaround restrictions in older APIs.
Rather than having multiple textures, it is technically possible to pack multiple textures into one texture resource, and sample from the correct part of the texture.
This kind of technique is typically referred to as "texture atlas".
Texture arrays (e.g.
sampler2DArray) is another feature which can be used for similar purposes.</p>
</div>
<div class="paragraph">
<p>Problems with atlas:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Mip-mapping is hard to implement, and must likely be done manually with derivatives and math</p>
</li>
<li>
<p>Anisotropic filtering is basically impossible</p>
</li>
<li>
<p>Any other sampler addressing than <code>CLAMP_TO_EDGE</code> is very awkward to implement</p>
</li>
<li>
<p>Cannot use different texture formats</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Problems with texture array:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>All resolutions must match</p>
</li>
<li>
<p>Number of array layers is limited (just 256 in min-spec)</p>
</li>
<li>
<p>Cannot use different texture formats</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Non-uniform indexing solves these issues since we can freely use multiple sampled image descriptors instead.
Atlases and texture arrays still have their place.
There are many use cases where these restrictions do not cause problems.</p>
</div>
</div>
<div class="sect3">
<h4 id="_not_just_textures"><a class="anchor" href="#_not_just_textures"></a>Not just textures</h4>
<div class="paragraph">
<p>Non-uniform indexing is not just limited to textures (although that is the most relevant use case).
Any descriptor type can be used as long as the device supports it.</p>
</div>
</div>
<div class="sect3">
<h4 id="_when_to_use_non_uniform_indexing_qualifier"><a class="anchor" href="#_when_to_use_non_uniform_indexing_qualifier"></a>When to use non-uniform indexing qualifier</h4>
<div class="paragraph">
<p><strong>Dynamically uniform</strong> is a somewhat difficult concept to understand.
There is some terminology we must introduce here.</p>
</div>
<div class="sect4">
<h5 id="_the_invocation_group"><a class="anchor" href="#_the_invocation_group"></a>The invocation group</h5>
<div class="paragraph">
<p>The invocation group is a set of threads (invocations) which work together to perform a task.</p>
</div>
<div class="paragraph">
<p>In graphics pipelines, the invocation group is all threads which are spawned as part of a single draw command.
This includes multiple instances, and for multi-draw-indirect it is limited to a single <code>gl_DrawID</code>.</p>
</div>
<div class="paragraph">
<p>In compute pipelines, the invocation group is a single workgroup, so it&#8217;s very easy to know when it is safe to avoid nonuniformEXT.</p>
</div>
<div class="paragraph">
<p>An expression is considered dynamically uniform if all invocations in an invocation group have the same value.</p>
</div>
</div>
<div class="sect4">
<h5 id="_how_do_subgroups_interact_here"><a class="anchor" href="#_how_do_subgroups_interact_here"></a>How do subgroups interact here?</h5>
<div class="paragraph">
<p>It is very easy to think that dynamically uniform just means "as long as the index is uniform in the subgroup, it&#8217;s fine!".
This is certainly true for most (desktop) architectures, but not all.</p>
</div>
<div class="paragraph">
<p>It is technically possible that a value can be subgroup uniform, but still not dynamically uniform.
Consider a case where we a have a workgroup size of 128 threads, with a subgroup size of 32.
Even if each subgroup does <code>subgroupBroadcastFirst()</code> on the index, each subgroup might have different values, and thus, we still technically need <code>nonuniformEXT</code> here.
If you know that you have only one subgroup per workgroup however, <code>subgroupBroadcastFirst()</code> is good enough.</p>
</div>
<div class="paragraph">
<p>The safe thing to do is to just add <code>nonuniformEXT</code> if you cannot prove the dynamically uniform property.
If the compiler knows that it only really cares about subgroup uniformity, it could trivially optimize away <code>nonuniformEXT(subgroupBroadcastFirst())</code> anyways.</p>
</div>
<div class="paragraph">
<p>The common reason to use subgroups in the first place, is that it was an old workaround for lack of true non-uniform indexing, especially for desktop GPUs.
A common pattern would be something like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">bool needs_work = true;
uint index = something_non_uniform();
do
{
    if (subgroupBroadcastFirst(index) == index)
    {
        // index is subgroup uniform, which is good enough for most (all?) desktop GPU architectures.
        // It is not technically correct, just use nonuniformEXT().
        // This style of code can still be worthwhile if we're loading uniform data based on index,
        // since we can greatly improve memory access patterns,
        // but that's another topic and is very IHV dependent ...
        texture(Tex[index], ...);
        needs_work = false;
    }
} while (needs_work);</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_vulkan_glsl_examples"><a class="anchor" href="#_vulkan_glsl_examples"></a>Vulkan GLSL examples</h5>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">#version 450
#extension GL_EXT_nonuniform_qualifier : require
layout(local_size_x = 64) in;

layout(set = 0, binding = 0) uniform sampler2D Combined[];
layout(set = 1, binding = 0) uniform texture2D Tex[];
layout(set = 2, binding = 0) uniform sampler Samp[];
layout(set = 3, binding = 0) uniform U { vec4 v; } UBO[];
layout(set = 4, binding = 0) buffer S { vec4 v; } SSBO[];
layout(set = 5, binding = 0, r32ui) uniform uimage2D Img[];

void main()
{
	uint index = gl_GlobalInvocationID.x;
	vec2 uv = vec2(gl_GlobalInvocationID.yz) / 1024.0;

	vec4 a = textureLod(Combined[nonuniformEXT(index)], uv, 0.0);
	vec4 b = textureLod(nonuniformEXT(sampler2D(Tex[index], Samp[index])), uv, 0.0);
	vec4 c = UBO[nonuniformEXT(index)].v;
	vec4 d = SSBO[nonuniformEXT(index)].v;

	imageAtomicAdd(Img[nonuniformEXT(index)], ivec2(0), floatBitsToUint(a.x + b.y + c.z + d.w));
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_hlsl_examples"><a class="anchor" href="#_hlsl_examples"></a>HLSL examples</h5>
<div class="paragraph">
<p>With DXC:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-hlsl hljs" data-lang="hlsl">Texture2D&lt;float4&gt; Tex[] : register(t0, space0);
SamplerState Samp[] : register(s0, space1);

struct Float4 { float4 v; };
ConstantBuffer&lt;Float4&gt; CBV[] : register(b0, space2);
RWStructuredBuffer&lt;float4&gt; SSBO[] : register(u0, space3);
RWTexture2D&lt;uint&gt; Img[] : register(u0, space4);

[numthreads(64, 1, 1)]
void main(uint3 thr : SV_DispatchThreadID)
{
	uint index = thr.x;
	float2 uv = float2(thr.yz) / 1024.0;
	float4 a = Tex[NonUniformResourceIndex(index)].SampleLevel(Samp[NonUniformResourceIndex(index)], uv, 0.0);
	float4 b = CBV[NonUniformResourceIndex(index)].v;
	float4 c = SSBO[NonUniformResourceIndex(index)][0];

	uint out_value;
	InterlockedAdd(Img[NonUniformResourceIndex(index)][int2(0, 0)], asuint(a.x + b.y + c.z), out_value);
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_what_to_look_for_in_spir_v"><a class="anchor" href="#_what_to_look_for_in_spir_v"></a>What to look for in SPIR-V</h5>
<div class="paragraph">
<p>In SPIR-V, it might be a bit unclear where to place the <code>NonUniform</code> decoration, but it is defined such that it is the final argument which is used in a load/store/sample/atomic command that must be decorated.
It is meaningless to decorate the index expression itself (although it would be natural!).
Some older buggy drivers did rely on the index itself being decorated though, so if you&#8217;re emitting SPIR-V yourself, it does not hurt to place NonUniform index redundantly, although it is an ugly caveat &#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>E.g.
for the <code>nonuniform-quads.frag</code> shader, we get:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-asciidoc hljs" data-lang="asciidoc">OpDecorate %27 NonUniform ; By spec, this is the only NonUniform we need
%26 = OpSampledImage %25 %20 %24
%27 = OpCopyObject %25 %26 ; This is a glslangValidator quirk
%32 = OpImageSampleImplicitLod %v4float %27 %31 ; It is %27 here which is significant</code></pre>
</div>
</div>
<div class="paragraph">
<p>Similarly for <code>OpLoad</code> and <code>OpStore</code> from and to UBO/SSBO it would be the pointer argument, and for <code>OpAtomic*</code> we would use NonUniform on the pointer argument.</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_the_sample"><a class="anchor" href="#_the_sample"></a>The sample</h2>
<div class="sectionbody">
<div class="imageblock">
<div class="content">
<img src="../../../_images/samples/extensions/descriptor_indexing/images/sample.png" alt="Sample">
</div>
</div>
<div class="paragraph">
<p>The goal of this sample is to demonstrate how to use the two main use cases enabled by descriptor indexing.</p>
</div>
<div class="paragraph">
<p>On the left side, we bind 64 unique textures and render them all in one draw call.
This makes use of non-uniform indexing of descriptors and assigns <code>gl_InstanceIndex</code> to an index into the descriptor array.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">#extension GL_EXT_nonuniform_qualifier : require
layout(set = 0, binding = 0) uniform texture2D Textures[];
layout(set = 1, binding = 0) uniform sampler ImmutableSampler;
out_frag_color = texture(nonuniformEXT(sampler2D(Textures[in_texture_index], ImmutableSampler)), in_uv);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The critical aspect here is <code>nonuniformEXT</code>, which lets us index into an array of resources where the index is <strong>not</strong> dynamically uniform.
For graphics, dynamically uniform means that the index is the same across all threads spawned by a draw commands.</p>
</div>
<div class="paragraph">
<p>On the right side, we render the same textures, but in this case we use the "update-after-bind" model, where we simply stream descriptors to a single descriptor set.
This is a style where we eliminate most of the complication with descriptor set management, and treat descriptor memory as a ring buffer.
We can place an offset into this ring in push constant memory, e.g.:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">layout(push_constant) uniform Registers
{
    layout(offset = 4) uint table_offset;
} registers;

void main()
{
    out_frag_color = texture(sampler2D(Textures[registers.table_offset], ImmutableSampler), in_uv);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We could go up to as much as 500k textures in the minimum spec for Vulkan, but it would be impractical to use that many for purposes of visualization.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_debugging_descriptor_indexing"><a class="anchor" href="#_debugging_descriptor_indexing"></a>Debugging descriptor indexing</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Descriptor indexing is very powerful, but it also means debugging and validating such shaders becomes more difficult.
There is more room for errors, e.g.
it is possible for application to index into descriptors that were never initialized, or you can access stale descriptors which resource was destroyed earlier.
There are means to debug and validate this in Vulkan.</p>
</div>
<div class="sect2">
<h3 id="_renderdoc"><a class="anchor" href="#_renderdoc"></a>RenderDoc</h3>
<div class="paragraph">
<p>For example, here we look at the non-uniform draw call which renders the left half of the screen.
<span class="image"><img src="../../../_images/samples/extensions/descriptor_indexing/images/non-uniform-draw.png" alt="non-uniform-draw"></span></p>
</div>
<div class="paragraph">
<p>RenderDoc supports debugging of descriptor indexing.
When inspecting the state panel, we can see all the descriptors which were accessed in the draw call.
It is important to note that RenderDoc must instrument your shaders with extra code which tags the resources which are <em>actually</em> accessed.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../../../_images/samples/extensions/descriptor_indexing/images/non-uniform-usage.png" alt="non-uniform-usage">
</div>
</div>
<div class="paragraph">
<p>Here we can see that all array entries were used, except index 0, which was never accessed since that particular quad was fully clipped away.
This is a quirk to keep in mind.</p>
</div>
<div class="paragraph">
<p>In the update-after-bind case, we draw one texture at a time, and these cases are much more straight forward to debug.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../../../_images/samples/extensions/descriptor_indexing/images/update-after-bind.png" alt="update-after-bind">
</div>
</div>
<div class="paragraph">
<p>Here we see that we accessed index 202, which corresponds to the push constant <code>table_offset</code> we passed to the shader, neat!</p>
</div>
</div>
<div class="sect2">
<h3 id="_gpu_assisted_validation"><a class="anchor" href="#_gpu_assisted_validation"></a>GPU assisted validation</h3>
<div class="paragraph">
<p>With descriptor indexing, it is impossible for a validation layer to validate at draw time, since it cannot know which resources a shader intends to access, and with update-after-bind, the descriptor might be filled in right before <code>vkQueueSubmit</code>.
Similar to RenderDoc, the validation layers must instrument your shaders which slows runtime down significantly.
For this reason, GPU-assisted validation is opt-in.</p>
</div>
<div class="paragraph">
<p>In <code>instance.cpp</code> we make use of <code>VK_EXT_validation_features</code> to enable GPU-assisted validation if <code>VKB_VALIDATION_LAYERS_GPU_ASSISTED</code> is set in the CMake build.</p>
</div>
<div class="paragraph">
<p>The key thing to know is that this is an extension exposed by the validation layer itself, so we need to query instance extensions directly on the layer.
E.g.:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">bool validation_features = false;
uint32_t layer_instance_extension_count;
VK_CHECK(vkEnumerateInstanceExtensionProperties("VK_LAYER_KHRONOS_validation", &amp;layer_instance_extension_count, nullptr));
std::vector&lt;VkExtensionProperties&gt; available_layer_instance_extensions(layer_instance_extension_count);
VK_CHECK(vkEnumerateInstanceExtensionProperties("VK_LAYER_KHRONOS_validation", &amp;layer_instance_extension_count, available_layer_instance_extensions.data()));

for (auto &amp;available_extension : available_layer_instance_extensions)
{
    if (strcmp(available_extension.extensionName, VK_EXT_VALIDATION_FEATURES_EXTENSION_NAME) == 0)
    {
        validation_features = true;
        LOGI("{} is available, enabling it", VK_EXT_VALIDATION_FEATURES_EXTENSION_NAME);
        enabled_extensions.push_back(VK_EXT_VALIDATION_FEATURES_EXTENSION_NAME);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If present, we can pass down information to <code>vkCreateInstance</code> about the features we need to enable:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">VkValidationFeaturesEXT validation_features_info = {VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT};
if (validation_features)
{
    static const VkValidationFeatureEnableEXT enable_features[2] = {
        VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_RESERVE_BINDING_SLOT_EXT,
        VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_EXT,
    };
    validation_features_info.enabledValidationFeatureCount = 2;
    validation_features_info.pEnabledValidationFeatures    = enable_features;
    validation_features_info.pNext                         = instance_info.pNext;
    instance_info.pNext                                    = &amp;validation_features_info;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The features to enable is <code>GPU_ASSISTED_EXT</code> and <code>RESERVE_BINDING_SLOT_EXT</code>.
The extra descriptor set slot is reserved by validation layers so it can bind metadata buffers.
Instrumented shaders will write here as they execute.</p>
</div>
<div class="paragraph">
<p>If we enable this, and say pretend that we forgot to update descriptor #3:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">for (unsigned i = 0; i &lt; NumDescriptorsNonUniform; i++)
{
    ...
    if (i != 3)
        vkUpdateDescriptorSets(get_device().get_handle(), 1, &amp;write, 0, nullptr);
    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We end up with:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-asciidoc hljs" data-lang="asciidoc">[error] [framework/core/instance.cpp:41] -1993010233 - UNASSIGNED-Descriptor uninitialized: Validation Error: [ UNASSIGNED-Descriptor uninitialized ] Object 0: handle = 0x55625acf5600, type = VK_OBJECT_TYPE_QUEUE; | MessageID = 0x893513c7 | Descriptor index 3 is uninitialized.  Command buffer (0x55625b187090). Draw Index 0x4. Pipeline (0x520000000052). Shader Module (0x510000000051). Shader Instruction Index = 59.  Stage = Fragment.  Fragment coord (x,y) = (930.5, 0.5).  Unable to find SPIR-V OpLine for source information.  Build shader with debug info to get source information.
[error] [framework/core/instance.cpp:41] -1993010233 - UNASSIGNED-Descriptor uninitialized: Validation Error: [ UNASSIGNED-Descriptor uninitialized ] Object 0: handle = 0x55625acf5600, type = VK_OBJECT_TYPE_QUEUE; | MessageID = 0x893513c7 | Descriptor index 67 is uninitialized.  Command buffer (0x55625b184d60). Draw Index 0x4. Pipeline (0x520000000052). Shader Module (0x510000000051). Shader Instruction Index = 59.  Stage = Fragment.  Fragment coord (x,y) = (944.5, 0.5).  Unable to find SPIR-V OpLine for source information.  Build shader with debug info to get source information.
[error] [framework/core/instance.cpp:41] -1993010233 - UNASSIGNED-Descriptor uninitialized: Validation Error: [ UNASSIGNED-Descriptor uninitialized ] Object 0: handle = 0x55625acf5600, type = VK_OBJECT_TYPE_QUEUE; | MessageID = 0x893513c7 | Descriptor index 131 is uninitialized.  Command buffer (0x55625b1893c0). Draw Index 0x4. Pipeline (0x520000000052). Shader Module (0x510000000051). Shader Instruction Index = 59.  Stage = Fragment.  Fragment coord (x,y) = (944.5, 0.5).  Unable to find SPIR-V OpLine for source information.  Build shader with debug info to get source information.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Adding debug symbols to the SPIR-V helps here, but that&#8217;s another topic.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_conclusion"><a class="anchor" href="#_conclusion"></a>Conclusion</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Descriptor indexing is a highly potent extension, but with great power comes great responsibility to use all debug tools available to you.
s to the SPIR-V helps here, but that&#8217;s another topic.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_conclusion_2"><a class="anchor" href="#_conclusion_2"></a>Conclusion</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Descriptor indexing is a highly potent extension, but with great power comes great responsibility to use all debug tools available to you.</p>
</div>
</div>
</div>
</article>
  </div>
</main>
</div>
<footer class="footer">
    <!--
  <p>This page was built using the Antora default UI.</p>
  <p>The source code for this UI is licensed under the terms of the MPL-2.0 license.</p>
    -->
</footer>
<script id="site-script" src="../../../../../_/js/site.js" data-ui-root-path="../../../../../_"></script>
<script async src="../../../../../_/js/vendor/highlight.js"></script>
<script src="../../../../../_/js/vendor/lunr.js"></script>
<script src="../../../../../_/js/search-ui.js" id="search-ui-script" data-site-root-path="../../../../.." data-snippet-length="100" data-stylesheet="../../../../../_/css/search.css"></script>
<script async src="../../../../../search-index.js"></script>
  </body>
</html>

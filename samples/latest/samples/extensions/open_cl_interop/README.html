<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Cross vendor OpenCL and Vulkan interoperability :: Vulkan Documentation Project</title>
    <meta name="generator" content="Antora 3.1.4">
    <link rel="stylesheet" href="../../../../../_/css/site.css">
    <link rel="apple-touch-icon" sizes="180x180" href="../../../../../_/img/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="../../../../../_/img/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="../../../../../_/img/favicon-16x16.png">
    <link rel="manifest" href="../../../../../_/static/site.webmanifest">
    <link rel="mask-icon" href="../../../../../_/img/safari-pinned-tab.svg" color="#a41e22">
    <meta name="msapplication-TileColor" content="#ffc40d">
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="../../../../.."><img class="navbar-item" alt="Vulkan White Label" src="../../../../../_/Vulkan_Docs.svg" /></a>
      <div class="navbar-item search hide-for-print">
        <div id="search-field" class="field has-filter">
          <label for="search-input"></label>
          <input id="search-input" type="text" placeholder="Search the docs">
          <label class="filter checkbox">
            <input type="checkbox" data-facet-filter="component:samples" checked> In this component
          </label>
        </div>
      </div>
      <button class="navbar-burger" aria-controls="topbar-nav" aria-expanded="false" aria-label="Toggle main menu">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <!-- <a class="navbar-item" href="#">Home</a> -->
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Specs</a>
          <div class="navbar-dropdown is-right">
            <a class="navbar-item" href="../../../../../spec/latest/chapters/introduction.html">Vulkan API</a>
            <a class="navbar-item" href="../../../../../glsl/latest/index.html">GLSL</a>
            <a class="navbar-item" href="../../../../../guide/latest/hlsl.html">HLSL</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Education</a>
          <div class="navbar-dropdown is-right">
            <a class="navbar-item" href="../../../../../features/latest/features/index.html">Vulkan Feature Descriptions</a>
            <a class="navbar-item" href="../../../../../guide/latest/index.html">Vulkan Guide</a>
            <a class="navbar-item" href="../../../../../samples/latest/README.html">Vulkan Samples</a>
            <a class="navbar-item" href="../../../../../tutorial/latest/index.html">Vulkan Tutorial</a>
            <a class="navbar-item" href="https://www.youtube.com/c/vulkan">YouTube</a>
            <a class="navbar-item" href="https://vulkan.org">More Info at Vulkan.org</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Feedback</a>
          <div class="navbar-dropdown is-right">
            <a class="navbar-item" href="https://github.com/KhronosGroup/Vulkan-Site/issues/new/choose" target="_blank">Report a Problem</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Community</a>
          <div class="navbar-dropdown is-right">
            <a class="navbar-item" href="https://discord.gg/vulkan">Vulkan Discord</a>
            <a class="navbar-item" href="https://reddit.com/r/vulkan">Reddit</a>
            <a class="navbar-item" href="https://stackoverflow.com/questions/tagged/vulkan">Stack Overflow</a>
            <a class="navbar-item" href="https://fosstodon.org/@vulkan">Mastodon</a>
          </div>
        </div>
      </div>
    </div>
    <label class="theme-toggler">
      <input type="checkbox" id="switch-theme-checkbox" name="switch-theme-checkbox"/>
      <span class="icon"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="moon" class="svg-inline--fa fa-moon moon" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><path fill="currentColor" d="M223.5 32C100 32 0 132.3 0 256S100 480 223.5 480c60.6 0 115.5-24.2 155.8-63.4c5-4.9 6.3-12.5 3.1-18.7s-10.1-9.7-17-8.5c-9.8 1.7-19.8 2.6-30.1 2.6c-96.9 0-175.5-78.8-175.5-176c0-65.8 36-123.1 89.3-153.3c6.1-3.5 9.2-10.5 7.7-17.3s-7.3-11.9-14.3-12.5c-6.3-.5-12.6-.8-19-.8z"></path>
        </svg>
        <svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="sun" class="svg-inline--fa fa-sun sun" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M361.5 1.2c5 2.1 8.6 6.6 9.6 11.9L391 121l107.9 19.8c5.3 1 9.8 4.6 11.9 9.6s1.5 10.7-1.6 15.2L446.9 256l62.3 90.3c3.1 4.5 3.7 10.2 1.6 15.2s-6.6 8.6-11.9 9.6L391 391 371.1 498.9c-1 5.3-4.6 9.8-9.6 11.9s-10.7 1.5-15.2-1.6L256 446.9l-90.3 62.3c-4.5 3.1-10.2 3.7-15.2 1.6s-8.6-6.6-9.6-11.9L121 391 13.1 371.1c-5.3-1-9.8-4.6-11.9-9.6s-1.5-10.7 1.6-15.2L65.1 256 2.8 165.7c-3.1-4.5-3.7-10.2-1.6-15.2s6.6-8.6 11.9-9.6L121 121 140.9 13.1c1-5.3 4.6-9.8 9.6-11.9s10.7-1.5 15.2 1.6L256 65.1 346.3 2.8c4.5-3.1 10.2-3.7 15.2-1.6zM160 256a96 96 0 1 1 192 0 96 96 0 1 1 -192 0zm224 0a128 128 0 1 0 -256 0 128 128 0 1 0 256 0z"></path>
        </svg></span>
      <span class="text">light</span>
    </label>
  </nav>
</header>
<script>
  !function() {
    let e = document.getElementById("switch-theme-checkbox")
    e.checked = document.documentElement.classList.contains("dark-theme")
    e.addEventListener("change", function() {
      if (document.documentElement.classList.contains("light")) {
        document.documentElement.classList.remove("light")
        document.documentElement.classList.add("dark")
      } else if (document.documentElement.classList.contains("dark")) {
        document.documentElement.classList.remove("dark")
        document.documentElement.classList.add("light")
      } else {
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
          document.documentElement.classList.add("dark")
        } else {
          document.documentElement.classList.add("light")
        }
      }
      document.documentElement.classList.toggle("dark-theme", this.checked), document.documentElement.setAttribute("data-theme", this.checked ? "dark" : "light"),
        function(e) {
          window.localStorage && window.localStorage.setItem("theme", e)
        }(this.checked ? "dark" : "light"), this.checked ? this.parentElement.classList.add("active") : this.parentElement.classList.remove("active")
    }.bind(e))
  }();
</script>
<div class="body">
<div class="nav-container" data-component="samples" data-version="latest">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <button class="nav-menu-toggle" aria-label="Toggle expand/collapse all" style="display: none"></button>
    <h3 class="title"><a href="../../../README.html">Vulkan Samples</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../README.html">Samples overview</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../vulkan_basics.html">Vulkan basics</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../../shaders/README.html">Shaders</a>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../../framework/README.html">Sample framework</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../../components/README.html">Framework components</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../api/README.html">Api usage samples</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../api/compute_nbody/README.html">Compute N-body</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../api/hpp_compute_nbody/README.html">Compute N-body (Vulkan-Hpp)</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../api/dynamic_uniform_buffers/README.html">Dynamic uniform buffers</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../api/hpp_dynamic_uniform_buffers/README.html">Dynamic Uniform Buffers (Vulkan-Hpp)</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../api/hdr/README.html">HDR</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../api/hpp_hdr/README.html">HDR (Vulkan-Hpp)</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../api/hello_triangle/README.html">Hello Triangle</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../api/hello_triangle_1_3/README.html">Hello Triangle 1.3</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../api/hpp_hello_triangle/README.html">Hello Triangle (Vulkan-Hpp)</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../api/hlsl_shaders/README.html">HLSL Shaders</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../api/hpp_hlsl_shaders/README.html">HLSL Shaders (Vulkan-Hpp)</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../api/instancing/README.html">Instancing</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../api/hpp_instancing/README.html">Instancing (Vulkan-Hpp)</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../api/separate_image_sampler/README.html">Separate image sampler</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../api/hpp_separate_image_sampler/README.html">Separate image sampler (Vulkan-Hpp)</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../api/terrain_tessellation/README.html">Terrain tessellation</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../api/hpp_terrain_tessellation/README.html">Terrain tessellation (Vulkan-Hpp)</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../api/texture_loading/README.html">Texture loading</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../api/hpp_texture_loading/README.html">Texture loading (Vulkan-Hpp)</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../api/texture_mipmap_generation/README.html">Texture mipmap generation</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../api/hpp_texture_mipmap_generation/README.html">Texture mipmap generation (Vulkan-Hpp)</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../api/timestamp_queries/README.html">Timestamp queries</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../api/hpp_timestamp_queries/README.html">Timestamp queries (Vulkan-Hpp)</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../api/oit_linked_lists/README.html">OIT linked lists</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../api/hpp_oit_linked_lists/README.html">OIT linked lists (Vulkan-Hpp)</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../api/oit_depth_peeling/README.html">OIT depth peeling</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../api/hpp_oit_depth_peeling/README.html">OIT depth peeling (Vulkan-Hpp)</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../README.html">Extension usage samples</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../buffer_device_address/README.html">Buffer device address</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../calibrated_timestamps/README.html">Calibrated timestamps</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../conditional_rendering/README.html">Conditional rendering</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../conservative_rasterization/README.html">Conservative rasterization</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../debug_utils/README.html">Debug utils</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../descriptor_buffer_basic/README.html">Descriptor buffer basic</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../descriptor_indexing/README.html">Descriptor indexing</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../dynamic_line_rasterization/README.html">Dynamic line rasterization</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../dynamic_primitive_clipping/README.html">Dynamic primitive clipping</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../dynamic_rendering/README.html">Dynamic rendering</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../dynamic_rendering_local_read/README.html">Dynamic rendering local read</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../extended_dynamic_state2/README.html">Extended dynamic state2</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../fragment_shader_barycentric/README.html">Fragment shader barycentric</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../fragment_shading_rate/README.html">Fragment shading rate</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../fragment_shading_rate_dynamic/README.html">Fragment shading rate dynamic</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../full_screen_exclusive/README.html">Full screen exclusive</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../graphics_pipeline_library/README.html">Graphics pipeline library</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../gshader_to_mshader/README.html">Geometry shader to mesh shader</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../host_image_copy/README.html">Host image copy</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../logic_op_dynamic_state/README.html">Logic op dynamic state</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../memory_budget/README.html">Memory budget</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../mesh_shader_culling/README.html">Mesh shader culling</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../mesh_shading/README.html">Mesh shading</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../hpp_mesh_shading/README.html">Mesh shading (Vulkan-Hpp)</a>
  </li>
</ul>
  </li>
  <li class="nav-item is-current-page" data-depth="2">
    <a class="nav-link" href="README.html">OpenCL interop</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../open_cl_interop_arm/README.html">OpenCL interop (Arm)</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../open_gl_interop/README.html">OpenGL interop</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../portability/README.html">Portability</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../push_descriptors/README.html">Push descriptors</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../hpp_push_descriptors/README.html">Push descriptors (Vulkan-Hpp)</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../ray_tracing_basic/README.html">Raytracing basic</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../ray_tracing_extended/README.html">Raytracing extended</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../ray_queries/README.html">Ray queries</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../ray_tracing_reflection/README.html">Ray tracing reflection</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../ray_tracing_position_fetch/README.html">Ray tracing position fetch</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../shader_object/README.html">Shader Object</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../shader_debugprintf/README.html">Shader Debug Printf</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../sparse_image/README.html">Sparse Image</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../synchronization_2/README.html">Synchronization 2</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../timeline_semaphore/README.html">Timeline semaphore</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../vertex_dynamic_state/README.html">Vertex dynamic state</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../performance/README.html">Performance samples</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../performance/16bit_arithmetic/README.html">16bit arithmetic</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../performance/16bit_storage_input_output/README.html">16bit storage input output</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../performance/afbc/README.html">AFBC</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../performance/async_compute/README.html">Async compute</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../performance/command_buffer_usage/README.html">Command buffer usage</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../performance/constant_data/README.html">Constant data</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../performance/descriptor_management/README.html">Descriptor management</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../performance/image_compression_control/README.html">Image compression control</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../performance/layout_transitions/README.html">Layout transitions</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../performance/msaa/README.html">MSAA</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../performance/multithreading_render_passes/README.html">Multithreading render passes</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../performance/multi_draw_indirect/README.html">Multi draw indirect</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../performance/pipeline_barriers/README.html">Pipeline barriers</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../performance/pipeline_cache/README.html">Pipeline cache</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../performance/hpp_pipeline_cache/README.html">Pipeline cache (Vulkan-Hpp)</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../performance/render_passes/README.html">Render passes</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../performance/specialization_constants/README.html">Specialization constants</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../performance/subpasses/README.html">Subpasses</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../performance/surface_rotation/README.html">Surface rotation</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../performance/swapchain_images/README.html">Swapchain images</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../performance/hpp_swapchain_images/README.html">Swapchain images (Vulkan-Hpp)</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../performance/texture_compression_basisu/README.html">Texture compression basisu</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../performance/texture_compression_comparison/README.html">Texture compression comparison</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../performance/hpp_texture_compression_comparison/README.html">Texture compression comparison (Vulkan-Hpp)</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../performance/wait_idle/README.html">Wait idle</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../tooling/README.html">Tooling samples</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../tooling/profiles/README.html">Profiles</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../general/README.html">General samples</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../general/mobile_nerf/README.html">Mobile NeRF</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../general/mobile_nerf_rayquery/README.html">Mobile NeRF Ray Query</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../../docs/README.html">General documentation</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../../docs/build.html">Build guide</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../../docs/memory_limits.html">Memory limits</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../../docs/misc.html">Miscellaneous</a>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Vulkan Samples</span>
    <span class="version">latest</span>
  </div>
  <ul class="components">
    <li class="component">
      <div class="title"><a href="../../../../../tutorial/latest/00_Introduction.html">Khronos Vulkan Tutorial</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../../../tutorial/latest/00_Introduction.html">latest</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../../../../glsl/latest/index.html">OpenGL Shading Language Specification</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../../../glsl/latest/index.html">latest</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../../../../features/latest/features/index.html">Vulkan Feature Descriptions</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../../../features/latest/features/index.html">latest</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../../../../guide/latest/index.html">Vulkan Guide</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../../../guide/latest/index.html">latest</a>
        </li>
      </ul>
    </li>
    <li class="component is-current">
      <div class="title"><a href="../../../README.html">Vulkan Samples</a></div>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="../../../README.html">latest</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../../../../spec/latest/index.html">Vulkan Specification</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../../../spec/latest/index.html">latest</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../../../../../spec/latest/index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../../../README.html">Vulkan Samples</a></li>
    <li><a href="../README.html">Extension usage samples</a></li>
    <li><a href="README.html">OpenCL interop</a></li>
  </ul>
</nav>
</div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">Cross vendor OpenCL and Vulkan interoperability</h1>
<div id="preamble">
<div class="sectionbody">
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The source for this sample can be found in the <a href="https://github.com/KhronosGroup/Vulkan-Samples/tree/main/samples/extensions/open_cl_interop">Khronos Vulkan samples github repository</a>.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_background"><a class="anchor" href="#_background"></a>Background</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Even though compute support in Vulkan is mandatory, there are still use-cases where the broader range of OpenCL&#8217;s compute features may be required, e.g. for complex scientific computations or for re-using existing OpenCL kernels. For that both apis offer a set of vendor independent extensions that allow zero-copy sharing of objects known to both apis (known as "api interoperability"). Zero-copy means that both apis can access these objects without the need to duplicate and copy them between the apis. This allows for an efficient sharing of these objects between Vulkan and OpenCL.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_the_sample"><a class="anchor" href="#_the_sample"></a>The sample</h2>
<div class="sectionbody">
<div class="imageblock">
<div class="content">
<img src="../../../_images/samples/extensions/open_cl_interop/images/open_cl_interop.jpg" alt="OpenCL interop sample">
</div>
</div>
<div class="paragraph">
<p>This sample demonstrates zero-copy sharing with an image that&#8217;s updated using an OpenCL compute kernel and displayed as a texture on a quad inside Vulkan. To sync between the two apis the sample also makes use of shared semaphores.</p>
</div>
<div class="paragraph">
<p>To fully understand how this sample works it&#8217;s advised to have experience with both Vulkan and OpenCL. While both apis are maintained by Khronos, they differ greatly in their usage and concepts</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_required_extensions"><a class="anchor" href="#_required_extensions"></a>Required extensions</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Both Vulkan and OpenCL offer extensions for so called external objects. An external object is something that can be referenced in multiple apis. In this sample we share images and semaphores, so we need to enable related extensions on both apis.</p>
</div>
<div class="paragraph">
<p>For <strong>sharing the memory</strong> backing up the image, in <strong>Vulkan</strong> we need to enable <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_external_memory_capabilities.html"><code>VK_KHR_external_memory_capabilities</code></a> at instance level and <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_external_memory.html"><code>VK_KHR_external_memory</code></a> at device level. We also need to enable specific extensions based on the platform we&#8217;re running on. For Windows that&#8217;s <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_external_memory_win32.html"><code>VK_KHR_external_memory_win32</code></a> and for all Unix based platforms we need to enable <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_external_memory_fd.html"><code>VK_KHR_external_memory_fd</code></a>. The OpenCl equivalents to these extensions are <a href="https://registry.khronos.org/OpenCL/specs/3.0-unified/html/OpenCL_Ext.html#cl_khr_external_memory"><code>cl_khr_external_memory</code></a>, <code>cl_khr_external_memory_win32</code> (Windows) and <code>cl_khr_external_memory_opaque_fd</code> (Unix based platforms).</p>
</div>
<div class="paragraph">
<p>For <strong>sharing the semaphores</strong> used to sync image access between the apis, in <strong>Vulkan</strong> we need to enable <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_external_semaphore_capabilities.html"><code>VK_KHR_external_semaphore_capabilities</code></a> at the instance level and <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_external_semaphore.html"><code>VK_KHR_external_semaphore</code></a> at the device level. The platform specific extension to enable are <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_external_semaphore_win32.html"><code>VK_KHR_external_semaphore_win32</code></a> for Windows and <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_external_semaphore_fd.html"><code>VK_KHR_external_semaphore_fd</code></a> for Unix based platforms. The <strong>OpenCL equivalents</strong> to these are <a href="https://registry.khronos.org/OpenCL/specs/3.0-unified/html/OpenCL_Ext.html#cl_khr_external_semaphore"><code>cl_khr_external_semaphore</code></a>, <code>cl_khr_external_semaphore_win32</code> (Windows) and <code>cl_khr_external_semaphore_opaque_fd</code> (Unix based platforms).</p>
</div>
<div class="paragraph">
<p>We also need to match devices between Vulkan and OpenCL. In Vulkan this functionality is provided e.g. by the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_external_memory_capabilities.html"><code>VK_KHR_external_memory_capabilities</code></a> extension, in OpenCL this requires the <code>cl_khr_device_uuid</code>. More on this later.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_matching_devices"><a class="anchor" href="#_matching_devices"></a>Matching devices</h2>
<div class="sectionbody">
<div class="paragraph">
<p>For the type of external objects we are going to share between Vulkan and OpenCL in this sample, we must make sure that we use the same device in Vulkan and OpenCL. See <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/chap49.html#capabilities-image">this chapter of the spec</a> as to why this is required and to what types of external objects this applies. Esp. on desktop systems you may have multiple Vulkan and/or OpenCL implementations, and they may be reported by both apis in different orders. So just assuming that the first Vulkan device is also the first OpenCL device may not work.</p>
</div>
<div class="paragraph">
<p>For that, both apis expose universally unique (device) identifiers (uuid) that we can use to match the devices between the apis. This is done in the <code>prepare_opencl_resources</code> function. Since this is a Vulkan sample we&#8217;ll try to find the OpenCL device that matches the UUID of our Vulkan sample:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">// Get the UUID of the current Vulkan device
VkPhysicalDeviceIDPropertiesKHR physical_device_id_propreties{};
physical_device_id_propreties.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES;
VkPhysicalDeviceProperties2 physical_device_properties_2{};
physical_device_properties_2.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2_KHR;
physical_device_properties_2.pNext = &amp;physical_device_id_propreties;
vkGetPhysicalDeviceProperties2KHR(device-&gt;get_gpu().get_handle(), &amp;physical_device_properties_2);

// Iterate over all available OpenCL platforms and find the first that fits our requirements (extensions, device UUID)
cl_uint num_platforms;
clGetPlatformIDs_ptr(0, nullptr, &amp;num_platforms);

std::vector&lt;cl_platform_id&gt; platform_ids(num_platforms);
clGetPlatformIDs_ptr(num_platforms, platform_ids.data(), nullptr);

cl_platform_id selected_platform_id{nullptr};
cl_device_id   selected_device_id{nullptr};

// Iterate over all available OpenCL platforms
for (auto &amp;platform_id : platform_ids)
{
	cl_uint        num_devices;
	clGetDeviceIDs_ptr(platform_id, CL_DEVICE_TYPE_ALL, 0, nullptr, &amp;num_devices);
	std::vector&lt;cl_device_id&gt; device_ids(num_devices);
	clGetDeviceIDs_ptr(platform_id, CL_DEVICE_TYPE_ALL, num_devices, device_ids.data(), nullptr);

	...

	// Check every device of this platform and see if it matches our Vulkan device UUID
	selected_device_id = nullptr;
	for (auto &amp;device_id : device_ids)
	{
		cl_uchar uuid[CL_UUID_SIZE_KHR];
		clGetDeviceInfo_ptr(device_id, CL_DEVICE_UUID_KHR, sizeof(uuid), &amp;uuid, nullptr);

		bool device_uuid_match = true;

		for (uint32_t i = 0; i &lt; CL_UUID_SIZE_KHR; i++)
		{
			if (uuid[i] != physical_device_id_propreties.deviceUUID[i])
			{
				device_uuid_match = false;
				break;
			}
		}

		if (!device_uuid_match)
		{
			continue;
		}

		// We found a device with a matching UUID, so use it
		selected_device_id = device_id;
		break;
	}

	...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_a_note_on_windows_security"><a class="anchor" href="#_a_note_on_windows_security"></a>A note on Windows security</h2>
<div class="sectionbody">
<div class="paragraph">
<p>On Windows we need to ensure read and write access to the shared memory for external handles (see <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkExportMemoryWin32HandleInfoKHR.html#_description">spec</a>). This requires setting up security attributes using the Windows API. To simplify this, the sample implements that in the <code>WinSecurityAttributes</code> class. This is then used in all places where we share memory on Windows.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_creating_and_sharing_the_image"><a class="anchor" href="#_creating_and_sharing_the_image"></a>Creating and sharing the image</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The sample will update the contents of an image with OpenCL and displays that on a quad with Vulkan. So we first need to setup that image (and it&#8217;s memory) in Vulkan just as any other image with the appropriate usage flags:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">VkImageCreateInfo image_create_info = vkb::initializers::image_create_info();
image_create_info.imageType         = VK_IMAGE_TYPE_2D;
image_create_info.format            = VK_FORMAT_R8G8B8A8_UNORM;
image_create_info.mipLevels         = 1;
image_create_info.arrayLayers       = 1;
image_create_info.samples           = VK_SAMPLE_COUNT_1_BIT;
image_create_info.tiling            = VK_IMAGE_TILING_OPTIMAL;
image_create_info.extent            = {shared_image.width, shared_image.height, shared_image.depth};
image_create_info.usage             = VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT;</code></pre>
</div>
</div>
<div class="paragraph">
<p>And mark it as external using <code>VkExternalMemoryImageCreateInfo</code> in the <code>pNext</code> chain of the image create info structure , so other apis (in our case OpenCL) will be able to access it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">VkExternalMemoryImageCreateInfo external_memory_image_info{};
external_memory_image_info.sType       = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO;
external_memory_image_info.handleTypes = external_handle_type;

image_create_info.pNext = &amp;external_memory_image_info;
VK_CHECK(vkCreateImage(get_device().get_handle(), &amp;image_create_info, nullptr, &amp;shared_image.image));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Just like the required extensions, the <code>handleTypes</code> are also platform specific. We need to use <code>VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR</code> for Windows and <code>VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHR</code> for Unix based platforms (which also includes Android).</p>
</div>
<div class="paragraph">
<p>We need to do the same with the memory backing up our image, as we also allocate it in the Vulkan part of our sample. We chain a <code>VkExportMemoryAllocateInfoKHR</code> structure into the memory allocation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">VkExportMemoryAllocateInfoKHR export_memory_allocate_info{};
export_memory_allocate_info.sType = VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_KHR;
export_memory_allocate_info.handleTypes = external_handle_type;
#ifdef _WIN32
	export_memory_allocate_info.pNext = &amp;export_memory_win32_handle_info;
#endif

VkMemoryAllocateInfo memory_allocate_info = vkb::initializers::memory_allocate_info();
memory_allocate_info.pNext                = &amp;export_memory_allocate_info;
memory_allocate_info.allocationSize       = memory_requirements.size;
memory_allocate_info.memoryTypeIndex      = device-&gt;get_memory_type(memory_requirements.memoryTypeBits, 0);

VK_CHECK(vkAllocateMemory(device_handle, &amp;memory_allocate_info, nullptr, &amp;shared_image.memory));
VK_CHECK(vkBindImageMemory(device_handle, shared_image.image, shared_image.memory, 0));</code></pre>
</div>
</div>
<div class="paragraph">
<p>As noted earlier, on Windows we need to pass additional process security related information using the <code>VkExportMemoryWin32HandleInfoKHR</code> structure:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">#ifdef _WIN32
	WinSecurityAttributes            win_security_attributes;
	VkExportMemoryWin32HandleInfoKHR export_memory_win32_handle_info{};
	export_memory_win32_handle_info.sType       = VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR;
	export_memory_win32_handle_info.pAttributes = &amp;win_security_attributes;
	export_memory_win32_handle_info.dwAccess    = DXGI_SHARED_RESOURCE_READ | DXGI_SHARED_RESOURCE_WRITE;
	export_memory_allocate_info.pNext           = &amp;export_memory_win32_handle_info;
#endif</code></pre>
</div>
</div>
<div class="paragraph">
<p>Once we created the image along with it&#8217;s memory in Vulkan, we <strong>switch over to OpenCL</strong> where we&#8217;ll import the image. Note that the OpenCL api looks very different from Vulkan. OpenCL e.g. often uses zero terminated property lists instead of explicit structures.</p>
</div>
<div class="paragraph">
<p>For this property list we need to get a shareable handle for the Vulkan memory backing up our image, This is done with the <code>get_vulkan_memory_handle</code> function, which is a light wrapper around the Vulkan functions for getting the platform specific handle (e.g. <code>vkGetMemoryWin32HandleKHR</code> on Windows):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">	std::vector&lt;cl_mem_properties&gt; mem_properties;

#ifdef _WIN32
	HANDLE handle = get_vulkan_memory_handle(shared_image.memory);
	mem_properties.push_back((cl_mem_properties) CL_EXTERNAL_MEMORY_HANDLE_OPAQUE_WIN32_KHR);
	mem_properties.push_back((cl_mem_properties) handle);
#else
	int fd = get_vulkan_memory_handle(shared_image.memory);
	mem_properties.push_back((cl_mem_properties) CL_EXTERNAL_MEMORY_HANDLE_OPAQUE_FD_KHR);
	mem_properties.push_back((cl_mem_properties) fd);
#endif
	mem_properties.push_back((cl_mem_properties) CL_MEM_DEVICE_HANDLE_LIST_KHR);
	mem_properties.push_back((cl_mem_properties) opencl_objects.device_id);
	mem_properties.push_back((cl_mem_properties) CL_MEM_DEVICE_HANDLE_LIST_END_KHR);
	mem_properties.push_back(0);</code></pre>
</div>
</div>
<div class="paragraph">
<p>And then create an OpenCL image using that handle:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">cl_image_format cl_img_fmt{};
cl_img_fmt.image_channel_order     = CL_RGBA;
cl_img_fmt.image_channel_data_type = CL_UNSIGNED_INT8;

cl_image_desc cl_img_desc{};
cl_img_desc.image_width       = shared_image.width;
cl_img_desc.image_height      = shared_image.height;
cl_img_desc.image_type        = CL_MEM_OBJECT_IMAGE2D;
cl_img_desc.image_slice_pitch = cl_img_desc.image_row_pitch * cl_img_desc.image_height;
cl_img_desc.num_mip_levels    = 1;
cl_img_desc.buffer            = nullptr;

int cl_result;
opencl_objects.image = clCreateImageWithProperties(opencl_objects.context,
                                                    mem_properties.data(),
                                                    CL_MEM_READ_WRITE,
                                                    &amp;cl_img_fmt,
                                                    &amp;cl_img_desc,
                                                    NULL,
                                                    &amp;cl_result);
CL_CHECK(cl_result);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The interesting part here is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">cl_img_desc.buffer            = nullptr;</code></pre>
</div>
</div>
<div class="paragraph">
<p>This means that we don&#8217;t allocate a buffer backing the image in OpenCL, but rather import it via the handle specified in the <code>mem_properties</code> property list.</p>
</div>
<div class="paragraph">
<p>After the call to <code>clCreateImageWithProperties</code> we&#8217;re ready to use the image in both apis.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_creating_and_sharing_semaphores"><a class="anchor" href="#_creating_and_sharing_semaphores"></a>Creating and sharing semaphores</h2>
<div class="sectionbody">
<div class="paragraph">
<p>To sync work across Vulkan and OpenCL we&#8217;ll be using semaphores. Once again we create these on the Vulkan side of our sample inside the <code>OpenCLInterop::prepare_sync_objects()</code> function. Sharing them is very similar to sharing any other object like e.g. the image:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">VkExportSemaphoreCreateInfoKHR export_semaphore_create_info{};
export_semaphore_create_info.sType = VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO_KHR;

#ifdef _WIN32
WinSecurityAttributes               win_security_attributes;
VkExportSemaphoreWin32HandleInfoKHR export_semaphore_handle_info{};
export_semaphore_handle_info.sType       = VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR;
export_semaphore_handle_info.pAttributes = &amp;win_security_attributes;
export_semaphore_handle_info.dwAccess    = DXGI_SHARED_RESOURCE_READ | DXGI_SHARED_RESOURCE_WRITE;

export_semaphore_create_info.pNext       = &amp;export_semaphore_handle_info;
export_semaphore_create_info.handleTypes = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT;
#else
export_semaphore_create_info.handleTypes = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT;
#endif

VkSemaphoreCreateInfo semaphore_create_info{};
semaphore_create_info.sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO;
semaphore_create_info.pNext = &amp;export_semaphore_create_info;

VK_CHECK(vkCreateSemaphore(device-&gt;get_handle(), &amp;semaphore_create_info, nullptr, &amp;cl_update_vk_semaphore));
VK_CHECK(vkCreateSemaphore(device-&gt;get_handle(), &amp;semaphore_create_info, nullptr, &amp;vk_update_cl_semaphore));</code></pre>
</div>
</div>
<div class="paragraph">
<p>We once again select the handle type based on the platform we&#8217;re compiling on and if it&#8217;s a Windows system we set the required security access information before creating two semaphores with <code>vkCreateSemaphore</code>.</p>
</div>
<div class="paragraph">
<p>With the Vulkan part done, we again <strong>switch over</strong> to OpenCL, where we&#8217;ll import the Vulkan semaphores. The <code>get_vulkan_semaphore_handle</code> function is a convenient wrapper for getting a platform specific handle to a Vulkan semaphore. It&#8217;ll use <code>vkGetSemaphoreWin32HandleKHR</code> on windows, and <code>vkGetSemaphoreFdKHR</code> on all other platforms:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">std::vector&lt;cl_semaphore_properties_khr&gt; semaphore_properties{
    (cl_semaphore_properties_khr) CL_SEMAPHORE_TYPE_KHR,
    (cl_semaphore_properties_khr) CL_SEMAPHORE_TYPE_BINARY_KHR,
    (cl_semaphore_properties_khr) CL_SEMAPHORE_DEVICE_HANDLE_LIST_KHR,
    (cl_semaphore_properties_khr) opencl_objects.device_id,
    (cl_semaphore_properties_khr) CL_SEMAPHORE_DEVICE_HANDLE_LIST_END_KHR,
};

// CL to VK semaphore

// We need to select the external handle type based on our target platform
#ifdef _WIN32
semaphore_properties.push_back((cl_semaphore_properties_khr) CL_SEMAPHORE_HANDLE_OPAQUE_WIN32_KHR);
HANDLE handle = get_vulkan_semaphore_handle(cl_update_vk_semaphore);
semaphore_properties.push_back((cl_semaphore_properties_khr) handle);
#else
semaphore_properties.push_back((cl_semaphore_properties_khr) CL_SEMAPHORE_HANDLE_OPAQUE_FD_KHR);
int fd = get_vulkan_semaphore_handle(cl_update_vk_semaphore);
semaphore_properties.push_back((cl_semaphore_properties_khr) fd);
#endif
semaphore_properties.push_back(0);

cl_int cl_result;

opencl_objects.cl_update_vk_semaphore = clCreateSemaphoreWithPropertiesKHR(opencl_objects.context, semaphore_properties.data(), &amp;cl_result);
CL_CHECK(cl_result);

// Remove the last two entries so we can push the next handle and zero terminator to the properties list and re-use the other values
semaphore_properties.pop_back();
semaphore_properties.pop_back();

// VK to CL semaphore
// Code is the same, and not repeated here
...</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_sharing_data_between_the_apis"><a class="anchor" href="#_sharing_data_between_the_apis"></a>Sharing data between the apis</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Now that all objects shared between Vulkan and OpenCL have been set up we can actually start sharing the images. Remember that we&#8217;ll be using OpenCL to update the contents of an image that we&#8217;ll then display in our Vulkan sample on a quad. This is done in the <code>OpenCLInterop::render()</code> function.</p>
</div>
<div class="paragraph">
<p>This includes proper synchronization of the image access as well as acquiring and releasing the image between the two apis.</p>
</div>
<div class="paragraph">
<p>First we need to ensure that the command buffer displaying our image has finished. This is done on the Vulkan side using a fence:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">vkWaitForFences(device-&gt;get_handle(), 1, &amp;rendering_finished_fence, VK_TRUE, std::numeric_limits&lt;uint64_t&gt;::max());
vkResetFences(device-&gt;get_handle(), 1, &amp;rendering_finished_fence);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Next up is work submission. As we&#8217;re now submitting work to two different apis we need to make sure that they&#8217;ll properly wait for and signal the semaphores. As noted above we have two semaphores:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>cl_update_vk_semaphore</code> - Is signalled by OpenCL and waited on by Vulkan</p>
</li>
<li>
<p><code>vk_update_cl_semaphore</code> - Is signalled by Vulkan and waited by OpenCL</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Due to how basic semaphores in Vulkan work (we&#8217;re not using timeline semaphores), we don&#8217;t have a way of manually signalling them. So instead we differ between the first and consecutive command buffer submissions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">if (first_submit)
{
	first_submit      = false;
	wait_stages       = {VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT};
	wait_semaphores   = {semaphores.acquired_image_ready};
	signal_semaphores = {semaphores.render_complete, vk_update_cl_semaphore};
}
else
{
	wait_stages       = {VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT, VK_PIPELINE_STAGE_ALL_COMMANDS_BIT};
	wait_semaphores   = {semaphores.acquired_image_ready, cl_update_vk_semaphore};
	signal_semaphores = {semaphores.render_complete, vk_update_cl_semaphore};
}
..
VK_CHECK(vkQueueSubmit(queue, 1, &amp;submit_info, rendering_finished_fence));</code></pre>
</div>
</div>
<div class="paragraph">
<p>The first submission won&#8217;t wait on any OpenCL semaphore (because it&#8217;s not signaled yet), and signals the Vulkan-&gt;OpenCL semaphore. So the OpenCl workload following the Vulkan queue submission will wait on it.</p>
</div>
<div class="paragraph">
<p>On consecutive submits, the OpenCL code workload already has been submitted so we&#8217;ll also wait for the OpenCL-&gt;vulkan semaphore. Additionally we also provide an additional pipeline stage to wait on to match OpenCL&#8217;s workload.</p>
</div>
<div class="paragraph">
<p>Now we move to the OpenCL side of things to update our image with an OpenCL kernel. The concepts here are similar to those in the Vulkan API.</p>
</div>
<div class="paragraph">
<p>We first wait for the Vulkan-&gt;OpenCL semaphore to ensure that the Vulkan side of the graphics queue is done before we start with the OpenCL update part:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">CL_CHECK(clEnqueueWaitSemaphoresKHR(opencl_objects.command_queue, 1, &amp;opencl_objects.vk_update_cl_semaphore, nullptr, 0, nullptr, nullptr));</code></pre>
</div>
</div>
<div class="paragraph">
<p>We then need to acquire the image handle created from our image. In this case, the image is an external memory handle (to OpenCL) as it was created in Vulkan:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">CL_CHECK(clEnqueueAcquireExternalMemObjectsKHR(opencl_objects.command_queue, 1, &amp;opencl_objects.image, 0, nullptr, nullptr));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Once we have successfully acquired the image for use with OpenCL, we can run the kernel to update the image contents. An OpenCL kernel is similar to a Vulkan compute shader. This part of the sample isn&#8217;t specific to api sharing, and just a basic example of how to run an OpenCL kernel on an image:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">std::array&lt;size_t, 2&gt; global_size = {shared_image.width, shared_image.height};
std::array&lt;size_t, 2&gt; local_size  = {16, 16};

CL_CHECK(clSetKernelArg(opencl_objects.kernel, 0, sizeof(cl_mem), &amp;opencl_objects.image));
CL_CHECK(clSetKernelArg(opencl_objects.kernel, 1, sizeof(float), &amp;total_time_passed));
CL_CHECK(clEnqueueNDRangeKernel(opencl_objects.command_queue, opencl_objects.kernel, global_size.size(), nullptr, global_size.data(), local_size.data(), 0, nullptr, nullptr));</code></pre>
</div>
</div>
<div class="paragraph">
<p>After this command we can return ownership of the image back to Vulkan by releasing it on the OpenCL side:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">CL_CHECK(clEnqueueReleaseExternalMemObjectsKHR(opencl_objects.command_queue, 1, &amp;opencl_objects.image, 0, nullptr, nullptr));</code></pre>
</div>
</div>
<div class="paragraph">
<p>After that we signal the OpenCL-&gt;Vulkan semaphore from the OpenCL side, so Vulkan can wait on this for the next frame:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">CL_CHECK(clEnqueueSignalSemaphoresKHR(opencl_objects.command_queue, 1, &amp;opencl_objects.cl_update_vk_semaphore, nullptr, 0, nullptr, nullptr));</code></pre>
</div>
</div>
<div class="paragraph">
<p>On the OpenCL side we&#8217;ll use the <code>cl_update_vk_semaphore</code> semaphore to signal work completion to Vulkan for the next frame (where <code>first_submit</code> is false). This ensures that the Vulkan graphics queue won&#8217;t start accessing the image until OpenCL queue has finished work.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_conclusion"><a class="anchor" href="#_conclusion"></a>Conclusion</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Doing cross api interoperability is a rather niche use case and quite involved, but with both apis offering similar concepts and extensions it&#8217;s not too hard to understand. Sharing other resources like buffers btw. is very similar to how we share images in this sample.</p>
</div>
</div>
</div>
</article>
  </div>
</main>
</div>
<script id="site-script" src="../../../../../_/js/site.js" data-ui-root-path="../../../../../_"></script>
<script async src="../../../../../_/js/vendor/highlight.js"></script>
<script src="../../../../../_/js/vendor/lunr.js"></script>
<script src="../../../../../_/js/search-ui.js" id="search-ui-script" data-site-root-path="../../../../.." data-snippet-length="100" data-stylesheet="../../../../../_/css/search.css"></script>
<script async src="../../../../../search-index.js"></script>
  </body>
</html>

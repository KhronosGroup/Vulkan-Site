<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Staging buffer :: Vulkan Documentation Project</title>
    <meta name="generator" content="Antora 3.1.4">
    <link rel="stylesheet" href="../../../_/css/site.css">
    <link rel="apple-touch-icon" sizes="180x180" href="../../../_/img/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="../../../_/img/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="../../../_/img/favicon-16x16.png">
    <link rel="manifest" href="../../../_/static/site.webmanifest">
    <link rel="mask-icon" href="../../../_/img/safari-pinned-tab.svg" color="#a41e22">
    <meta name="msapplication-TileColor" content="#ffc40d">
    <meta name="theme-color" content="#ffffff">
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="../../.."><img class="navbar-item" alt="Vulkan White Label" src="../../../_/Vulkan_Docs.svg" /></a>
      <div class="navbar-item search hide-for-print">
        <div id="search-field" class="field has-filter">
          <label for="search-input"></label>
          <input id="search-input" type="text" placeholder="Search the docs">
          <label class="filter checkbox">
            <input type="checkbox" data-facet-filter="component:tutorial" checked> In this component
          </label>
        </div>
      </div>
      <button class="navbar-burger" aria-controls="topbar-nav" aria-expanded="false" aria-label="Toggle main menu">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <!-- <a class="navbar-item" href="#">Home</a> -->
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Specs</a>
          <div class="navbar-dropdown is-right">
            <a class="navbar-item" href="../../../spec/latest/chapters/introduction.html">Vulkan API</a>
            <a class="navbar-item" href="https://registry.khronos.org/OpenGL/specs/gl/GLSLangSpec.4.60.html">GLSL</a>
            <a class="navbar-item" href="../../../guide/latest/hlsl.html">HLSL</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Education</a>
          <div class="navbar-dropdown is-right">
            <a class="navbar-item" href="../../../features/latest/features/index.html">Vulkan Feature Descriptions</a>
            <a class="navbar-item" href="../../../guide/latest/index.html">Vulkan Guide</a>
            <a class="navbar-item" href="../../../samples/latest/README.html">Vulkan Samples</a>
            <a class="navbar-item" href="../../../tutorial/latest/index.html">Vulkan Tutorial</a>
            <a class="navbar-item" href="https://www.youtube.com/c/vulkan">YouTube</a>
            <a class="navbar-item" href="https://vulkan.org">More Info at Vulkan.org</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Feedback</a>
          <div class="navbar-dropdown is-right">
            <a class="navbar-item" href="https://github.com/KhronosGroup/Vulkan-Site/issues/new/choose" target="_blank">Report a Problem</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Community</a>
          <div class="navbar-dropdown is-right">
            <a class="navbar-item" href="https://discord.gg/vulkan">Vulkan Discord</a>
            <a class="navbar-item" href="https://reddit.com/r/vulkan">Reddit</a>
            <a class="navbar-item" href="https://stackoverflow.com/questions/tagged/vulkan">Stack Overflow</a>
            <a class="navbar-item" href="https://fosstodon.org/@vulkan">Mastodon</a>
          </div>
        </div>
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="tutorial" data-version="latest">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <button class="nav-menu-toggle" aria-label="Toggle expand/collapse all" style="display: none"></button>
    <h3 class="title"><a href="../00_Introduction.html">Khronos Vulkan Tutorial</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../00_Introduction.html">Introduction</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../01_Overview.html">Overview</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../02_Development_environment.html">Development environment</a>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../03_Drawing_a_triangle/00_Setup/00_Base_code.html">Drawing a triangle</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../03_Drawing_a_triangle/00_Setup/00_Base_code.html">Setup</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../03_Drawing_a_triangle/00_Setup/00_Base_code.html">Base Code</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../03_Drawing_a_triangle/00_Setup/01_Instance.html">Instance</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../03_Drawing_a_triangle/00_Setup/02_Validation_layers.html">Validation layers</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../03_Drawing_a_triangle/00_Setup/03_Physical_devices_and_queue_families.html">Physical devices and queue families</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../03_Drawing_a_triangle/00_Setup/04_Logical_device_and_queues.html">Logical device and queues</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../03_Drawing_a_triangle/01_Presentation/00_Window_surface.html">Presentation</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../03_Drawing_a_triangle/01_Presentation/00_Window_surface.html">Window surface</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../03_Drawing_a_triangle/01_Presentation/01_Swap_chain.html">Swap chain</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../03_Drawing_a_triangle/01_Presentation/02_Image_views.html">Image views</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../03_Drawing_a_triangle/02_Graphics_pipeline_basics/00_Introduction.html">Graphics pipeline basics</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../03_Drawing_a_triangle/02_Graphics_pipeline_basics/00_Introduction.html">Introduction</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../03_Drawing_a_triangle/02_Graphics_pipeline_basics/01_Shader_modules.html">Shader modules</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../03_Drawing_a_triangle/02_Graphics_pipeline_basics/02_Fixed_functions.html">Fixed functions</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../03_Drawing_a_triangle/02_Graphics_pipeline_basics/03_Render_passes.html">Render passes</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../03_Drawing_a_triangle/02_Graphics_pipeline_basics/04_Conclusion.html">Conclusion</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../03_Drawing_a_triangle/03_Drawing/00_Framebuffers.html">Drawing</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../03_Drawing_a_triangle/03_Drawing/00_Framebuffers.html">Framebuffers</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../03_Drawing_a_triangle/03_Drawing/01_Command_buffers.html">Command buffers</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../03_Drawing_a_triangle/03_Drawing/02_Rendering_and_presentation.html">Rendering and presentation</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../03_Drawing_a_triangle/03_Drawing/03_Frames_in_flight.html">Frames in flight</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../03_Drawing_a_triangle/04_Swap_chain_recreation.html">Swap chain recreation</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="00_Vertex_input_description.html">Vertex buffers</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="00_Vertex_input_description.html">Vertex input description</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="01_Vertex_buffer_creation.html">Vertex buffer creation</a>
  </li>
  <li class="nav-item is-current-page" data-depth="2">
    <a class="nav-link" href="02_Staging_buffer.html">Staging buffer</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="03_Index_buffer.html">Index buffer</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../05_Uniform_buffers/00_Descriptor_set_layout_and_buffer.html">Uniform buffers</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../05_Uniform_buffers/00_Descriptor_set_layout_and_buffer.html">Descriptor layout and buffer</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../05_Uniform_buffers/01_Descriptor_pool_and_sets.html">Descriptor pool and sets</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../06_Texture_mapping/00_Images.html">Texture mapping</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../06_Texture_mapping/00_Images.html">Images</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../06_Texture_mapping/01_Image_view_and_sampler.html">Image view and sampler</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../06_Texture_mapping/02_Combined_image_sampler.html">Combined image sampler</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../07_Depth_buffering.html">Depth buffering</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../08_Loading_models.html">Loading models</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../09_Generating_Mipmaps.html">Generating Mipmaps</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../10_Multisampling.html">Multisampling</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../11_Compute_Shader.html">Compute Shader</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../90_FAQ.html">FAQ</a>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Khronos Vulkan Tutorial</span>
    <span class="version">latest</span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <div class="title"><a href="../00_Introduction.html">Khronos Vulkan Tutorial</a></div>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="../00_Introduction.html">latest</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../../features/latest/features/index.html">Vulkan Feature Descriptions</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../features/latest/features/index.html">latest</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../../guide/latest/index.html">Vulkan Guide</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../guide/latest/index.html">latest</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../../samples/latest/README.html">Vulkan Samples</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../samples/latest/README.html">latest</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../../spec/latest/index.html">Vulkan Specification</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../spec/latest/index.html">latest</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../../../spec/latest/index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../00_Introduction.html">Khronos Vulkan Tutorial</a></li>
    <li><a href="00_Vertex_input_description.html">Vertex buffers</a></li>
    <li><a href="02_Staging_buffer.html">Staging buffer</a></li>
  </ul>
</nav>
</div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">Staging buffer</h1>
<div class="sect1">
<h2 id="_introduction"><a class="anchor" href="#_introduction"></a>Introduction</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The vertex buffer we have right now works correctly, but the memory type that allows us to access it from the CPU may not be the most optimal memory type for the graphics card itself to read from.
The most optimal memory has the <code>VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</code> flag and is usually not accessible by the CPU on dedicated graphics cards.
In this chapter we&#8217;re going to create two vertex buffers.
One <em>staging buffer</em> in CPU accessible memory to upload the data from the vertex array to, and the final vertex buffer in device local memory.
We&#8217;ll then use a buffer copy command to move the data from the staging buffer to the actual vertex buffer.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_transfer_queue"><a class="anchor" href="#_transfer_queue"></a>Transfer queue</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The buffer copy command requires a queue family that supports transfer operations, which is indicated using <code>VK_QUEUE_TRANSFER_BIT</code>.
The good news is that any queue family with <code>VK_QUEUE_GRAPHICS_BIT</code> or <code>VK_QUEUE_COMPUTE_BIT</code> capabilities already implicitly support <code>VK_QUEUE_TRANSFER_BIT</code> operations.
The implementation is not required to explicitly list it in <code>queueFlags</code> in those cases.</p>
</div>
<div class="paragraph">
<p>If you like a challenge, then you can still try to use a different queue family specifically for transfer operations.
It will require you to make the following modifications to your program:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Modify <code>QueueFamilyIndices</code> and <code>findQueueFamilies</code> to explicitly look for a queue family with the <code>VK_QUEUE_TRANSFER_BIT</code> bit, but not the <code>VK_QUEUE_GRAPHICS_BIT</code>.</p>
</li>
<li>
<p>Modify <code>createLogicalDevice</code> to request a handle to the transfer queue</p>
</li>
<li>
<p>Create a second command pool for command buffers that are submitted on the transfer queue family</p>
</li>
<li>
<p>Change the <code>sharingMode</code> of resources to be <code>VK_SHARING_MODE_CONCURRENT</code> and specify both the graphics and transfer queue families</p>
</li>
<li>
<p>Submit any transfer commands like <code>vkCmdCopyBuffer</code> (which we&#8217;ll be using in this chapter) to the transfer queue instead of the graphics queue</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>It&#8217;s a bit of work, but it&#8217;ll teach you a lot about how resources are shared between queue families.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_abstracting_buffer_creation"><a class="anchor" href="#_abstracting_buffer_creation"></a>Abstracting buffer creation</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Because we&#8217;re going to create multiple buffers in this chapter, it&#8217;s a good idea to move buffer creation to a helper function.
Create a new function <code>createBuffer</code> and move the code in <code>createVertexBuffer</code> (except mapping) to it.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">void createBuffer(VkDeviceSize size, VkBufferUsageFlags usage, VkMemoryPropertyFlags properties, VkBuffer&amp; buffer, VkDeviceMemory&amp; bufferMemory) {
    VkBufferCreateInfo bufferInfo{};
    bufferInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
    bufferInfo.size = size;
    bufferInfo.usage = usage;
    bufferInfo.sharingMode = VK_SHARING_MODE_EXCLUSIVE;

    if (vkCreateBuffer(device, &amp;bufferInfo, nullptr, &amp;buffer) != VK_SUCCESS) {
        throw std::runtime_error("failed to create buffer!");
    }

    VkMemoryRequirements memRequirements;
    vkGetBufferMemoryRequirements(device, buffer, &amp;memRequirements);

    VkMemoryAllocateInfo allocInfo{};
    allocInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
    allocInfo.allocationSize = memRequirements.size;
    allocInfo.memoryTypeIndex = findMemoryType(memRequirements.memoryTypeBits, properties);

    if (vkAllocateMemory(device, &amp;allocInfo, nullptr, &amp;bufferMemory) != VK_SUCCESS) {
        throw std::runtime_error("failed to allocate buffer memory!");
    }

    vkBindBufferMemory(device, buffer, bufferMemory, 0);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Make sure to add parameters for the buffer size, memory properties and usage so that we can use this function to create many different types of buffers.
The last two parameters are output variables to write the handles to.</p>
</div>
<div class="paragraph">
<p>You can now remove the buffer creation and memory allocation code from <code>createVertexBuffer</code> and just call <code>createBuffer</code> instead:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">void createVertexBuffer() {
    VkDeviceSize bufferSize = sizeof(vertices[0]) * vertices.size();
    createBuffer(bufferSize, VK_BUFFER_USAGE_VERTEX_BUFFER_BIT, VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT, vertexBuffer, vertexBufferMemory);

    void* data;
    vkMapMemory(device, vertexBufferMemory, 0, bufferSize, 0, &amp;data);
        memcpy(data, vertices.data(), (size_t) bufferSize);
    vkUnmapMemory(device, vertexBufferMemory);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Run your program to make sure that the vertex buffer still works properly.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_using_a_staging_buffer"><a class="anchor" href="#_using_a_staging_buffer"></a>Using a staging buffer</h2>
<div class="sectionbody">
<div class="paragraph">
<p>We&#8217;re now going to change <code>createVertexBuffer</code> to only use a host visible buffer as temporary buffer and use a device local one as actual vertex buffer.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">void createVertexBuffer() {
    VkDeviceSize bufferSize = sizeof(vertices[0]) * vertices.size();

    VkBuffer stagingBuffer;
    VkDeviceMemory stagingBufferMemory;
    createBuffer(bufferSize, VK_BUFFER_USAGE_TRANSFER_SRC_BIT, VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT, stagingBuffer, stagingBufferMemory);

    void* data;
    vkMapMemory(device, stagingBufferMemory, 0, bufferSize, 0, &amp;data);
        memcpy(data, vertices.data(), (size_t) bufferSize);
    vkUnmapMemory(device, stagingBufferMemory);

    createBuffer(bufferSize, VK_BUFFER_USAGE_TRANSFER_DST_BIT | VK_BUFFER_USAGE_VERTEX_BUFFER_BIT, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, vertexBuffer, vertexBufferMemory);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We&#8217;re now using a new <code>stagingBuffer</code> with <code>stagingBufferMemory</code> for mapping and copying the vertex data.
In this chapter we&#8217;re going to use two new buffer usage flags:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>VK_BUFFER_USAGE_TRANSFER_SRC_BIT</code>: Buffer can be used as source in a memory transfer operation.</p>
</li>
<li>
<p><code>VK_BUFFER_USAGE_TRANSFER_DST_BIT</code>: Buffer can be used as destination in a memory transfer operation.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <code>vertexBuffer</code> is now allocated from a memory type that is device local, which generally means that we&#8217;re not able to use <code>vkMapMemory</code>.
However, we can copy data from the <code>stagingBuffer</code> to the <code>vertexBuffer</code>.
We have to indicate that we intend to do that by specifying the transfer source flag for the <code>stagingBuffer</code> and the transfer destination flag for the <code>vertexBuffer</code>, along with the vertex buffer usage flag.</p>
</div>
<div class="paragraph">
<p>We&#8217;re now going to write a function to copy the contents from one buffer to another, called <code>copyBuffer</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">void copyBuffer(VkBuffer srcBuffer, VkBuffer dstBuffer, VkDeviceSize size) {

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Memory transfer operations are executed using command buffers, just like drawing commands.
Therefore we must first allocate a temporary command buffer.
You may wish to create a separate command pool for these kinds of short-lived buffers, because the implementation may be able to apply memory allocation optimizations.
You should use the <code>VK_COMMAND_POOL_CREATE_TRANSIENT_BIT</code> flag during command pool generation in that case.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">void copyBuffer(VkBuffer srcBuffer, VkBuffer dstBuffer, VkDeviceSize size) {
    VkCommandBufferAllocateInfo allocInfo{};
    allocInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
    allocInfo.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;
    allocInfo.commandPool = commandPool;
    allocInfo.commandBufferCount = 1;

    VkCommandBuffer commandBuffer;
    vkAllocateCommandBuffers(device, &amp;allocInfo, &amp;commandBuffer);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>And immediately start recording the command buffer:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">VkCommandBufferBeginInfo beginInfo{};
beginInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
beginInfo.flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT;

vkBeginCommandBuffer(commandBuffer, &amp;beginInfo);</code></pre>
</div>
</div>
<div class="paragraph">
<p>We&#8217;re only going to use the command buffer once and wait with returning from the function until the copy operation has finished executing.
It&#8217;s good practice to tell the driver about our intent using <code>VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">VkBufferCopy copyRegion{};
copyRegion.srcOffset = 0; // Optional
copyRegion.dstOffset = 0; // Optional
copyRegion.size = size;
vkCmdCopyBuffer(commandBuffer, srcBuffer, dstBuffer, 1, &amp;copyRegion);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Contents of buffers are transferred using the <code>vkCmdCopyBuffer</code> command.
It takes the source and destination buffers as arguments, and an array of regions to copy.
The regions are defined in <code>VkBufferCopy</code> structs and consist of a source buffer offset, destination buffer offset and size.
It is not possible to specify <code>VK_WHOLE_SIZE</code> here, unlike the <code>vkMapMemory</code> command.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">vkEndCommandBuffer(commandBuffer);</code></pre>
</div>
</div>
<div class="paragraph">
<p>This command buffer only contains the copy command, so we can stop recording right after that.
Now execute the command buffer to complete the transfer:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">VkSubmitInfo submitInfo{};
submitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;
submitInfo.commandBufferCount = 1;
submitInfo.pCommandBuffers = &amp;commandBuffer;

vkQueueSubmit(graphicsQueue, 1, &amp;submitInfo, VK_NULL_HANDLE);
vkQueueWaitIdle(graphicsQueue);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Unlike the draw commands, there are no events we need to wait on this time.
We just want to execute the transfer on the buffers immediately.
There are again two possible ways to wait on this transfer to complete.
We could use a fence and wait with <code>vkWaitForFences</code>, or simply wait for the transfer queue to become idle with <code>vkQueueWaitIdle</code>.
A fence would allow you to schedule multiple transfers simultaneously and wait for all of them complete, instead of executing one at a time.
That may give the driver more opportunities to optimize.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">vkFreeCommandBuffers(device, commandPool, 1, &amp;commandBuffer);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Don&#8217;t forget to clean up the command buffer used for the transfer operation.</p>
</div>
<div class="paragraph">
<p>We can now call <code>copyBuffer</code> from the <code>createVertexBuffer</code> function to move the vertex data to the device local buffer:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">createBuffer(bufferSize, VK_BUFFER_USAGE_TRANSFER_DST_BIT | VK_BUFFER_USAGE_VERTEX_BUFFER_BIT, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, vertexBuffer, vertexBufferMemory);

copyBuffer(stagingBuffer, vertexBuffer, bufferSize);</code></pre>
</div>
</div>
<div class="paragraph">
<p>After copying the data from the staging buffer to the device buffer, we should clean it up:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">    ...

    copyBuffer(stagingBuffer, vertexBuffer, bufferSize);

    vkDestroyBuffer(device, stagingBuffer, nullptr);
    vkFreeMemory(device, stagingBufferMemory, nullptr);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Run your program to verify that you&#8217;re seeing the familiar triangle again.
The improvement may not be visible right now, but its vertex data is now being loaded from high performance memory.
This will matter when we&#8217;re going to start rendering more complex geometry.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_conclusion"><a class="anchor" href="#_conclusion"></a>Conclusion</h2>
<div class="sectionbody">
<div class="paragraph">
<p>It should be noted that in a real world application, you&#8217;re not supposed to actually call <code>vkAllocateMemory</code> for every individual buffer.
The maximum number of simultaneous memory allocations is limited by the <code>maxMemoryAllocationCount</code> physical device limit, which may be as low as <code>4096</code> even on high end hardware like an NVIDIA GTX 1080.
The right way to allocate memory for a large number of objects at the same time is to create a custom allocator that splits up a single allocation among many different objects by using the <code>offset</code> parameters that we&#8217;ve seen in many functions.</p>
</div>
<div class="paragraph">
<p>You can either implement such an allocator yourself, or use the <a href="https://github.com/GPUOpen-LibrariesAndSDKs/VulkanMemoryAllocator">VulkanMemoryAllocator</a> library provided by the GPUOpen initiative.
However, for this tutorial it&#8217;s okay to use a separate allocation for every resource, because we won&#8217;t come close to hitting any of these limits for now.</p>
</div>
<div class="paragraph">
<p>In the <a href="03_Index_buffer.html" class="xref page">next chapter</a> we&#8217;ll learn about index buffers for vertex reuse.</p>
</div>
<div class="paragraph">
<p><a href="../_attachments/20_staging_buffer.cpp">C&#43;&#43; code</a> / <a href="../_attachments/18_shader_vertexbuffer.vert">Vertex shader</a> / <a href="../_attachments/18_shader_vertexbuffer.frag">Fragment shader</a></p>
</div>
</div>
</div>
</article>
  </div>
</main>
</div>
<script id="site-script" src="../../../_/js/site.js" data-ui-root-path="../../../_"></script>
<script async src="../../../_/js/vendor/highlight.js"></script>
<script src="../../../_/js/vendor/lunr.js"></script>
<script src="../../../_/js/search-ui.js" id="search-ui-script" data-site-root-path="../../.." data-snippet-length="100" data-stylesheet="../../../_/css/search.css"></script>
<script async src="../../../search-index.js"></script>
  </body>
</html>

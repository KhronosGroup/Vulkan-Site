<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Vertex buffer creation :: Vulkan Documentation Project</title>
    <meta name="generator" content="Antora 3.1.10">
    <link rel="stylesheet" href="../../../_/css/site.css">
    <script>var uiRootPath = '../../../_'</script>
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="../../..">Vulkan Documentation Project</a>
      <div class="navbar-item">
        <img alt="Vulkan White Label" src="../../../_/Vulkan_White_Dec16.svg" height="100%" />
      </div>
      <div class="navbar-item search hide-for-print">
        <div id="search-field" class="field">
          <label for="search-input"></label><input id="search-input" type="text" placeholder="Search the docs">
        </div>
      </div>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <!-- <a class="navbar-item" href="#">Home</a> -->
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Specs</a>
          <div class="navbar-dropdown is-right">
            <a class="navbar-item" href="../../../spec/latest/chapters/introduction.html">Vulkan 1.3</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Guides</a>
          <div class="navbar-dropdown is-right">
            <a class="navbar-item" href="../../../guide/latest/index.html">Vulkan Guide</a>
          </div>
        </div>
            <!--
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Tools</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">TBD</a>
          </div>
        </div>
            -->
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Tutorial</a>
          <div class="navbar-dropdown is-right">
            <a class="navbar-item" href="../../../tutorial/latest/index.html">Vulkan Tutorial</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Samples</a>
          <div class="navbar-dropdown is-right">
            <a class="navbar-item" href="../../../samples/latest/README.html">Vulkan Samples</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Help</a>
          <div class="navbar-dropdown is-right">
            <a class="navbar-item" href="https://discord.gg/vulkan">Vulkan Discord</a>
            <a class="navbar-item" href="https://khr.io/khrdiscord">Khronos Discord</a>
          </div>
        </div>
            <!--
        <div class="navbar-item">
          <span class="control">
            <a class="button is-primary" href="#">Download</a>
          </span>
        </div>
            -->
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="tutorial" data-version="latest">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="../00_Introduction.html">Khronos Vulkan Tutorial</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../00_Introduction.html">Introduction</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../01_Overview.html">Overview</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../02_Development_environment.html">Development environment</a>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../03_Drawing_a_triangle/00_Setup/00_Base_code.html">Drawing a triangle</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../03_Drawing_a_triangle/00_Setup/00_Base_code.html">Setup</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../03_Drawing_a_triangle/00_Setup/00_Base_code.html">Base Code</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../03_Drawing_a_triangle/00_Setup/01_Instance.html">Instance</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../03_Drawing_a_triangle/00_Setup/02_Validation_layers.html">Validation layers</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../03_Drawing_a_triangle/00_Setup/03_Physical_devices_and_queue_families.html">Physical devices and queue families</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../03_Drawing_a_triangle/00_Setup/04_Logical_device_and_queues.html">Logical device and queues</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../03_Drawing_a_triangle/01_Presentation/00_Window_surface.html">Presentation</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../03_Drawing_a_triangle/01_Presentation/00_Window_surface.html">Window surface</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../03_Drawing_a_triangle/01_Presentation/01_Swap_chain.html">Swap chain</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../03_Drawing_a_triangle/01_Presentation/02_Image_views.html">Image views</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../03_Drawing_a_triangle/02_Graphics_pipeline_basics/00_Introduction.html">Graphics pipeline basics</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../03_Drawing_a_triangle/02_Graphics_pipeline_basics/00_Introduction.html">Introduction</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../03_Drawing_a_triangle/02_Graphics_pipeline_basics/01_Shader_modules.html">Shader modules</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../03_Drawing_a_triangle/02_Graphics_pipeline_basics/02_Fixed_functions.html">Fixed functions</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../03_Drawing_a_triangle/02_Graphics_pipeline_basics/03_Render_passes.html">Render passes</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../03_Drawing_a_triangle/02_Graphics_pipeline_basics/04_Conclusion.html">Conclusion</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../03_Drawing_a_triangle/03_Drawing/00_Framebuffers.html">Drawing</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../03_Drawing_a_triangle/03_Drawing/00_Framebuffers.html">Framebuffers</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../03_Drawing_a_triangle/03_Drawing/01_Command_buffers.html">Command buffers</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../03_Drawing_a_triangle/03_Drawing/02_Rendering_and_presentation.html">Rendering and presentation</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../03_Drawing_a_triangle/03_Drawing/03_Frames_in_flight.html">Frames in flight</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../03_Drawing_a_triangle/04_Swap_chain_recreation.html">Swap chain recreation</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="00_Vertex_input_description.html">Vertex buffers</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="00_Vertex_input_description.html">Vertex input description</a>
  </li>
  <li class="nav-item is-current-page" data-depth="2">
    <a class="nav-link" href="01_Vertex_buffer_creation.html">Vertex buffer creation</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="02_Staging_buffer.html">Staging buffer</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="03_Index_buffer.html">Index buffer</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../05_Uniform_buffers/00_Descriptor_set_layout_and_buffer.html">Uniform buffers</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../05_Uniform_buffers/00_Descriptor_set_layout_and_buffer.html">Descriptor layout and buffer</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../05_Uniform_buffers/01_Descriptor_pool_and_sets.html">Descriptor pool and sets</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../06_Texture_mapping/00_Images.html">Texture mapping</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../06_Texture_mapping/00_Images.html">Images</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../06_Texture_mapping/01_Image_view_and_sampler.html">Image view and sampler</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../06_Texture_mapping/02_Combined_image_sampler.html">Combined image sampler</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../07_Depth_buffering.html">Depth buffering</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../08_Loading_models.html">Loading models</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../09_Generating_Mipmaps.html">Generating Mipmaps</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../10_Multisampling.html">Multisampling</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../11_Compute_Shader.html">Compute Shader</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../90_FAQ.html">FAQ</a>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Khronos Vulkan Tutorial</span>
    <span class="version">latest</span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <a class="title" href="../00_Introduction.html">Khronos Vulkan Tutorial</a>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="../00_Introduction.html">latest</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <a class="title" href="../../../glsl/latest/index.html">OpenGL Shading Language Specification</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../glsl/latest/index.html">latest</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <a class="title" href="../../../features/latest/features/index.html">Vulkan Feature Descriptions</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../features/latest/features/index.html">latest</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <a class="title" href="../../../guide/latest/index.html">Vulkan Guide</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../guide/latest/index.html">latest</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <a class="title" href="../../../samples/latest/README.html">Vulkan Samples</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../samples/latest/README.html">latest</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <a class="title" href="../../../spec/latest/index.html">Vulkan Specification</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../spec/latest/index.html">latest</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../../../spec/latest/index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../00_Introduction.html">Khronos Vulkan Tutorial</a></li>
    <li><a href="00_Vertex_input_description.html">Vertex buffers</a></li>
    <li><a href="01_Vertex_buffer_creation.html">Vertex buffer creation</a></li>
  </ul>
</nav>
    <!--
    -->
</div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">Vertex buffer creation</h1>
<div class="sect1">
<h2 id="_introduction"><a class="anchor" href="#_introduction"></a>Introduction</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Buffers in Vulkan are regions of memory used for storing arbitrary data that can be read by the graphics card.
They can be used to store vertex data, which we&#8217;ll do in this chapter, but they can also be used for many other purposes that we&#8217;ll explore in future chapters.
Unlike the Vulkan objects we&#8217;ve been dealing with so far, buffers do not automatically allocate memory for themselves.
The work from the previous chapters has shown that the Vulkan API puts the programmer in control of almost everything and memory management is one of those things.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_buffer_creation"><a class="anchor" href="#_buffer_creation"></a>Buffer creation</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Create a new function <code>createVertexBuffer</code> and call it from <code>initVulkan</code> right before <code>createCommandBuffers</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">void initVulkan() {
    createInstance();
    setupDebugMessenger();
    createSurface();
    pickPhysicalDevice();
    createLogicalDevice();
    createSwapChain();
    createImageViews();
    createRenderPass();
    createGraphicsPipeline();
    createFramebuffers();
    createCommandPool();
    createVertexBuffer();
    createCommandBuffers();
    createSyncObjects();
}

...

void createVertexBuffer() {

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Creating a buffer requires us to fill a <code>VkBufferCreateInfo</code> structure.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">VkBufferCreateInfo bufferInfo{};
bufferInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
bufferInfo.size = sizeof(vertices[0]) * vertices.size();</code></pre>
</div>
</div>
<div class="paragraph">
<p>The first field of the struct is <code>size</code>, which specifies the size of the buffer in bytes.
Calculating the byte size of the vertex data is straightforward with <code>sizeof</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">bufferInfo.usage = VK_BUFFER_USAGE_VERTEX_BUFFER_BIT;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The second field is <code>usage</code>, which indicates for which purposes the data in the buffer is going to be used.
It is possible to specify multiple purposes using a bitwise or.
Our use case will be a vertex buffer, we&#8217;ll look at other types of usage in future chapters.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">bufferInfo.sharingMode = VK_SHARING_MODE_EXCLUSIVE;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Just like the images in the swap chain, buffers can also be owned by a specific queue family or be shared between multiple at the same time.
The buffer will only be used from the graphics queue, so we can stick to exclusive access.</p>
</div>
<div class="paragraph">
<p>The <code>flags</code> parameter is used to configure sparse buffer memory, which is not relevant right now.
We&#8217;ll leave it at the default value of <code>0</code>.</p>
</div>
<div class="paragraph">
<p>We can now create the buffer with <code>vkCreateBuffer</code>.
Define a class member to hold the buffer handle and call it <code>vertexBuffer</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">VkBuffer vertexBuffer;

...

void createVertexBuffer() {
    VkBufferCreateInfo bufferInfo{};
    bufferInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
    bufferInfo.size = sizeof(vertices[0]) * vertices.size();
    bufferInfo.usage = VK_BUFFER_USAGE_VERTEX_BUFFER_BIT;
    bufferInfo.sharingMode = VK_SHARING_MODE_EXCLUSIVE;

    if (vkCreateBuffer(device, &amp;bufferInfo, nullptr, &amp;vertexBuffer) != VK_SUCCESS) {
        throw std::runtime_error("failed to create vertex buffer!");
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The buffer should be available for use in rendering commands until the end of the program and it does not depend on the swap chain, so we&#8217;ll clean it up in the original <code>cleanup</code> function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">void cleanup() {
    cleanupSwapChain();

    vkDestroyBuffer(device, vertexBuffer, nullptr);

    ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_memory_requirements"><a class="anchor" href="#_memory_requirements"></a>Memory requirements</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The buffer has been created, but it doesn&#8217;t actually have any memory assigned to it yet.
The first step of allocating memory for the buffer is to query its memory requirements using the aptly named <code>vkGetBufferMemoryRequirements</code> function.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">VkMemoryRequirements memRequirements;
vkGetBufferMemoryRequirements(device, vertexBuffer, &amp;memRequirements);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>VkMemoryRequirements</code> struct has three fields:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>size</code>: The size of the required amount of memory in bytes, may differ from <code>bufferInfo.size</code>.</p>
</li>
<li>
<p><code>alignment</code>: The offset in bytes where the buffer begins in the allocated region of memory, depends on <code>bufferInfo.usage</code> and <code>bufferInfo.flags</code>.</p>
</li>
<li>
<p><code>memoryTypeBits</code>: Bit field of the memory types that are suitable for the buffer.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Graphics cards can offer different types of memory to allocate from.
Each type of memory varies in terms of allowed operations and performance characteristics.
We need to combine the requirements of the buffer and our own application requirements to find the right type of memory to use.
Let&#8217;s create a new function <code>findMemoryType</code> for this purpose.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">uint32_t findMemoryType(uint32_t typeFilter, VkMemoryPropertyFlags properties) {

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>First we need to query info about the available types of memory using <code>vkGetPhysicalDeviceMemoryProperties</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">VkPhysicalDeviceMemoryProperties memProperties;
vkGetPhysicalDeviceMemoryProperties(physicalDevice, &amp;memProperties);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>VkPhysicalDeviceMemoryProperties</code> structure has two arrays <code>memoryTypes</code> and <code>memoryHeaps</code>.
Memory heaps are distinct memory resources like dedicated VRAM and swap space in RAM for when VRAM runs out.
The different types of memory exist within these heaps.
Right now we&#8217;ll only concern ourselves with the type of memory and not the heap it comes from, but you can imagine that this can affect performance.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s first find a memory type that is suitable for the buffer itself:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">for (uint32_t i = 0; i &lt; memProperties.memoryTypeCount; i++) {
    if (typeFilter &amp; (1 &lt;&lt; i)) {
        return i;
    }
}

throw std::runtime_error("failed to find suitable memory type!");</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>typeFilter</code> parameter will be used to specify the bit field of memory types that are suitable.
That means that we can find the index of a suitable memory type by simply iterating over them and checking if the corresponding bit is set to <code>1</code>.</p>
</div>
<div class="paragraph">
<p>However, we&#8217;re not just interested in a memory type that is suitable for the vertex buffer.
We also need to be able to write our vertex data to that memory.
The <code>memoryTypes</code> array consists of <code>VkMemoryType</code> structs that specify the heap and properties of each type of memory.
The properties define special features of the memory, like being able to map it so we can write to it from the CPU.
This property is indicated with <code>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</code>, but we also need to use the <code>VK_MEMORY_PROPERTY_HOST_COHERENT_BIT</code> property.
We&#8217;ll see why when we map the memory.</p>
</div>
<div class="paragraph">
<p>We can now modify the loop to also check for the support of this property:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">for (uint32_t i = 0; i &lt; memProperties.memoryTypeCount; i++) {
    if ((typeFilter &amp; (1 &lt;&lt; i)) &amp;&amp; (memProperties.memoryTypes[i].propertyFlags &amp; properties) == properties) {
        return i;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We may have more than one desirable property, so we should check if the result of the bitwise AND is not just non-zero, but equal to the desired properties bit field.
If there is a memory type suitable for the buffer that also has all of the properties we need, then we return its index, otherwise we throw an exception.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_memory_allocation"><a class="anchor" href="#_memory_allocation"></a>Memory allocation</h2>
<div class="sectionbody">
<div class="paragraph">
<p>We now have a way to determine the right memory type, so we can actually allocate the memory by filling in the <code>VkMemoryAllocateInfo</code> structure.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">VkMemoryAllocateInfo allocInfo{};
allocInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
allocInfo.allocationSize = memRequirements.size;
allocInfo.memoryTypeIndex = findMemoryType(memRequirements.memoryTypeBits, VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Memory allocation is now as simple as specifying the size and type, both of which are derived from the memory requirements of the vertex buffer and the desired property.
Create a class member to store the handle to the memory and allocate it with <code>vkAllocateMemory</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">VkBuffer vertexBuffer;
VkDeviceMemory vertexBufferMemory;

...

if (vkAllocateMemory(device, &amp;allocInfo, nullptr, &amp;vertexBufferMemory) != VK_SUCCESS) {
    throw std::runtime_error("failed to allocate vertex buffer memory!");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If memory allocation was successful, then we can now associate this memory with the buffer using <code>vkBindBufferMemory</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">vkBindBufferMemory(device, vertexBuffer, vertexBufferMemory, 0);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The first three parameters are self-explanatory and the fourth parameter is the offset within the region of memory.
Since this memory is allocated specifically for this the vertex buffer, the offset is simply <code>0</code>.
If the offset is non-zero, then it is required to be divisible by <code>memRequirements.alignment</code>.</p>
</div>
<div class="paragraph">
<p>Of course, just like dynamic memory allocation in C&#43;&#43;, the memory should be freed at some point.
Memory that is bound to a buffer object may be freed once the buffer is no longer used, so let&#8217;s free it after the buffer has been destroyed:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">void cleanup() {
    cleanupSwapChain();

    vkDestroyBuffer(device, vertexBuffer, nullptr);
    vkFreeMemory(device, vertexBufferMemory, nullptr);</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_filling_the_vertex_buffer"><a class="anchor" href="#_filling_the_vertex_buffer"></a>Filling the vertex buffer</h2>
<div class="sectionbody">
<div class="paragraph">
<p>It is now time to copy the vertex data to the buffer.
This is done by <a href="https://en.wikipedia.org/wiki/Memory-mapped_I/O">mapping the buffer memory</a> into CPU accessible memory with <code>vkMapMemory</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">void* data;
vkMapMemory(device, vertexBufferMemory, 0, bufferInfo.size, 0, &amp;data);</code></pre>
</div>
</div>
<div class="paragraph">
<p>This function allows us to access a region of the specified memory resource defined by an offset and size.
The offset and size here are <code>0</code> and <code>bufferInfo.size</code>, respectively.
It is also possible to specify the special value <code>VK_WHOLE_SIZE</code> to map all of the memory.
The second to last parameter can be used to specify flags, but there aren&#8217;t any available yet in the current API.
It must be set to the value <code>0</code>.
The last parameter specifies the output for the pointer to the mapped memory.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">void* data;
vkMapMemory(device, vertexBufferMemory, 0, bufferInfo.size, 0, &amp;data);
    memcpy(data, vertices.data(), (size_t) bufferInfo.size);
vkUnmapMemory(device, vertexBufferMemory);</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can now simply <code>memcpy</code> the vertex data to the mapped memory and unmap it again using <code>vkUnmapMemory</code>.
Unfortunately the driver may not immediately copy the data into the buffer memory, for example because of caching.
It is also possible that writes to the buffer are not visible in the mapped memory yet.
There are two ways to deal with that problem:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Use a memory heap that is host coherent, indicated with <code>VK_MEMORY_PROPERTY_HOST_COHERENT_BIT</code></p>
</li>
<li>
<p>Call <code>vkFlushMappedMemoryRanges</code> after writing to the mapped memory, and call <code>vkInvalidateMappedMemoryRanges</code> before reading from the mapped memory</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>We went for the first approach, which ensures that the mapped memory always matches the contents of the allocated memory.
Do keep in mind that this may lead to slightly worse performance than explicit flushing, but we&#8217;ll see why that doesn&#8217;t matter in the next chapter.</p>
</div>
<div class="paragraph">
<p>Flushing memory ranges or using a coherent memory heap means that the driver will be aware of our writes to the buffer, but it doesn&#8217;t mean that they are actually visible on the GPU yet.
The transfer of data to the GPU is an operation that happens in the background and the specification simply <a href="https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/chap7.html#synchronization-submission-host-writes">tells us</a> that it is guaranteed to be complete as of the next call to <code>vkQueueSubmit</code>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_binding_the_vertex_buffer"><a class="anchor" href="#_binding_the_vertex_buffer"></a>Binding the vertex buffer</h2>
<div class="sectionbody">
<div class="paragraph">
<p>All that remains now is binding the vertex buffer during rendering operations.
We&#8217;re going to extend the <code>recordCommandBuffer</code> function to do that.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">vkCmdBindPipeline(commandBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS, graphicsPipeline);

VkBuffer vertexBuffers[] = {vertexBuffer};
VkDeviceSize offsets[] = {0};
vkCmdBindVertexBuffers(commandBuffer, 0, 1, vertexBuffers, offsets);

vkCmdDraw(commandBuffer, static_cast&lt;uint32_t&gt;(vertices.size()), 1, 0, 0);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>vkCmdBindVertexBuffers</code> function is used to bind vertex buffers to bindings, like the one we set up in the previous chapter.
The first two parameters, besides the command buffer, specify the offset and number of bindings we&#8217;re going to specify vertex buffers for.
The last two parameters specify the array of vertex buffers to bind and the byte offsets to start reading vertex data from.
You should also change the call to <code>vkCmdDraw</code> to pass the number of vertices in the buffer as opposed to the hardcoded number <code>3</code>.</p>
</div>
<div class="paragraph">
<p>Now run the program and you should see the familiar triangle again:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../_images/images/triangle.png" alt="triangle">
</div>
</div>
<div class="paragraph">
<p>Try changing the color of the top vertex to white by modifying the <code>vertices</code> array:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">const std::vector&lt;Vertex&gt; vertices = {
    {{0.0f, -0.5f}, {1.0f, 1.0f, 1.0f}},
    {{0.5f, 0.5f}, {0.0f, 1.0f, 0.0f}},
    {{-0.5f, 0.5f}, {0.0f, 0.0f, 1.0f}}
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>Run the program again and you should see the following:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../_images/images/triangle_white.png" alt="triangle white">
</div>
</div>
<div class="paragraph">
<p>In the <a href="02_Staging_buffer.html" class="xref page">next chapter</a> we&#8217;ll look at a different way to copy vertex data to a vertex buffer that results in better performance, but takes some more work.</p>
</div>
<div class="paragraph">
<p><a href="../_attachments/19_vertex_buffer.cpp">C&#43;&#43; code</a> / <a href="../_attachments/18_shader_vertexbuffer.vert">Vertex shader</a> / <a href="../_attachments/18_shader_vertexbuffer.frag">Fragment shader</a></p>
</div>
</div>
</div>
</article>
  </div>
</main>
</div>
<footer class="footer">
    <!--
  <p>This page was built using the Antora default UI.</p>
  <p>The source code for this UI is licensed under the terms of the MPL-2.0 license.</p>
    -->
</footer>
<script id="site-script" src="../../../_/js/site.js" data-ui-root-path="../../../_"></script>
<script async src="../../../_/js/vendor/highlight.js"></script>
<script src="../../../_/js/vendor/lunr.js"></script>
<script src="https://cdn.jsdelivr.net/pako/1.0.3/pako.min.js"></script>
<script src="../../../_/js/search-ui.js" id="search-ui-script" data-site-root-path="../../.." data-snippet-length="100" data-stylesheet="../../../_/css/search.css"></script>
<script async src="../../../search-index.js"></script>
  </body>
</html>

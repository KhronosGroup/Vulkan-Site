<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Untitled :: Vulkan Documentation Project</title>
    <meta name="generator" content="Antora 3.1.4">
    <link rel="stylesheet" href="../../_/css/site.css">
    <link rel="apple-touch-icon" sizes="180x180" href="../../_/img/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="../../_/img/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="../../_/img/favicon-16x16.png">
    <link rel="manifest" href="../../_/static/site.webmanifest">
    <link rel="mask-icon" href="../../_/img/safari-pinned-tab.svg" color="#a41e22">
    <meta name="msapplication-TileColor" content="#ffc40d">
    <meta name="theme-color" content="#ffffff">
    <script>var uiRootPath = '../../_'</script>
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="../.."><img class="navbar-item" alt="Vulkan White Label" src="../../_/Vulkan_Docs.svg" /></a>
      <div class="navbar-item search hide-for-print">
        <div id="search-field" class="field">
          <label for="search-input"></label><input id="search-input" type="text" placeholder="Search the docs">
        </div>
      </div>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <!-- <a class="navbar-item" href="#">Home</a> -->
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Specs</a>
          <div class="navbar-dropdown is-right">
            <a class="navbar-item" href="../../spec/latest/chapters/introduction.html">Vulkan 1.3</a>
            <a class="navbar-item" href="https://registry.khronos.org/OpenGL/specs/gl/GLSLangSpec.4.60.html">GLSL</a>
            <a class="navbar-item" href="../../guide/latest/hlsl.html">HLSL</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Education</a>
          <div class="navbar-dropdown is-right">
            <a class="navbar-item" href="../../guide/latest/index.html">Vulkan Guide</a>
            <a class="navbar-item" href="../../tutorial/latest/index.html">Vulkan Tutorial</a>
            <a class="navbar-item" href="../../samples/latest/README.html">Vulkan Samples</a>
            <a class="navbar-item" href="https://www.youtube.com/c/vulkan">YouTube</a>
            <a class="navbar-item" href="https://vulkan.org">More Info at Vulkan.org</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Community</a>
          <div class="navbar-dropdown is-right">
            <a class="navbar-item" href="https://discord.gg/vulkan">Vulkan Discord</a>
            <a class="navbar-item" href="https://reddit.com/r/vulkan">Reddit</a>
            <a class="navbar-item" href="https://stackoverflow.com/questions/tagged/vulkan">Stack Overflow</a>
            <a class="navbar-item" href="https://fosstodon.org/@vulkan">Mastodon</a>
          </div>
        </div>
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="tutorial" data-version="latest">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="00_Introduction.html">Khronos Vulkan Tutorial</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="00_Introduction.html">Introduction</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="01_Overview.html">Overview</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="02_Development_environment.html">Development environment</a>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="03_Drawing_a_triangle/00_Setup/00_Base_code.html">Drawing a triangle</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="03_Drawing_a_triangle/00_Setup/00_Base_code.html">Setup</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="03_Drawing_a_triangle/00_Setup/00_Base_code.html">Base Code</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="03_Drawing_a_triangle/00_Setup/01_Instance.html">Instance</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="03_Drawing_a_triangle/00_Setup/02_Validation_layers.html">Validation layers</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="03_Drawing_a_triangle/00_Setup/03_Physical_devices_and_queue_families.html">Physical devices and queue families</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="03_Drawing_a_triangle/00_Setup/04_Logical_device_and_queues.html">Logical device and queues</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="03_Drawing_a_triangle/01_Presentation/00_Window_surface.html">Presentation</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="03_Drawing_a_triangle/01_Presentation/00_Window_surface.html">Window surface</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="03_Drawing_a_triangle/01_Presentation/01_Swap_chain.html">Swap chain</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="03_Drawing_a_triangle/01_Presentation/02_Image_views.html">Image views</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="03_Drawing_a_triangle/02_Graphics_pipeline_basics/00_Introduction.html">Graphics pipeline basics</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="03_Drawing_a_triangle/02_Graphics_pipeline_basics/00_Introduction.html">Introduction</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="03_Drawing_a_triangle/02_Graphics_pipeline_basics/01_Shader_modules.html">Shader modules</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="03_Drawing_a_triangle/02_Graphics_pipeline_basics/02_Fixed_functions.html">Fixed functions</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="03_Drawing_a_triangle/02_Graphics_pipeline_basics/03_Render_passes.html">Render passes</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="03_Drawing_a_triangle/02_Graphics_pipeline_basics/04_Conclusion.html">Conclusion</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="03_Drawing_a_triangle/03_Drawing/00_Framebuffers.html">Drawing</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="03_Drawing_a_triangle/03_Drawing/00_Framebuffers.html">Framebuffers</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="03_Drawing_a_triangle/03_Drawing/01_Command_buffers.html">Command buffers</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="03_Drawing_a_triangle/03_Drawing/02_Rendering_and_presentation.html">Rendering and presentation</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="03_Drawing_a_triangle/03_Drawing/03_Frames_in_flight.html">Frames in flight</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="03_Drawing_a_triangle/04_Swap_chain_recreation.html">Swap chain recreation</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="04_Vertex_buffers/00_Vertex_input_description.html">Vertex buffers</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="04_Vertex_buffers/00_Vertex_input_description.html">Vertex input description</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="04_Vertex_buffers/01_Vertex_buffer_creation.html">Vertex buffer creation</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="04_Vertex_buffers/02_Staging_buffer.html">Staging buffer</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="04_Vertex_buffers/03_Index_buffer.html">Index buffer</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="05_Uniform_buffers/00_Descriptor_set_layout_and_buffer.html">Uniform buffers</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="05_Uniform_buffers/00_Descriptor_set_layout_and_buffer.html">Descriptor layout and buffer</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="05_Uniform_buffers/01_Descriptor_pool_and_sets.html">Descriptor pool and sets</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="06_Texture_mapping/00_Images.html">Texture mapping</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="06_Texture_mapping/00_Images.html">Images</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="06_Texture_mapping/01_Image_view_and_sampler.html">Image view and sampler</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="06_Texture_mapping/02_Combined_image_sampler.html">Combined image sampler</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="07_Depth_buffering.html">Depth buffering</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="08_Loading_models.html">Loading models</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="09_Generating_Mipmaps.html">Generating Mipmaps</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="10_Multisampling.html">Multisampling</a>
  </li>
  <li class="nav-item is-current-page" data-depth="1">
    <a class="nav-link" href="11_Compute_Shader.html">Compute Shader</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="90_FAQ.html">FAQ</a>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Khronos Vulkan Tutorial</span>
    <span class="version">latest</span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <a class="title" href="00_Introduction.html">Khronos Vulkan Tutorial</a>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="00_Introduction.html">latest</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <a class="title" href="../../guide/latest/index.html">Vulkan Guide</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../guide/latest/index.html">latest</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <a class="title" href="../../samples/latest/README.html">Vulkan Samples</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../samples/latest/README.html">latest</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <a class="title" href="../../spec/latest/index.html">Vulkan Specification and Proposals</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../spec/latest/index.html">latest</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../../spec/latest/index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="00_Introduction.html">Khronos Vulkan Tutorial</a></li>
    <li><a href="11_Compute_Shader.html">Compute Shader</a></li>
  </ul>
</nav>
    <!--
  <div class="edit-this-page"><a href="https://github.com/KhronosGroup/Vulkan-Tutorial/edit/main/antora/modules/ROOT/pages/11_Compute_Shader.adoc">Edit this Page</a></div>
      -->
</div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<div class="sect1">
<h2 id="_introduction"><a class="anchor" href="#_introduction"></a>Introduction</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In this bonus chapter we&#8217;ll take a look at compute shaders.
Up until now all previous chapters dealt with the traditional graphics part of the Vulkan pipeline.
But unlike older APIs like OpenGL, compute shader support in Vulkan is mandatory.
This means that you can use compute shaders on every Vulkan implementation available, no matter if it&#8217;s a high-end desktop GPU or a low-powered embedded device.</p>
</div>
<div class="paragraph">
<p>This opens up the world of general purpose computing on graphics processor units (GPGPU), no matter where your application is running.
GPGPU means that you can do general computations on your GPU, something that has traditionally been a domain of CPUs.
But with GPUs having become more and more powerful and more flexible, many workloads that would require the general purpose capabilities of a CPU can now be done on the GPU in realtime.</p>
</div>
<div class="paragraph">
<p>A few examples of where the compute capabilities of a GPU can be used are image manipulation, visibility testing, post processing, advanced lighting calculations, animations, physics (e.g.
for a particle system) and much more.
And it&#8217;s even possible to use compute for non-visual computational only work that does not require any graphics output, e.g.
number crunching or AI related things.
This is called "headless compute".</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_advantages"><a class="anchor" href="#_advantages"></a>Advantages</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Doing computationally expensive calculations on the GPU has several advantages.
The most obvious one is offloading work from the CPU.
Another one is not requiring moving data between the CPU&#8217;s main memory and the GPU&#8217;s memory.
All of the data can stay on the GPU without having to wait for slow transfers from main memory.</p>
</div>
<div class="paragraph">
<p>Aside from these, GPUs are heavily parallelized with some of them having tens of thousands of small compute units.
This often makes them a better fit for highly parallel workflows than a CPU with a few large compute units.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_the_vulkan_pipeline"><a class="anchor" href="#_the_vulkan_pipeline"></a>The Vulkan pipeline</h2>
<div class="sectionbody">
<div class="paragraph">
<p>It&#8217;s important to know that compute is completely separated from the graphics part of the pipeline.
This is visible in the following block diagram of the Vulkan pipeline from the official specification:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/images/vulkan_pipeline_block_diagram.png" alt="vulkan pipeline block diagram">
</div>
</div>
<div class="paragraph">
<p>In this diagram we can see the traditional graphics part of the pipeline on the left, and several stages on the right that are not part of this graphics pipeline, including the compute shader (stage).
With the compute shader stage being detached from the graphics pipeline we&#8217;ll be able to use it anywhere we see fit.
This is very different from e.g.
the fragment shader which is always applied to the transformed output of the vertex shader.</p>
</div>
<div class="paragraph">
<p>The center of the diagram also shows that e.g.
descriptor sets are also used by compute, so everything we learned about descriptors layouts, descriptor sets and descriptors also applies here.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_an_example"><a class="anchor" href="#_an_example"></a>An example</h2>
<div class="sectionbody">
<div class="paragraph">
<p>An easy to understand example that we will implement in this chapter is a GPU based particle system.
Such systems are used in many games and often consist of thousands of particles that need to be updated at interactive frame rates.
Rendering such a system requires 2 main components: vertices, passed as vertex buffers, and a way to update them based on some equation.</p>
</div>
<div class="paragraph">
<p>The "classical" CPU based particle system would store particle data in the system&#8217;s main memory and then use the CPU to update them.
After the update, the vertices need to be transferred to the GPU&#8217;s memory again so it can display the updated particles in the next frame.
The most straight-forward way would be recreating the vertex buffer with the new data for each frame.
This is obviously very costly.
Depending on your implementation, there are other options like mapping GPU memory so it can be written by the CPU (called "resizable BAR" on desktop systems, or unified memory on integrated GPUs) or just using a host local buffer (which would be the slowest method due to PCI-E bandwidth).
But no matter what buffer update method you choose, you always require a "round-trip" to the CPU to update the particles.</p>
</div>
<div class="paragraph">
<p>With a GPU based particle system, this round-trip is no longer required.
Vertices are only uploaded to the GPU at the start and all updates are done in the GPU&#8217;s memory using compute shaders.
One of the main reasons why this is faster is the much higher bandwidth between the GPU and it&#8217;s local memory.
In a CPU based scenario, you&#8217;d be limited by main memory and PCI-express bandwidth, which is often just a fraction of the GPU&#8217;s memory bandwidth.</p>
</div>
<div class="paragraph">
<p>When doing this on a GPU with a dedicated compute queue, you can update particles in parallel to the rendering part of the graphics pipeline.
This is called "async compute", and is an advanced topic not covered in this tutorial.</p>
</div>
<div class="paragraph">
<p>Here is a screenshot from this chapter&#8217;s code.
The particles shown here are updated by a compute shader directly on the GPU, without any CPU interaction:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/images/compute_shader_particles.png" alt="compute shader particles">
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_data_manipulation"><a class="anchor" href="#_data_manipulation"></a>Data manipulation</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In this tutorial we already learned about different buffer types like vertex and index buffers for passing primitives and uniform buffers for passing data to a shader.
And we also used images to do texture mapping.
But up until now, we always wrote data using the CPU and only did reads on the GPU.</p>
</div>
<div class="paragraph">
<p>An important concept introduced with compute shaders is the ability to arbitrarily read from <strong>and write to</strong> buffers.
For this, Vulkan offers two dedicated storage types.</p>
</div>
<div class="sect2">
<h3 id="_shader_storage_buffer_objects_ssbo"><a class="anchor" href="#_shader_storage_buffer_objects_ssbo"></a>Shader storage buffer objects (SSBO)</h3>
<div class="paragraph">
<p>A shader storage buffer (SSBO) allows shaders to read from and write to a buffer.
Using these is similar to using uniform buffer objects.
The biggest differences are that you can alias other buffer types to SSBOs and that they can be arbitrarily large.</p>
</div>
<div class="paragraph">
<p>Going back to the GPU based particle system, you might now wonder how to deal with vertices being updated (written) by the compute shader and read (drawn) by the vertex shader, as both usages would seemingly require different buffer types.</p>
</div>
<div class="paragraph">
<p>But that&#8217;s not the case.
In Vulkan you can specify multiple usages for buffers and images.
So for the particle vertex buffer to be used as a vertex buffer (in the graphics pass) and as a storage buffer (in the compute pass), you simply create the buffer with those two usage flags:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">VkBufferCreateInfo bufferInfo{};
...
bufferInfo.usage = VK_BUFFER_USAGE_VERTEX_BUFFER_BIT | VK_BUFFER_USAGE_STORAGE_BUFFER_BIT | VK_BUFFER_USAGE_TRANSFER_DST_BIT;
...

if (vkCreateBuffer(device, &amp;bufferInfo, nullptr, &amp;shaderStorageBuffers[i]) != VK_SUCCESS) {
    throw std::runtime_error("failed to create vertex buffer!");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The two flags <code>VK_BUFFER_USAGE_VERTEX_BUFFER_BIT</code> and <code>VK_BUFFER_USAGE_STORAGE_BUFFER_BIT</code> set with <code>bufferInfo.usage</code> tell the implementation that we want to use this buffer for two different scenarios: as a vertex buffer in the vertex shader and as a store buffer.
Note that we also added the <code>VK_BUFFER_USAGE_TRANSFER_DST_BIT</code> flag in here so we can transfer data from the host to the GPU.
This is crucial as we want the shader storage buffer to stay in GPU memory only (<code>VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</code>) we need to to transfer data from the host to this buffer.</p>
</div>
<div class="paragraph">
<p>Here is the same code using using the <code>createBuffer</code> helper function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">createBuffer(bufferSize, VK_BUFFER_USAGE_STORAGE_BUFFER_BIT | VK_BUFFER_USAGE_VERTEX_BUFFER_BIT | VK_BUFFER_USAGE_TRANSFER_DST_BIT, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, shaderStorageBuffers[i], shaderStorageBuffersMemory[i]);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The GLSL shader declaration for accessing such a buffer looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">struct Particle {
  vec2 position;
  vec2 velocity;
  vec4 color;
};

layout(std140, binding = 1) readonly buffer ParticleSSBOIn {
   Particle particlesIn[ ];
};

layout(std140, binding = 2) buffer ParticleSSBOOut {
   Particle particlesOut[ ];
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this example we have a typed SSBO with each particle having a position and velocity value (see the <code>Particle</code> struct).
The SSBO then contains an unbound number of particles as marked by the <code>[]</code>.
Not having to specify the number of elements in an SSBO is one of the advantages over e.g.
uniform buffers.
<code>std140</code> is a memory layout qualifier that determines how the member elements of the shader storage buffer are aligned in memory.
This gives us certain guarantees, required to map the buffers between the host and the GPU.</p>
</div>
<div class="paragraph">
<p>Writing to such a storage buffer object in the compute shader is straight-forward and similar to how you&#8217;d write to the buffer on the C&#43;&#43; side:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">particlesOut[index].position = particlesIn[index].position + particlesIn[index].velocity.xy * ubo.deltaTime;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_storage_images"><a class="anchor" href="#_storage_images"></a>Storage images</h3>
<div class="paragraph">
<p><em>Note that we won&#8217;t be doing image manipulation in this chapter.
This paragraph is here to make readers aware that compute shaders can also be used for image manipulation.</em></p>
</div>
<div class="paragraph">
<p>A storage image allows you read from and write to an image.
Typical use cases are applying image effects to textures, doing post processing (which in turn is very similar) or generating mip-maps.</p>
</div>
<div class="paragraph">
<p>This is similar for images:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">VkImageCreateInfo imageInfo {};
...
imageInfo.usage = VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT;
...

if (vkCreateImage(device, &amp;imageInfo, nullptr, &amp;textureImage) != VK_SUCCESS) {
    throw std::runtime_error("failed to create image!");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The two flags <code>VK_IMAGE_USAGE_SAMPLED_BIT</code> and <code>VK_IMAGE_USAGE_STORAGE_BIT</code> set with <code>imageInfo.usage</code> tell the implementation that we want to use this image for two different scenarios: as an image sampled in the fragment shader and as a storage image in the computer shader;</p>
</div>
<div class="paragraph">
<p>The GLSL shader declaration for storage image looks similar to sampled images used e.g.
in the fragment shader:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">layout (binding = 0, rgba8) uniform readonly image2D inputImage;
layout (binding = 1, rgba8) uniform writeonly image2D outputImage;</code></pre>
</div>
</div>
<div class="paragraph">
<p>A few differences here are additional attributes like <code>rgba8</code> for the format of the image, the <code>readonly</code> and <code>writeonly</code> qualifiers, telling the implementation that we will only read from the input image and write to the output image.
And last but not least we need to use the <code>image2D</code> type to declare a storage image.</p>
</div>
<div class="paragraph">
<p>Reading from and writing to storage images in the compute shader is then done using <code>imageLoad</code> and <code>imageStore</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">vec3 pixel = imageLoad(inputImage, ivec2(gl_GlobalInvocationID.xy)).rgb;
imageStore(outputImage, ivec2(gl_GlobalInvocationID.xy), pixel);</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_compute_queue_families"><a class="anchor" href="#_compute_queue_families"></a>Compute queue families</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In the <a href="03_Drawing_a_triangle/00_Setup/03_Physical_devices_and_queue_families.md#page_Queue-families">physical device and queue families chapter</a> we already learned about queue families and how to select a graphics queue family.
Compute uses the queue family properties flag bit <code>VK_QUEUE_COMPUTE_BIT</code>.
So if we want to do compute work, we need to get a queue from a queue family that supports compute.</p>
</div>
<div class="paragraph">
<p>Note that Vulkan requires an implementation which supports graphics operations to have at least one queue family that supports both graphics and compute operations, but it&#8217;s also possible that implementations offer a dedicated compute queue.
This dedicated compute queue (that does not have the graphics bit) hints at an asynchronous compute queue.
To keep this tutorial beginner friendly though, we&#8217;ll use a queue that can do both graphics and compute operations.
This will also save us from dealing with several advanced synchronization mechanisms.</p>
</div>
<div class="paragraph">
<p>For our compute sample we need to change the device creation code a bit:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">uint32_t queueFamilyCount = 0;
vkGetPhysicalDeviceQueueFamilyProperties(device, &amp;queueFamilyCount, nullptr);

std::vector&lt;VkQueueFamilyProperties&gt; queueFamilies(queueFamilyCount);
vkGetPhysicalDeviceQueueFamilyProperties(device, &amp;queueFamilyCount, queueFamilies.data());

int i = 0;
for (const auto&amp; queueFamily : queueFamilies) {
    if ((queueFamily.queueFlags &amp; VK_QUEUE_GRAPHICS_BIT) &amp;&amp; (queueFamily.queueFlags &amp; VK_QUEUE_COMPUTE_BIT)) {
        indices.graphicsAndComputeFamily = i;
    }

    i++;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The changed queue family index selection code will now try to find a queue family that supports both graphics and compute.</p>
</div>
<div class="paragraph">
<p>We can then get a compute queue from this queue family in <code>createLogicalDevice</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">vkGetDeviceQueue(device, indices.graphicsAndComputeFamily.value(), 0, &amp;computeQueue);</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_the_compute_shader_stage"><a class="anchor" href="#_the_compute_shader_stage"></a>The compute shader stage</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In the graphics samples we have used different pipeline stages to load shaders and access descriptors.
Compute shaders are accessed in a similar way by using the <code>VK_SHADER_STAGE_COMPUTE_BIT</code> pipeline.
So loading a compute shader is just the same as loading a vertex shader, but with a different shader stage.
We&#8217;ll talk about this in detail in the next paragraphs.
Compute also introduces a new binding point type for descriptors and pipelines named <code>VK_PIPELINE_BIND_POINT_COMPUTE</code> that we&#8217;ll have to use later on.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_loading_compute_shaders"><a class="anchor" href="#_loading_compute_shaders"></a>Loading compute shaders</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Loading compute shaders in our application is the same as loading any other other shader.
The only real difference is that we&#8217;ll need to use the <code>VK_SHADER_STAGE_COMPUTE_BIT</code> mentioned above.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">auto computeShaderCode = readFile("shaders/compute.spv");

VkShaderModule computeShaderModule = createShaderModule(computeShaderCode);

VkPipelineShaderStageCreateInfo computeShaderStageInfo{};
computeShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
computeShaderStageInfo.stage = VK_SHADER_STAGE_COMPUTE_BIT;
computeShaderStageInfo.module = computeShaderModule;
computeShaderStageInfo.pName = "main";
...</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_preparing_the_shader_storage_buffers"><a class="anchor" href="#_preparing_the_shader_storage_buffers"></a>Preparing the shader storage buffers</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Earlier on we learned that we can use shader storage buffers to pass arbitrary data to compute shaders.
For this example we will upload an array of particles to the GPU, so we can manipulate it directly in the GPU&#8217;s memory.</p>
</div>
<div class="paragraph">
<p>In the <a href="03_Drawing_a_triangle/03_Drawing/03_Frames_in_flight.html" class="xref page">frames in flight</a> chapter we talked about duplicating resources per frame in flight, so we can keep the CPU and the GPU busy.
First we declare a vector for the buffer object and the device memory backing it up:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">std::vector&lt;VkBuffer&gt; shaderStorageBuffers;
std::vector&lt;VkDeviceMemory&gt; shaderStorageBuffersMemory;</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the <code>createShaderStorageBuffers</code> we then resize those vectors to match the max.
number of frames in flight:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">shaderStorageBuffers.resize(MAX_FRAMES_IN_FLIGHT);
shaderStorageBuffersMemory.resize(MAX_FRAMES_IN_FLIGHT);</code></pre>
</div>
</div>
<div class="paragraph">
<p>With this setup in place we can start to move the initial particle information to the GPU.
We first initialize a vector of particles on the host side:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">    // Initialize particles
    std::default_random_engine rndEngine((unsigned)time(nullptr));
    std::uniform_real_distribution&lt;float&gt; rndDist(0.0f, 1.0f);

    // Initial particle positions on a circle
    std::vector&lt;Particle&gt; particles(PARTICLE_COUNT);
    for (auto&amp; particle : particles) {
        float r = 0.25f * sqrt(rndDist(rndEngine));
        float theta = rndDist(rndEngine) * 2 * 3.14159265358979323846;
        float x = r * cos(theta) * HEIGHT / WIDTH;
        float y = r * sin(theta);
        particle.position = glm::vec2(x, y);
        particle.velocity = glm::normalize(glm::vec2(x,y)) * 0.00025f;
        particle.color = glm::vec4(rndDist(rndEngine), rndDist(rndEngine), rndDist(rndEngine), 1.0f);
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>We then create a <a href="04_Vertex_buffers/02_Staging_buffer.html" class="xref page">staging buffer</a> in the host&#8217;s memory to hold the initial particle properties:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">    VkDeviceSize bufferSize = sizeof(Particle) * PARTICLE_COUNT;

    VkBuffer stagingBuffer;
    VkDeviceMemory stagingBufferMemory;
    createBuffer(bufferSize, VK_BUFFER_USAGE_TRANSFER_SRC_BIT, VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT, stagingBuffer, stagingBufferMemory);

    void* data;
    vkMapMemory(device, stagingBufferMemory, 0, bufferSize, 0, &amp;data);
    memcpy(data, particles.data(), (size_t)bufferSize);
    vkUnmapMemory(device, stagingBufferMemory);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Using this staging buffer as a source we then create the per-frame shader storage buffers and copy the particle properties from the staging buffer to each of these:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">    for (size_t i = 0; i &lt; MAX_FRAMES_IN_FLIGHT; i++) {
        createBuffer(bufferSize, VK_BUFFER_USAGE_STORAGE_BUFFER_BIT | VK_BUFFER_USAGE_VERTEX_BUFFER_BIT | VK_BUFFER_USAGE_TRANSFER_DST_BIT, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, shaderStorageBuffers[i], shaderStorageBuffersMemory[i]);
        // Copy data from the staging buffer (host) to the shader storage buffer (GPU)
        copyBuffer(stagingBuffer, shaderStorageBuffers[i], bufferSize);
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_descriptors"><a class="anchor" href="#_descriptors"></a>Descriptors</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Setting up descriptors for compute is almost identical to graphics.
The only difference is that descriptors need to have the <code>VK_SHADER_STAGE_COMPUTE_BIT</code> set to make them accessible by the compute stage:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">std::array&lt;VkDescriptorSetLayoutBinding, 3&gt; layoutBindings{};
layoutBindings[0].binding = 0;
layoutBindings[0].descriptorCount = 1;
layoutBindings[0].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
layoutBindings[0].pImmutableSamplers = nullptr;
layoutBindings[0].stageFlags = VK_SHADER_STAGE_COMPUTE_BIT;
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that you can combine shader stages here, so if you want the descriptor to be accessible from the vertex and compute stage, e.g.
for a uniform buffer with parameters shared across them, you simply set the bits for both stages:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">layoutBindings[0].stageFlags = VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_COMPUTE_BIT;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here is the descriptor setup for our sample.
The layout looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">std::array&lt;VkDescriptorSetLayoutBinding, 3&gt; layoutBindings{};
layoutBindings[0].binding = 0;
layoutBindings[0].descriptorCount = 1;
layoutBindings[0].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
layoutBindings[0].pImmutableSamplers = nullptr;
layoutBindings[0].stageFlags = VK_SHADER_STAGE_COMPUTE_BIT;

layoutBindings[1].binding = 1;
layoutBindings[1].descriptorCount = 1;
layoutBindings[1].descriptorType = VK_DESCRIPTOR_TYPE_STORAGE_BUFFER;
layoutBindings[1].pImmutableSamplers = nullptr;
layoutBindings[1].stageFlags = VK_SHADER_STAGE_COMPUTE_BIT;

layoutBindings[2].binding = 2;
layoutBindings[2].descriptorCount = 1;
layoutBindings[2].descriptorType = VK_DESCRIPTOR_TYPE_STORAGE_BUFFER;
layoutBindings[2].pImmutableSamplers = nullptr;
layoutBindings[2].stageFlags = VK_SHADER_STAGE_COMPUTE_BIT;

VkDescriptorSetLayoutCreateInfo layoutInfo{};
layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
layoutInfo.bindingCount = 3;
layoutInfo.pBindings = layoutBindings.data();

if (vkCreateDescriptorSetLayout(device, &amp;layoutInfo, nullptr, &amp;computeDescriptorSetLayout) != VK_SUCCESS) {
    throw std::runtime_error("failed to create compute descriptor set layout!");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Looking at this setup, you might wonder why we have two layout bindings for shader storage buffer objects, even though we&#8217;ll only render a single particle system.
This is because the particle positions are updated frame by frame based on a delta time.
This means that each frame needs to know about the last frames' particle positions, so it can update them with a new delta time and write them to it&#8217;s own SSBO:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/images/compute_ssbo_read_write.svg" alt="compute ssbo read write">
</div>
</div>
<div class="paragraph">
<p>For that, the compute shader needs to have access to the last and current frame&#8217;s SSBOs.
This is done by passing both to the compute shader in our descriptor setup.
See the <code>storageBufferInfoLastFrame</code> and <code>storageBufferInfoCurrentFrame</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">for (size_t i = 0; i &lt; MAX_FRAMES_IN_FLIGHT; i++) {
    VkDescriptorBufferInfo uniformBufferInfo{};
    uniformBufferInfo.buffer = uniformBuffers[i];
    uniformBufferInfo.offset = 0;
    uniformBufferInfo.range = sizeof(UniformBufferObject);

    std::array&lt;VkWriteDescriptorSet, 3&gt; descriptorWrites{};
    ...

    VkDescriptorBufferInfo storageBufferInfoLastFrame{};
    storageBufferInfoLastFrame.buffer = shaderStorageBuffers[(i - 1) % MAX_FRAMES_IN_FLIGHT];
    storageBufferInfoLastFrame.offset = 0;
    storageBufferInfoLastFrame.range = sizeof(Particle) * PARTICLE_COUNT;

    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = computeDescriptorSets[i];
    descriptorWrites[1].dstBinding = 1;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_STORAGE_BUFFER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pBufferInfo = &amp;storageBufferInfoLastFrame;

    VkDescriptorBufferInfo storageBufferInfoCurrentFrame{};
    storageBufferInfoCurrentFrame.buffer = shaderStorageBuffers[i];
    storageBufferInfoCurrentFrame.offset = 0;
    storageBufferInfoCurrentFrame.range = sizeof(Particle) * PARTICLE_COUNT;

    descriptorWrites[2].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[2].dstSet = computeDescriptorSets[i];
    descriptorWrites[2].dstBinding = 2;
    descriptorWrites[2].dstArrayElement = 0;
    descriptorWrites[2].descriptorType = VK_DESCRIPTOR_TYPE_STORAGE_BUFFER;
    descriptorWrites[2].descriptorCount = 1;
    descriptorWrites[2].pBufferInfo = &amp;storageBufferInfoCurrentFrame;

    vkUpdateDescriptorSets(device, 3, descriptorWrites.data(), 0, nullptr);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Remember that we also have to request the descriptor types for the SSBOs from our descriptor pool:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">std::array&lt;VkDescriptorPoolSize, 2&gt; poolSizes{};
...

poolSizes[1].type = VK_DESCRIPTOR_TYPE_STORAGE_BUFFER;
poolSizes[1].descriptorCount = static_cast&lt;uint32_t&gt;(MAX_FRAMES_IN_FLIGHT) * 2;</code></pre>
</div>
</div>
<div class="paragraph">
<p>We need to double the number of <code>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER</code> types requested from the pool by two because our sets reference the SSBOs of the last and current frame.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_compute_pipelines"><a class="anchor" href="#_compute_pipelines"></a>Compute pipelines</h2>
<div class="sectionbody">
<div class="paragraph">
<p>As compute is not a part of the graphics pipeline, we can&#8217;t use <code>vkCreateGraphicsPipelines</code>.
Instead we need to create a dedicated compute pipeline with <code>vkCreateComputePipelines</code> for running our compute commands.
Since a compute pipeline does not touch any of the rasterization state, it has a lot less state than a graphics pipeline:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">VkComputePipelineCreateInfo pipelineInfo{};
pipelineInfo.sType = VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO;
pipelineInfo.layout = computePipelineLayout;
pipelineInfo.stage = computeShaderStageInfo;

if (vkCreateComputePipelines(device, VK_NULL_HANDLE, 1, &amp;pipelineInfo, nullptr, &amp;computePipeline) != VK_SUCCESS) {
    throw std::runtime_error("failed to create compute pipeline!");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The setup is a lot simpler, as we only require one shader stage and a pipeline layout.
The pipeline layout works the same as with the graphics pipeline:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">VkPipelineLayoutCreateInfo pipelineLayoutInfo{};
pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
pipelineLayoutInfo.setLayoutCount = 1;
pipelineLayoutInfo.pSetLayouts = &amp;computeDescriptorSetLayout;

if (vkCreatePipelineLayout(device, &amp;pipelineLayoutInfo, nullptr, &amp;computePipelineLayout) != VK_SUCCESS) {
    throw std::runtime_error("failed to create compute pipeline layout!");
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_compute_space"><a class="anchor" href="#_compute_space"></a>Compute space</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Before we get into how a compute shader works and how we submit compute workloads to the GPU, we need to talk about two important compute concepts: <strong>work groups</strong> and <strong>invocations</strong>.
They define an abstract execution model for how compute workloads are processed by the compute hardware of the GPU in three dimensions (x, y, and z).</p>
</div>
<div class="paragraph">
<p><strong>Work groups</strong> define how the compute workloads are formed and processed by the the compute hardware of the GPU.
You can think of them as work items the GPU has to work through.
Work group dimensions are set by the application at command buffer time using a dispatch command.</p>
</div>
<div class="paragraph">
<p>And each work group then is a collection of <strong>invocations</strong> that execute the same compute shader.
Invocations can potentially run in parallel and their dimensions are set in the compute shader.
Invocations within a single workgroup have access to shared memory.</p>
</div>
<div class="paragraph">
<p>This image shows the relation between these two in three dimensions:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/images/compute_space.svg" alt="compute space">
</div>
</div>
<div class="paragraph">
<p>The number of dimensions for work groups (defined by <code>vkCmdDispatch</code>) and invocations depends (defined by the local sizes in the compute shader) on how input data is structured.
If you e.g.
work on a one-dimensional array, like we do in this chapter, you only have to specify the x dimension for both.</p>
</div>
<div class="paragraph">
<p>As an example: If we dispatch a work group count of [64, 1, 1] with a compute shader local size of [32, 32, ,1], our compute shader will be invoked 64 x 32 x 32 = 65,536 times.</p>
</div>
<div class="paragraph">
<p>Note that the maximum count for work groups and local sizes differs from implementation to implementation, so you should always check the compute related <code>maxComputeWorkGroupCount</code>, <code>maxComputeWorkGroupInvocations</code> and <code>maxComputeWorkGroupSize</code> limits in <code>VkPhysicalDeviceLimits</code>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_compute_shaders"><a class="anchor" href="#_compute_shaders"></a>Compute shaders</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Now that we have learned about all the parts required to setup a compute shader pipeline, it&#8217;s time to take a look at compute shaders.
All of the things we learned about using GLSL shaders e.g.
for vertex and fragment shaders also applies to compute shaders.
The syntax is the same, and many concepts like passing data between the application and the shader are the same.
But there are some important differences.</p>
</div>
<div class="paragraph">
<p>A very basic compute shader for updating a linear array of particles may look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">#version 450

layout (binding = 0) uniform ParameterUBO {
    float deltaTime;
} ubo;

struct Particle {
    vec2 position;
    vec2 velocity;
    vec4 color;
};

layout(std140, binding = 1) readonly buffer ParticleSSBOIn {
   Particle particlesIn[ ];
};

layout(std140, binding = 2) buffer ParticleSSBOOut {
   Particle particlesOut[ ];
};

layout (local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

void main()
{
    uint index = gl_GlobalInvocationID.x;

    Particle particleIn = particlesIn[index];

    particlesOut[index].position = particleIn.position + particleIn.velocity.xy * ubo.deltaTime;
    particlesOut[index].velocity = particleIn.velocity;
    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The top part of the shader contains the declarations for the shader&#8217;s input.
First is a uniform buffer object at binding 0, something we already learned about in this tutorial.
Below we declare our Particle structure that matches the declaration in the C&#43;&#43; code.
Binding 1 then refers to the shader storage buffer object with the particle data from the last frame (see the descriptor setup), and binding 2 points to the SSBO for the current frame, which is the one we&#8217;ll be updating with this shader.</p>
</div>
<div class="paragraph">
<p>An interesting thing is this compute-only declaration related to the compute space:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-glsl hljs" data-lang="glsl">layout (local_size_x = 256, local_size_y = 1, local_size_z = 1) in;</code></pre>
</div>
</div>
<div class="paragraph">
<p>This defines the number invocations of this compute shader in the current work group.
As noted earlier, this is the local part of the compute space.
Hence the <code>local_</code> prefix.
As we work on a linear 1D array of particles we only need to specify a number for x dimension in <code>local_size_x</code>.</p>
</div>
<div class="paragraph">
<p>The <code>main</code> function then reads from the last frame&#8217;s SSBO and writes the updated particle position to the SSBO for the current frame.
Similar to other shader types, compute shaders have their own set of builtin input variables.
Built-ins are always prefixed with <code>gl_</code>.
One such built-in is <code>gl_GlobalInvocationID</code>, a variable that uniquely identifies the current compute shader invocation across the current dispatch.
We use this to index into our particle array.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_running_compute_commands"><a class="anchor" href="#_running_compute_commands"></a>Running compute commands</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_dispatch"><a class="anchor" href="#_dispatch"></a>Dispatch</h3>
<div class="paragraph">
<p>Now it&#8217;s time to actually tell the GPU to do some compute.
This is done by calling <code>vkCmdDispatch</code> inside a command buffer.
While not perfectly true, a dispatch is for compute as a draw call like <code>vkCmdDraw</code> is for graphics.
This dispatches a given number of compute work items in at max.
three dimensions.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">VkCommandBufferBeginInfo beginInfo{};
beginInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;

if (vkBeginCommandBuffer(commandBuffer, &amp;beginInfo) != VK_SUCCESS) {
    throw std::runtime_error("failed to begin recording command buffer!");
}

...

vkCmdBindPipeline(commandBuffer, VK_PIPELINE_BIND_POINT_COMPUTE, computePipeline);
vkCmdBindDescriptorSets(commandBuffer, VK_PIPELINE_BIND_POINT_COMPUTE, computePipelineLayout, 0, 1, &amp;computeDescriptorSets[i], 0, 0);

vkCmdDispatch(computeCommandBuffer, PARTICLE_COUNT / 256, 1, 1);

...

if (vkEndCommandBuffer(commandBuffer) != VK_SUCCESS) {
    throw std::runtime_error("failed to record command buffer!");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>vkCmdDispatch</code> will dispatch <code>PARTICLE_COUNT / 256</code> local work groups in the x dimension.
As our particles array is linear, we leave the other two dimensions at one, resulting in a one-dimensional dispatch.
But why do we divide the number of particles (in our array) by 256?
That&#8217;s because in the previous paragraph we defined that every compute shader in a work group will do 256 invocations.
So if we were to have 4096 particles, we would dispatch 16 work groups, with each work group running 256 compute shader invocations.
Getting the two numbers right usually takes some tinkering and profiling, depending on your workload and the hardware you&#8217;re running on.
If your particle size would be dynamic and can&#8217;t always be divided by e.g.
256, you can always use <code>gl_GlobalInvocationID</code> at the start of your compute shader and return from it if the global invocation index is greater than the number of your particles.</p>
</div>
<div class="paragraph">
<p>And just as was the case for the compute pipeline, a compute command buffer contains a lot less state than a graphics command buffer.
There&#8217;s no need to start a render pass or set a viewport.</p>
</div>
</div>
<div class="sect2">
<h3 id="_submitting_work"><a class="anchor" href="#_submitting_work"></a>Submitting work</h3>
<div class="paragraph">
<p>As our sample does both compute and graphics operations, we&#8217;ll be doing two submits to both the graphics and compute queue per frame (see the <code>drawFrame</code> function):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">...
if (vkQueueSubmit(computeQueue, 1, &amp;submitInfo, nullptr) != VK_SUCCESS) {
    throw std::runtime_error("failed to submit compute command buffer!");
};
...
if (vkQueueSubmit(graphicsQueue, 1, &amp;submitInfo, inFlightFences[currentFrame]) != VK_SUCCESS) {
    throw std::runtime_error("failed to submit draw command buffer!");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The first submit to the compute queue updates the particle positions using the compute shader, and the second submit will then use that updated data to draw the particle system.</p>
</div>
</div>
<div class="sect2">
<h3 id="_synchronizing_graphics_and_compute"><a class="anchor" href="#_synchronizing_graphics_and_compute"></a>Synchronizing graphics and compute</h3>
<div class="paragraph">
<p>Synchronization is an important part of Vulkan, even more so when doing compute in conjunction with graphics.
Wrong or lacking synchronization may result in the vertex stage starting to draw (=read) particles while the compute shader hasn&#8217;t finished updating (=write) them (read-after-write hazard), or the compute shader could start updating particles that are still in use by the vertex part of the pipeline (write-after-read hazard).</p>
</div>
<div class="paragraph">
<p>So we must make sure that those cases don&#8217;t happen by properly synchronizing the graphics and the compute load.
There are different ways of doing so, depending on how you submit your compute workload but in our case with two separate submits, we&#8217;ll be using <a href="03_Drawing_a_triangle/03_Drawing/02_Rendering_and_presentation.md#page_Semaphores">semaphores</a> and <a href="03_Drawing_a_triangle/03_Drawing/02_Rendering_and_presentation.md#page_Fences">fences</a> to ensure that the vertex shader won&#8217;t start fetching vertices until the compute shader has finished updating them.</p>
</div>
<div class="paragraph">
<p>This is necessary as even though the two submits are ordered one-after-another, there is no guarantee that they execute on the GPU in this order.
Adding in wait and signal semaphores ensures this execution order.</p>
</div>
<div class="paragraph">
<p>So we first add a new set of synchronization primitives for the compute work in <code>createSyncObjects</code>.
The compute fences, just like the graphics fences, are created in the signaled state because otherwise, the first draw would time out while waiting for the fences to be signaled as detailed <a href="03_Drawing_a_triangle/03_Drawing/02_Rendering_and_presentation.md#page_Waiting-for-the-previous-frame">here</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">std::vector&lt;VkFence&gt; computeInFlightFences;
std::vector&lt;VkSemaphore&gt; computeFinishedSemaphores;
...
computeInFlightFences.resize(MAX_FRAMES_IN_FLIGHT);
computeFinishedSemaphores.resize(MAX_FRAMES_IN_FLIGHT);

VkSemaphoreCreateInfo semaphoreInfo{};
semaphoreInfo.sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO;

VkFenceCreateInfo fenceInfo{};
fenceInfo.sType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO;
fenceInfo.flags = VK_FENCE_CREATE_SIGNALED_BIT;

for (size_t i = 0; i &lt; MAX_FRAMES_IN_FLIGHT; i++) {
    ...
    if (vkCreateSemaphore(device, &amp;semaphoreInfo, nullptr, &amp;computeFinishedSemaphores[i]) != VK_SUCCESS ||
        vkCreateFence(device, &amp;fenceInfo, nullptr, &amp;computeInFlightFences[i]) != VK_SUCCESS) {
        throw std::runtime_error("failed to create compute synchronization objects for a frame!");
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We then use these to synchronize the compute buffer submission with the graphics submission:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">// Compute submission
vkWaitForFences(device, 1, &amp;computeInFlightFences[currentFrame], VK_TRUE, UINT64_MAX);

updateUniformBuffer(currentFrame);

vkResetFences(device, 1, &amp;computeInFlightFences[currentFrame]);

vkResetCommandBuffer(computeCommandBuffers[currentFrame], /*VkCommandBufferResetFlagBits*/ 0);
recordComputeCommandBuffer(computeCommandBuffers[currentFrame]);

submitInfo.commandBufferCount = 1;
submitInfo.pCommandBuffers = &amp;computeCommandBuffers[currentFrame];
submitInfo.signalSemaphoreCount = 1;
submitInfo.pSignalSemaphores = &amp;computeFinishedSemaphores[currentFrame];

if (vkQueueSubmit(computeQueue, 1, &amp;submitInfo, computeInFlightFences[currentFrame]) != VK_SUCCESS) {
    throw std::runtime_error("failed to submit compute command buffer!");
};

// Graphics submission
vkWaitForFences(device, 1, &amp;inFlightFences[currentFrame], VK_TRUE, UINT64_MAX);

...

vkResetFences(device, 1, &amp;inFlightFences[currentFrame]);

vkResetCommandBuffer(commandBuffers[currentFrame], /*VkCommandBufferResetFlagBits*/ 0);
recordCommandBuffer(commandBuffers[currentFrame], imageIndex);

VkSemaphore waitSemaphores[] = { computeFinishedSemaphores[currentFrame], imageAvailableSemaphores[currentFrame] };
VkPipelineStageFlags waitStages[] = { VK_PIPELINE_STAGE_VERTEX_INPUT_BIT, VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT };
submitInfo = {};
submitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;

submitInfo.waitSemaphoreCount = 2;
submitInfo.pWaitSemaphores = waitSemaphores;
submitInfo.pWaitDstStageMask = waitStages;
submitInfo.commandBufferCount = 1;
submitInfo.pCommandBuffers = &amp;commandBuffers[currentFrame];
submitInfo.signalSemaphoreCount = 1;
submitInfo.pSignalSemaphores = &amp;renderFinishedSemaphores[currentFrame];

if (vkQueueSubmit(graphicsQueue, 1, &amp;submitInfo, inFlightFences[currentFrame]) != VK_SUCCESS) {
    throw std::runtime_error("failed to submit draw command buffer!");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Similar to the sample in the <a href="03_Drawing_a_triangle/03_Drawing/02_Rendering_and_presentation.md#page_Semaphores">semaphores chapter</a>, this setup will immediately run the compute shader as we haven&#8217;t specified any wait semaphores.
This is fine, as we are waiting for the compute command buffer of the current frame to finish execution before the compute submission with the <code>vkWaitForFences</code> command.</p>
</div>
<div class="paragraph">
<p>The graphics submission on the other hand needs to wait for the compute work to finish so it doesn&#8217;t start fetching vertices while the compute buffer is still updating them.
So we wait on the <code>computeFinishedSemaphores</code> for the current frame and have the graphics submission wait on the <code>VK_PIPELINE_STAGE_VERTEX_INPUT_BIT</code> stage, where vertices are consumed.</p>
</div>
<div class="paragraph">
<p>But it also needs to wait for presentation so the fragment shader won&#8217;t output to the color attachments until the image has been presented.
So we also wait on the <code>imageAvailableSemaphores</code> on the current frame at the <code>VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT</code> stage.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_drawing_the_particle_system"><a class="anchor" href="#_drawing_the_particle_system"></a>Drawing the particle system</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Earlier on, we learned that buffers in Vulkan can have multiple use-cases and so we created the shader storage buffer that contains our particles with both the shader storage buffer bit and the vertex buffer bit.
This means that we can use the shader storage buffer for drawing just as we used "pure" vertex buffers in the previous chapters.</p>
</div>
<div class="paragraph">
<p>We first setup the vertex input state to match our particle structure:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">struct Particle {
    ...

    static std::array&lt;VkVertexInputAttributeDescription, 2&gt; getAttributeDescriptions() {
        std::array&lt;VkVertexInputAttributeDescription, 2&gt; attributeDescriptions{};

        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 0;
        attributeDescriptions[0].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[0].offset = offsetof(Particle, position);

        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 1;
        attributeDescriptions[1].format = VK_FORMAT_R32G32B32A32_SFLOAT;
        attributeDescriptions[1].offset = offsetof(Particle, color);

        return attributeDescriptions;
    }
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that we don&#8217;t add <code>velocity</code> to the vertex input attributes, as this is only used by the compute shader.</p>
</div>
<div class="paragraph">
<p>We then bind and draw it like we would with any vertex buffer:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">vkCmdBindVertexBuffers(commandBuffer, 0, 1, &amp;shaderStorageBuffer[currentFrame], offsets);

vkCmdDraw(commandBuffer, PARTICLE_COUNT, 1, 0, 0);</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_conclusion"><a class="anchor" href="#_conclusion"></a>Conclusion</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In this chapter, we learned how to use compute shaders to offload work from the CPU to the GPU.
Without compute shaders, many effects in modern games and applications would either not be possible or would run a lot slower.
But even more than graphics, compute has a lot of use-cases, and this chapter only gives you a glimpse of what&#8217;s possible.
So now that you know how to use compute shaders, you may want to take look at some advanced compute topics like:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Shared memory</p>
</li>
<li>
<p><a href="https://github.com/KhronosGroup/Vulkan-Samples/tree/master/samples/performance/async_compute">Asynchronous compute</a></p>
</li>
<li>
<p>Atomic operations</p>
</li>
<li>
<p><a href="https://www.khronos.org/blog/vulkan-subgroup-tutorial">Subgroups</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You can find some advanced compute samples in the <a href="https://github.com/KhronosGroup/Vulkan-Samples/tree/master/samples/api">official Khronos Vulkan Samples repository</a>.</p>
</div>
<div class="paragraph">
<p><a href="_attachments/31_compute_shader.cpp">C&#43;&#43; code</a> / <a href="_attachments/31_shader_compute.vert">Vertex shader</a> / <a href="_attachments/31_shader_compute.frag">Fragment shader</a> / <a href="_attachments/31_shader_compute.comp">Compute shader</a></p>
</div>
</div>
</div>
</article>
  </div>
</main>
</div>
<footer class="footer">
    <!--
  <p>This page was built using the Antora default UI.</p>
  <p>The source code for this UI is licensed under the terms of the MPL-2.0 license.</p>
    -->
</footer>
<script id="site-script" src="../../_/js/site.js" data-ui-root-path="../../_"></script>
<script async src="../../_/js/vendor/highlight.js"></script>
<script src="../../_/js/vendor/lunr.js"></script>
<script src="../../_/js/search-ui.js" id="search-ui-script" data-site-root-path="../.." data-snippet-length="100" data-stylesheet="../../_/css/search.css"></script>
<script async src="../../search-index.js"></script>
  </body>
</html>

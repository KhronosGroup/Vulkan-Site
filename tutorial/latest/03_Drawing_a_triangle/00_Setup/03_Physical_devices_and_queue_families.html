<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Untitled :: Vulkan Documentation Project</title>
    <meta name="generator" content="Antora 3.1.4">
    <link rel="stylesheet" href="../../../../_/css/site.css">
    <link rel="apple-touch-icon" sizes="180x180" href="../../../../_/img/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="../../../../_/img/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="../../../../_/img/favicon-16x16.png">
    <link rel="manifest" href="../../../../_/static/site.webmanifest">
    <link rel="mask-icon" href="../../../../_/img/safari-pinned-tab.svg" color="#a41e22">
    <meta name="msapplication-TileColor" content="#ffc40d">
    <meta name="theme-color" content="#ffffff">
    <script>var uiRootPath = '../../../../_'</script>
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="../../../.."><img class="navbar-item" alt="Vulkan White Label" src="../../../../_/Vulkan_Docs.svg" /></a>
      <div class="navbar-item search hide-for-print">
        <div id="search-field" class="field">
          <label for="search-input"></label><input id="search-input" type="text" placeholder="Search the docs">
        </div>
      </div>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <!-- <a class="navbar-item" href="#">Home</a> -->
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Specs</a>
          <div class="navbar-dropdown is-right">
            <a class="navbar-item" href="../../../../spec/latest/chapters/introduction.html">Vulkan 1.3</a>
            <a class="navbar-item" href="https://registry.khronos.org/OpenGL/specs/gl/GLSLangSpec.4.60.html">GLSL</a>
            <a class="navbar-item" href="../../../../guide/latest/hlsl.html">HLSL</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Education</a>
          <div class="navbar-dropdown is-right">
            <a class="navbar-item" href="../../../../guide/latest/index.html">Vulkan Guide</a>
            <a class="navbar-item" href="../../../../tutorial/latest/index.html">Vulkan Tutorial</a>
            <a class="navbar-item" href="../../../../samples/latest/README.html">Vulkan Samples</a>
            <a class="navbar-item" href="https://www.youtube.com/c/vulkan">YouTube</a>
            <a class="navbar-item" href="https://vulkan.org">More Info at Vulkan.org</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Community</a>
          <div class="navbar-dropdown is-right">
            <a class="navbar-item" href="https://discord.gg/vulkan">Vulkan Discord</a>
            <a class="navbar-item" href="https://reddit.com/r/vulkan">Reddit</a>
            <a class="navbar-item" href="https://stackoverflow.com/questions/tagged/vulkan">Stack Overflow</a>
            <a class="navbar-item" href="https://fosstodon.org/@vulkan">Mastodon</a>
          </div>
        </div>
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="tutorial" data-version="latest">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="../../00_Introduction.html">Khronos Vulkan Tutorial</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../00_Introduction.html">Introduction</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../01_Overview.html">Overview</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../02_Development_environment.html">Development environment</a>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="00_Base_code.html">Drawing a triangle</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="00_Base_code.html">Setup</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="00_Base_code.html">Base Code</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="01_Instance.html">Instance</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="02_Validation_layers.html">Validation layers</a>
  </li>
  <li class="nav-item is-current-page" data-depth="3">
    <a class="nav-link" href="03_Physical_devices_and_queue_families.html">Physical devices and queue families</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="04_Logical_device_and_queues.html">Logical device and queues</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../01_Presentation/00_Window_surface.html">Presentation</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../01_Presentation/00_Window_surface.html">Window surface</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../01_Presentation/01_Swap_chain.html">Swap chain</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../01_Presentation/02_Image_views.html">Image views</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../02_Graphics_pipeline_basics/00_Introduction.html">Graphics pipeline basics</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../02_Graphics_pipeline_basics/00_Introduction.html">Introduction</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../02_Graphics_pipeline_basics/01_Shader_modules.html">Shader modules</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../02_Graphics_pipeline_basics/02_Fixed_functions.html">Fixed functions</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../02_Graphics_pipeline_basics/03_Render_passes.html">Render passes</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../02_Graphics_pipeline_basics/04_Conclusion.html">Conclusion</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../03_Drawing/00_Framebuffers.html">Drawing</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../03_Drawing/00_Framebuffers.html">Framebuffers</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../03_Drawing/01_Command_buffers.html">Command buffers</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../03_Drawing/02_Rendering_and_presentation.html">Rendering and presentation</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../03_Drawing/03_Frames_in_flight.html">Frames in flight</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../04_Swap_chain_recreation.html">Swap chain recreation</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../04_Vertex_buffers/00_Vertex_input_description.html">Vertex buffers</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../04_Vertex_buffers/00_Vertex_input_description.html">Vertex input description</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../04_Vertex_buffers/01_Vertex_buffer_creation.html">Vertex buffer creation</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../04_Vertex_buffers/02_Staging_buffer.html">Staging buffer</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../04_Vertex_buffers/03_Index_buffer.html">Index buffer</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../05_Uniform_buffers/00_Descriptor_set_layout_and_buffer.html">Uniform buffers</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../05_Uniform_buffers/00_Descriptor_set_layout_and_buffer.html">Descriptor layout and buffer</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../05_Uniform_buffers/01_Descriptor_pool_and_sets.html">Descriptor pool and sets</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../06_Texture_mapping/00_Images.html">Texture mapping</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../06_Texture_mapping/00_Images.html">Images</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../06_Texture_mapping/01_Image_view_and_sampler.html">Image view and sampler</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../06_Texture_mapping/02_Combined_image_sampler.html">Combined image sampler</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../07_Depth_buffering.html">Depth buffering</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../08_Loading_models.html">Loading models</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../09_Generating_Mipmaps.html">Generating Mipmaps</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../10_Multisampling.html">Multisampling</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../11_Compute_Shader.html">Compute Shader</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../90_FAQ.html">FAQ</a>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Khronos Vulkan Tutorial</span>
    <span class="version">latest</span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <a class="title" href="../../00_Introduction.html">Khronos Vulkan Tutorial</a>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="../../00_Introduction.html">latest</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <a class="title" href="../../../../guide/latest/index.html">Vulkan Guide</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../../guide/latest/index.html">latest</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <a class="title" href="../../../../samples/latest/README.html">Vulkan Samples</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../../samples/latest/README.html">latest</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <a class="title" href="../../../../spec/latest/index.html">Vulkan Specification and Proposals</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../../spec/latest/index.html">latest</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../../../../spec/latest/index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../../00_Introduction.html">Khronos Vulkan Tutorial</a></li>
    <li><a href="00_Base_code.html">Drawing a triangle</a></li>
    <li><a href="00_Base_code.html">Setup</a></li>
    <li><a href="03_Physical_devices_and_queue_families.html">Physical devices and queue families</a></li>
  </ul>
</nav>
    <!--
  <div class="edit-this-page"><a href="https://github.com/KhronosGroup/Vulkan-Tutorial/edit/main/antora/modules/ROOT/pages/03_Drawing_a_triangle/00_Setup/03_Physical_devices_and_queue_families.adoc">Edit this Page</a></div>
      -->
</div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<div class="sect1">
<h2 id="_selecting_a_physical_device"><a class="anchor" href="#_selecting_a_physical_device"></a>Selecting a physical device</h2>
<div class="sectionbody">
<div class="paragraph">
<p>After initializing the Vulkan library through a VkInstance we need to look for and select a graphics card in the system that supports the features we need.
In fact we can select any number of graphics cards and use them simultaneously, but in this tutorial we&#8217;ll stick to the first graphics card that suits our needs.</p>
</div>
<div class="paragraph">
<p>We&#8217;ll add a function <code>pickPhysicalDevice</code> and add a call to it in the <code>initVulkan</code> function.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">void initVulkan() {
    createInstance();
    setupDebugMessenger();
    pickPhysicalDevice();
}

void pickPhysicalDevice() {

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The graphics card that we&#8217;ll end up selecting will be stored in a VkPhysicalDevice handle that is added as a new class member.
This object will be implicitly destroyed when the VkInstance is destroyed, so we won&#8217;t need to do anything new in the <code>cleanup</code> function.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">VkPhysicalDevice physicalDevice = VK_NULL_HANDLE;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Listing the graphics cards is very similar to listing extensions and starts with querying just the number.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">uint32_t deviceCount = 0;
vkEnumeratePhysicalDevices(instance, &amp;deviceCount, nullptr);</code></pre>
</div>
</div>
<div class="paragraph">
<p>If there are 0 devices with Vulkan support then there is no point going further.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">if (deviceCount == 0) {
    throw std::runtime_error("failed to find GPUs with Vulkan support!");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Otherwise we can now allocate an array to hold all of the VkPhysicalDevice handles.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">std::vector&lt;VkPhysicalDevice&gt; devices(deviceCount);
vkEnumeratePhysicalDevices(instance, &amp;deviceCount, devices.data());</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now we need to evaluate each of them and check if they are suitable for the operations we want to perform, because not all graphics cards are created equal.
For that we&#8217;ll introduce a new function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">bool isDeviceSuitable(VkPhysicalDevice device) {
    return true;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>And we&#8217;ll check if any of the physical devices meet the requirements that we&#8217;ll add to that function.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">for (const auto&amp; device : devices) {
    if (isDeviceSuitable(device)) {
        physicalDevice = device;
        break;
    }
}

if (physicalDevice == VK_NULL_HANDLE) {
    throw std::runtime_error("failed to find a suitable GPU!");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The next section will introduce the first requirements that we&#8217;ll check for in the <code>isDeviceSuitable</code> function.
As we&#8217;ll start using more Vulkan features in the later chapters we will also extend this function to include more checks.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_base_device_suitability_checks"><a class="anchor" href="#_base_device_suitability_checks"></a>Base device suitability checks</h2>
<div class="sectionbody">
<div class="paragraph">
<p>To evaluate the suitability of a device we can start by querying for some details.
Basic device properties like the name, type and supported Vulkan version can be queried using vkGetPhysicalDeviceProperties.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">VkPhysicalDeviceProperties deviceProperties;
vkGetPhysicalDeviceProperties(device, &amp;deviceProperties);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The support for optional features like texture compression, 64 bit floats and multi viewport rendering (useful for VR) can be queried using vkGetPhysicalDeviceFeatures:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">VkPhysicalDeviceFeatures deviceFeatures;
vkGetPhysicalDeviceFeatures(device, &amp;deviceFeatures);</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are more details that can be queried from devices that we&#8217;ll discuss later concerning device memory and queue families (see the next section).</p>
</div>
<div class="paragraph">
<p>As an example, let&#8217;s say we consider our application only usable for dedicated graphics cards that support geometry shaders.
Then the <code>isDeviceSuitable</code> function would look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">bool isDeviceSuitable(VkPhysicalDevice device) {
    VkPhysicalDeviceProperties deviceProperties;
    VkPhysicalDeviceFeatures deviceFeatures;
    vkGetPhysicalDeviceProperties(device, &amp;deviceProperties);
    vkGetPhysicalDeviceFeatures(device, &amp;deviceFeatures);

    return deviceProperties.deviceType == VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU &amp;&amp;
           deviceFeatures.geometryShader;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Instead of just checking if a device is suitable or not and going with the first one, you could also give each device a score and pick the highest one.
That way you could favor a dedicated graphics card by giving it a higher score, but fall back to an integrated GPU if that&#8217;s the only available one.
You could implement something like that as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">#include &lt;map&gt;

...

void pickPhysicalDevice() {
    ...

    // Use an ordered map to automatically sort candidates by increasing score
    std::multimap&lt;int, VkPhysicalDevice&gt; candidates;

    for (const auto&amp; device : devices) {
        int score = rateDeviceSuitability(device);
        candidates.insert(std::make_pair(score, device));
    }

    // Check if the best candidate is suitable at all
    if (candidates.rbegin()-&gt;first &gt; 0) {
        physicalDevice = candidates.rbegin()-&gt;second;
    } else {
        throw std::runtime_error("failed to find a suitable GPU!");
    }
}

int rateDeviceSuitability(VkPhysicalDevice device) {
    ...

    int score = 0;

    // Discrete GPUs have a significant performance advantage
    if (deviceProperties.deviceType == VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU) {
        score += 1000;
    }

    // Maximum possible size of textures affects graphics quality
    score += deviceProperties.limits.maxImageDimension2D;

    // Application can't function without geometry shaders
    if (!deviceFeatures.geometryShader) {
        return 0;
    }

    return score;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You don&#8217;t need to implement all that for this tutorial, but it&#8217;s to give you an idea of how you could design your device selection process.
Of course you can also just display the names of the choices and allow the user to select.</p>
</div>
<div class="paragraph">
<p>Because we&#8217;re just starting out, Vulkan support is the only thing we need and therefore we&#8217;ll settle for just any GPU:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">bool isDeviceSuitable(VkPhysicalDevice device) {
    return true;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the next section we&#8217;ll discuss the first real required feature to check for.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_queue_families"><a class="anchor" href="#_queue_families"></a>Queue families</h2>
<div class="sectionbody">
<div class="paragraph">
<p>It has been briefly touched upon before that almost every operation in Vulkan, anything from drawing to uploading textures, requires commands to be submitted to a queue.
There are different types of queues that originate from different <em>queue families</em> and each family of queues allows only a subset of commands.
For example, there could be a queue family that only allows processing of compute commands or one that only allows memory transfer related commands.</p>
</div>
<div class="paragraph">
<p>We need to check which queue families are supported by the device and which one of these supports the commands that we want to use.
For that purpose we&#8217;ll add a new function <code>findQueueFamilies</code> that looks for all the queue families we need.</p>
</div>
<div class="paragraph">
<p>Right now we are only going to look for a queue that supports graphics commands, so the function could look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">uint32_t findQueueFamilies(VkPhysicalDevice device) {
    // Logic to find graphics queue family
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>However, in one of the next chapters we&#8217;re already going to look for yet another queue, so it&#8217;s better to prepare for that and bundle the indices into a struct:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">struct QueueFamilyIndices {
    uint32_t graphicsFamily;
};

QueueFamilyIndices findQueueFamilies(VkPhysicalDevice device) {
    QueueFamilyIndices indices;
    // Logic to find queue family indices to populate struct with
    return indices;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>But what if a queue family is not available?
We could throw an exception in <code>findQueueFamilies</code>, but this function is not really the right place to make decisions about device suitability.
For example, we may <em>prefer</em> devices with a dedicated transfer queue family, but not require it.
Therefore we need some way of indicating whether a particular queue family was found.</p>
</div>
<div class="paragraph">
<p>It&#8217;s not really possible to use a magic value to indicate the nonexistence of a queue family, since any value of <code>uint32_t</code> could in theory be a valid queue family index including <code>0</code>.
Luckily C&#43;&#43;17 introduced a data structure to distinguish between the case of a value existing or not:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">#include &lt;optional&gt;

...

std::optional&lt;uint32_t&gt; graphicsFamily;

std::cout &lt;&lt; std::boolalpha &lt;&lt; graphicsFamily.has_value() &lt;&lt; std::endl; // false

graphicsFamily = 0;

std::cout &lt;&lt; std::boolalpha &lt;&lt; graphicsFamily.has_value() &lt;&lt; std::endl; // true</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>std::optional</code> is a wrapper that contains no value until you assign something to it.
At any point you can query if it contains a value or not by calling its <code>has_value()</code> member function.
That means that we can change the logic to:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">#include &lt;optional&gt;

...

struct QueueFamilyIndices {
    std::optional&lt;uint32_t&gt; graphicsFamily;
};

QueueFamilyIndices findQueueFamilies(VkPhysicalDevice device) {
    QueueFamilyIndices indices;
    // Assign index to queue families that could be found
    return indices;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can now begin to actually implement <code>findQueueFamilies</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">QueueFamilyIndices findQueueFamilies(VkPhysicalDevice device) {
    QueueFamilyIndices indices;

    ...

    return indices;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The process of retrieving the list of queue families is exactly what you expect and uses <code>vkGetPhysicalDeviceQueueFamilyProperties</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">uint32_t queueFamilyCount = 0;
vkGetPhysicalDeviceQueueFamilyProperties(device, &amp;queueFamilyCount, nullptr);

std::vector&lt;VkQueueFamilyProperties&gt; queueFamilies(queueFamilyCount);
vkGetPhysicalDeviceQueueFamilyProperties(device, &amp;queueFamilyCount, queueFamilies.data());</code></pre>
</div>
</div>
<div class="paragraph">
<p>The VkQueueFamilyProperties struct contains some details about the queue family, including the type of operations that are supported and the number of queues that can be created based on that family.
We need to find at least one queue family that supports <code>VK_QUEUE_GRAPHICS_BIT</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">int i = 0;
for (const auto&amp; queueFamily : queueFamilies) {
    if (queueFamily.queueFlags &amp; VK_QUEUE_GRAPHICS_BIT) {
        indices.graphicsFamily = i;
    }

    i++;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now that we have this fancy queue family lookup function, we can use it as a check in the <code>isDeviceSuitable</code> function to ensure that the device can process the commands we want to use:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">bool isDeviceSuitable(VkPhysicalDevice device) {
    QueueFamilyIndices indices = findQueueFamilies(device);

    return indices.graphicsFamily.has_value();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>To make this a little bit more convenient, we&#8217;ll also add a generic check to the struct itself:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">struct QueueFamilyIndices {
    std::optional&lt;uint32_t&gt; graphicsFamily;

    bool isComplete() {
        return graphicsFamily.has_value();
    }
};

...

bool isDeviceSuitable(VkPhysicalDevice device) {
    QueueFamilyIndices indices = findQueueFamilies(device);

    return indices.isComplete();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can now also use this for an early exit from <code>findQueueFamilies</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">for (const auto&amp; queueFamily : queueFamilies) {
    ...

    if (indices.isComplete()) {
        break;
    }

    i++;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Great, that&#8217;s all we need for now to find the right physical device!
The next step is to <a href="04_Logical_device_and_queues.html" class="xref page">create a logical device</a> to interface with it.</p>
</div>
<div class="paragraph">
<p><a href="../../_attachments/03_physical_device_selection.cpp">C&#43;&#43; code</a></p>
</div>
</div>
</div>
</article>
  </div>
</main>
</div>
<footer class="footer">
    <!--
  <p>This page was built using the Antora default UI.</p>
  <p>The source code for this UI is licensed under the terms of the MPL-2.0 license.</p>
    -->
</footer>
<script id="site-script" src="../../../../_/js/site.js" data-ui-root-path="../../../../_"></script>
<script async src="../../../../_/js/vendor/highlight.js"></script>
<script src="../../../../_/js/vendor/lunr.js"></script>
<script src="../../../../_/js/search-ui.js" id="search-ui-script" data-site-root-path="../../../.." data-snippet-length="100" data-stylesheet="../../../../_/css/search.css"></script>
<script async src="../../../../search-index.js"></script>
  </body>
</html>
